This is Info file elisp, produced by Makeinfo version 1.68 from the
input file elisp.texi.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY

   This version is the edition 2.5 of the GNU Emacs Lisp Reference
Manual.  It corresponds to Emacs Version 20.3

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307  USA

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: elisp,  Node: Coding Conventions,  Next: Compilation Tips,  Up: Tips

Emacs Lisp Coding Conventions
=============================

   Here are conventions that you should follow when writing Emacs Lisp
code intended for widespread use:

   * Since all global variables share the same name space, and all
     functions share another name space, you should choose a short word
     to distinguish your program from other Lisp programs.  Then take
     care to begin the names of all global variables, constants, and
     functions with the chosen prefix.  This helps avoid name conflicts.

     This recommendation applies even to names for traditional Lisp
     primitives that are not primitives in Emacs Lisp--even to
     `copy-list'.  Believe it or not, there is more than one plausible
     way to define `copy-list'.  Play it safe; append your name prefix
     to produce a name like `foo-copy-list' or `mylib-copy-list'
     instead.

     If you write a function that you think ought to be added to Emacs
     under a certain name, such as `twiddle-files', don't call it by
     that name in your program.  Call it `mylib-twiddle-files' in your
     program, and send mail to `bug-gnu-emacs@gnu.org' suggesting we add
     it to Emacs.  If and when we do, we can change the name easily
     enough.

     If one prefix is insufficient, your package may use two or three
     alternative common prefixes, so long as they make sense.

     Separate the prefix from the rest of the symbol name with a hyphen,
     `-'.  This will be consistent with Emacs itself and with most Emacs
     Lisp programs.

   * It is often useful to put a call to `provide' in each separate
     library program, at least if there is more than one entry point to
     the program.

   * If a file requires certain other library programs to be loaded
     beforehand, then the comments at the beginning of the file should
     say so.  Also, use `require' to make sure they are loaded.

   * If one file FOO uses a macro defined in another file BAR, FOO
     should contain this expression before the first use of the macro:

          (eval-when-compile (require 'BAR))

     (And the library BAR should contain `(provide 'BAR)', to make the
     `require' work.)  This will cause BAR to be loaded when you
     byte-compile FOO.  Otherwise, you risk compiling FOO without the
     necessary macro loaded, and that would produce compiled code that
     won't work right.  *Note Compiling Macros::.

     Using `eval-when-compile' avoids loading BAR when the compiled
     version of FOO is *used*.

   * When defining a major mode, please follow the major mode
     conventions.  *Note Major Mode Conventions::.

   * When defining a minor mode, please follow the minor mode
     conventions.  *Note Minor Mode Conventions::.

   * If the purpose of a function is to tell you whether a certain
     condition is true or false, give the function a name that ends in
     `p'.  If the name is one word, add just `p'; if the name is
     multiple words, add `-p'.  Examples are `framep' and
     `frame-live-p'.

   * If a user option variable records a true-or-false condition, give
     it a name that ends in `-flag'.

   * Please do not define `C-c LETTER' as a key in your major modes.
     These sequences are reserved for users; they are the *only*
     sequences reserved for users, so do not block them.

     Instead, define sequences consisting of `C-c' followed by a control
     character, a digit, or certain punctuation characters.  These
     sequences are reserved for major modes.

     Changing all the Emacs major modes to follow this convention was a
     lot of work.  Abandoning this convention would make that work go
     to waste, and inconvenience users.

   * Sequences consisting of `C-c' followed by `{', `}', `<', `>', `:'
     or `;' are also reserved for major modes.

   * Sequences consisting of `C-c' followed by any other punctuation
     character are allocated for minor modes.  Using them in a major
     mode is not absolutely prohibited, but if you do that, the major
     mode binding may be shadowed from time to time by minor modes.

   * Function keys <F5> through <F9> without modifier keys are reserved
     for users to define.

   * Do not bind `C-h' following any prefix character (including
     `C-c').  If you don't bind `C-h', it is automatically available as
     a help character for listing the subcommands of the prefix
     character.

   * Do not bind a key sequence ending in <ESC> except following
     another <ESC>.  (That is, it is OK to bind a sequence ending in
     `<ESC> <ESC>'.)

     The reason for this rule is that a non-prefix binding for <ESC> in
     any context prevents recognition of escape sequences as function
     keys in that context.

   * Anything which acts like a temporary mode or state which the user
     can enter and leave should define `<ESC> <ESC>' of `<ESC> <ESC>
     <ESC>' as a way to escape.

     For a state which accepts ordinary Emacs commands, or more
     generally any kind of state in which <ESC> followed by a function
     key or arrow key is potentially meaningful, then you must not
     define `<ESC> <ESC>', since that would preclude recognizing an
     escape sequence after <ESC>.  In these states, you should define
     `<ESC> <ESC> <ESC>' as the way to escape.  Otherwise, define
     `<ESC> <ESC>' instead.

   * Applications should not bind mouse events based on button 1 with
     the shift key held down.  These events include `S-mouse-1',
     `M-S-mouse-1', `C-S-mouse-1', and so on.  They are reserved for
     users.

   * Special major modes used for read-only text should usually redefine
     `mouse-2' and <RET> to trace some sort of reference in the text.
     Modes such as Dired, Info, Compilation, and Occur redefine it in
     this way.

   * When a package provides a modification of ordinary Emacs behavior,
     it is good to include a command to enable and disable the feature,
     Provide a command named `WHATEVER-mode' which turns the feature on
     or off, and make it autoload (*note Autoload::.).  Design the
     package so that simply loading it has no visible effect--that
     should not enable the feature.  Users will request the feature by
     invoking the command.

   * It is a bad idea to define aliases for the Emacs primitives.  Use
     the standard names instead.

   * Redefining (or advising) an Emacs primitive is discouraged.  It
     may do the right thing for a particular program, but there is no
     telling what other programs might break as a result.

   * If a file does replace any of the functions or library programs of
     standard Emacs, prominent comments at the beginning of the file
     should say which functions are replaced, and how the behavior of
     the replacements differs from that of the originals.

   * Please keep the names of your Emacs Lisp source files to 13
     characters or less.  This way, if the files are compiled, the
     compiled files' names will be 14 characters or less, which is
     short enough to fit on all kinds of Unix systems.

   * Don't use `next-line' or `previous-line' in programs; nearly
     always, `forward-line' is more convenient as well as more
     predictable and robust.  *Note Text Lines::.

   * Don't call functions that set the mark, unless setting the mark is
     one of the intended features of your program.  The mark is a
     user-level feature, so it is incorrect to change the mark except
     to supply a value for the user's benefit.  *Note The Mark::.

     In particular, don't use any of these functions:

        * `beginning-of-buffer', `end-of-buffer'

        * `replace-string', `replace-regexp'

     If you just want to move point, or replace a certain string,
     without any of the other features intended for interactive users,
     you can replace these functions with one or two lines of simple
     Lisp code.

   * Use lists rather than vectors, except when there is a particular
     reason to use a vector.  Lisp has more facilities for manipulating
     lists than for vectors, and working with lists is usually more
     convenient.

     Vectors are advantageous for tables that are substantial in size
     and are accessed in random order (not searched front to back),
     provided there is no need to insert or delete elements (only lists
     allow that).

   * The recommended way to print a message in the echo area is with
     the `message' function, not `princ'.  *Note The Echo Area::.

   * When you encounter an error condition, call the function `error'
     (or `signal').  The function `error' does not return.  *Note
     Signaling Errors::.

     Do not use `message', `throw', `sleep-for', or `beep' to report
     errors.

   * An error message should start with a capital letter but should not
     end with a period.

   * Many commands that take a long time to execute display a message
     that says `Operating...' when they start, and change it to
     `Operating...done' when they finish.  Please keep the style of
     these messages uniform: *no* space around the ellipsis, and *no*
     period at the end.

   * Try to avoid using recursive edits.  Instead, do what the Rmail `e'
     command does: use a new local keymap that contains one command
     defined to switch back to the old local keymap.  Or do what the
     `edit-options' command does: switch to another buffer and let the
     user switch back at will.  *Note Recursive Editing::.

   * In some other systems there is a convention of choosing variable
     names that begin and end with `*'.  We don't use that convention
     in Emacs Lisp, so please don't use it in your programs.  (Emacs
     uses such names only for special-purpose buffers.)  The users will
     find Emacs more coherent if all libraries use the same conventions.

   * Try to avoid compiler warnings about undefined free variables, by
     adding `defvar' definitions for these variables.

     If you bind a variable in one function, and use it or set it in
     another function, the compiler warns about the latter function
     unless the variable has a definition.  But often these variables
     have short names, and it is not clean for Lisp packages to define
     such variable names.  Therefore, you should rename the variable to
     start with the name prefix used for the other functions and
     variables in your package.

   * Indent each function with `C-M-q' (`indent-sexp') using the
     default indentation parameters.

   * Don't make a habit of putting close-parentheses on lines by
     themselves; Lisp programmers find this disconcerting.  Once in a
     while, when there is a sequence of many consecutive
     close-parentheses, it may make sense to split the sequence in one
     or two significant places.

   * Please put a copyright notice on the file if you give copies to
     anyone.  Use a message like this one:

          ;; Copyright (C) YEAR NAME
          
          ;; This program is free software; you can redistribute it and/or
          ;; modify it under the terms of the GNU General Public License as
          ;; published by the Free Software Foundation; either version 2 of
          ;; the License, or (at your option) any later version.
          
          ;; This program is distributed in the hope that it will be
          ;; useful, but WITHOUT ANY WARRANTY; without even the implied
          ;; warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
          ;; PURPOSE.  See the GNU General Public License for more details.
          
          ;; You should have received a copy of the GNU General Public
          ;; License along with this program; if not, write to the Free
          ;; Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
          ;; MA 02111-1307 USA

     If you have signed papers to assign the copyright to the
     Foundation, then use `Free Software Foundation, Inc.' as NAME.
     Otherwise, use your name.


File: elisp,  Node: Compilation Tips,  Next: Documentation Tips,  Prev: Coding Conventions,  Up: Tips

Tips for Making Compiled Code Fast
==================================

   Here are ways of improving the execution speed of byte-compiled Lisp
programs.

   * Profile your program with the `profile' library or the `elp'
     library.  See the files `profile.el' and `elp.el' for instructions.

   * Use iteration rather than recursion whenever possible.  Function
     calls are slow in Emacs Lisp even when a compiled function is
     calling another compiled function.

   * Using the primitive list-searching functions `memq', `member',
     `assq', or `assoc' is even faster than explicit iteration.  It can
     be worth rearranging a data structure so that one of these
     primitive search functions can be used.

   * Certain built-in functions are handled specially in byte-compiled
     code, avoiding the need for an ordinary function call.  It is a
     good idea to use these functions rather than alternatives.  To see
     whether a function is handled specially by the compiler, examine
     its `byte-compile' property.  If the property is non-`nil', then
     the function is handled specially.

     For example, the following input will show you that `aref' is
     compiled specially (*note Array Functions::.):

          (get 'aref 'byte-compile)
               => byte-compile-two-args

   * If calling a small function accounts for a substantial part of your
     program's running time, make the function inline.  This eliminates
     the function call overhead.  Since making a function inline reduces
     the flexibility of changing the program, don't do it unless it
     gives a noticeable speedup in something slow enough that users
     care about the speed.  *Note Inline Functions::.


File: elisp,  Node: Documentation Tips,  Next: Comment Tips,  Prev: Compilation Tips,  Up: Tips

Tips for Documentation Strings
==============================

   Here are some tips and conventions for the writing of documentation
strings.  You can check many of these conventions by running the command
`M-x checkdoc-minor-mode'.

   * Every command, function, or variable intended for users to know
     about should have a documentation string.

   * An internal variable or subroutine of a Lisp program might as well
     have a documentation string.  In earlier Emacs versions, you could
     save space by using a comment instead of a documentation string,
     but that is no longer the case.

   * The first line of the documentation string should consist of one
     or two complete sentences that stand on their own as a summary.
     `M-x apropos' displays just the first line, and if it doesn't
     stand on its own, the result looks bad.  In particular, start the
     first line with a capital letter and end with a period.

     The documentation string can have additional lines that expand on
     the details of how to use the function or variable.  The
     additional lines should be made up of complete sentences also, but
     they may be filled if that looks good.

   * For consistency, phrase the verb in the first sentence of a
     function's documentation string as an infinitive with "to"
     omitted.  For instance, use "Return the cons of A and B." in
     preference to "Returns the cons of A and B."  Usually it looks
     good to do likewise for the rest of the first paragraph.
     Subsequent paragraphs usually look better if they have proper
     subjects.

   * Write documentation strings in the active voice, not the passive,
     and in the present tense, not the future.  For instance, use
     "Return a list containing A and B." instead of "A list containing
     A and B will be returned."

   * Avoid using the word "cause" (or its equivalents) unnecessarily.
     Instead of, "Cause Emacs to display text in boldface," write just
     "Display text in boldface."

   * Do not start or end a documentation string with whitespace.

   * Format the documentation string so that it fits in an Emacs window
     on an 80-column screen.  It is a good idea for most lines to be no
     wider than 60 characters.  The first line can be wider if
     necessary to fit the information that ought to be there.

     However, rather than simply filling the entire documentation
     string, you can make it much more readable by choosing line breaks
     with care.  Use blank lines between topics if the documentation
     string is long.

   * *Do not* indent subsequent lines of a documentation string so that
     the text is lined up in the source code with the text of the first
     line.  This looks nice in the source code, but looks bizarre when
     users view the documentation.  Remember that the indentation
     before the starting double-quote is not part of the string!

   * When the user tries to use a disabled command, Emacs displays just
     the first paragraph of its documentation string--everything
     through the first blank line.  If you wish, you can choose which
     information to include before the first blank line so as to make
     this display useful.

   * A variable's documentation string should start with `*' if the
     variable is one that users would often want to set interactively.
     If the value is a long list, or a function, or if the variable
     would be set only in init files, then don't start the
     documentation string with `*'.  *Note Defining Variables::.

   * The documentation string for a variable that is a yes-or-no flag
     should start with words such as "Non-nil means...", to make it
     clear that all non-`nil' values are equivalent and indicate
     explicitly what `nil' and non-`nil' mean.

   * When a function's documentation string mentions the value of an
     argument of the function, use the argument name in capital letters
     as if it were a name for that value.  Thus, the documentation
     string of the function `/' refers to its second argument as
     `DIVISOR', because the actual argument name is `divisor'.

     Also use all caps for meta-syntactic variables, such as when you
     show the decomposition of a list or vector into subunits, some of
     which may vary.

   * When a documentation string refers to a Lisp symbol, write it as it
     would be printed (which usually means in lower case), with
     single-quotes around it.  For example: `lambda'.  There are two
     exceptions: write t and nil without single-quotes.  (In this
     manual, we use a different convention, with single-quotes for all
     symbols.)

     Help mode automatically creates a hyperlink when a documentation
     string uses a symbol name inside single quotes, if the symbol has
     either a function or a variable definition.  You do not need to do
     anything special to make use of this feature.  However, when a
     symbol has both a function definition and a variable definition,
     and you want to refer to just one of them, you can specify which
     one by writing one of the words `variable', `option', `function',
     or `command', immediately before the symbol name.  (Case makes no
     difference in recognizing these indicator words.)  For example, if
     you write

          This function sets the variable `buffer-file-name'.

     then the hyperlink will refer only to the variable documentation of
     `buffer-file-name', and not to its function documentation.

     If a symbol has a function definition and/or a variable
     definition, but those are irrelevant to the use of the symbol that
     you are documenting, you can write the word `symbol' before the
     symbol name to prevent making any hyperlink.  For example,

          If the argument KIND-OF-RESULT is the symbol `list',
          this function returns a list of all the objects
          that satisfy the criterion.

     does not make a hyperlink to the documentation, irrelevant here,
     of the function `list'.

   * Don't write key sequences directly in documentation strings.
     Instead, use the `\\[...]' construct to stand for them.  For
     example, instead of writing `C-f', write the construct
     `\\[forward-char]'.  When Emacs displays the documentation string,
     it substitutes whatever key is currently bound to `forward-char'.
     (This is normally `C-f', but it may be some other character if the
     user has moved key bindings.)  *Note Keys in Documentation::.

   * In documentation strings for a major mode, you will want to refer
     to the key bindings of that mode's local map, rather than global
     ones.  Therefore, use the construct `\\<...>' once in the
     documentation string to specify which key map to use.  Do this
     before the first use of `\\[...]'.  The text inside the `\\<...>'
     should be the name of the variable containing the local keymap for
     the major mode.

     It is not practical to use `\\[...]' very many times, because
     display of the documentation string will become slow.  So use this
     to describe the most important commands in your major mode, and
     then use `\\{...}' to display the rest of the mode's keymap.


File: elisp,  Node: Comment Tips,  Next: Library Headers,  Prev: Documentation Tips,  Up: Tips

Tips on Writing Comments
========================

   We recommend these conventions for where to put comments and how to
indent them:

`;'
     Comments that start with a single semicolon, `;', should all be
     aligned to the same column on the right of the source code.  Such
     comments usually explain how the code on the same line does its
     job.  In Lisp mode and related modes, the `M-;'
     (`indent-for-comment') command automatically inserts such a `;' in
     the right place, or aligns such a comment if it is already present.

     This and following examples are taken from the Emacs sources.

          (setq base-version-list                 ; there was a base
                (assoc (substring fn 0 start-vn)  ; version to which
                       file-version-assoc-list))  ; this looks like
                                                  ; a subversion

`;;'
     Comments that start with two semicolons, `;;', should be aligned to
     the same level of indentation as the code.  Such comments usually
     describe the purpose of the following lines or the state of the
     program at that point.  For example:

          (prog1 (setq auto-fill-function
                       ...
                       ...
            ;; update mode line
            (force-mode-line-update)))

     Every function that has no documentation string (presumably one
     that is used only internally within the package it belongs to),
     should have instead a two-semicolon comment right before the
     function, explaining what the function does and how to call it
     properly.  Explain precisely what each argument means and how the
     function interprets its possible values.

`;;;'
     Comments that start with three semicolons, `;;;', should start at
     the left margin.  Such comments are used outside function
     definitions to make general statements explaining the design
     principles of the program.  For example:

          ;;; This Lisp code is run in Emacs
          ;;; when it is to operate as a server
          ;;; for other processes.

     Another use for triple-semicolon comments is for commenting out
     lines within a function.  We use triple-semicolons for this
     precisely so that they remain at the left margin.

          (defun foo (a)
          ;;; This is no longer necessary.
          ;;;  (force-mode-line-update)
            (message "Finished with %s" a))

`;;;;'
     Comments that start with four semicolons, `;;;;', should be aligned
     to the left margin and are used for headings of major sections of a
     program.  For example:

          ;;;; The kill ring

The indentation commands of the Lisp modes in Emacs, such as `M-;'
(`indent-for-comment') and <TAB> (`lisp-indent-line'), automatically
indent comments according to these conventions, depending on the number
of semicolons.  *Note Manipulating Comments: (emacs)Comments.


File: elisp,  Node: Library Headers,  Prev: Comment Tips,  Up: Tips

Conventional Headers for Emacs Libraries
========================================

   Emacs has conventions for using special comments in Lisp libraries
to divide them into sections and give information such as who wrote
them.  This section explains these conventions.  First, an example:

     ;;; lisp-mnt.el --- minor mode for Emacs Lisp maintainers
     
     ;; Copyright (C) 1992 Free Software Foundation, Inc.
     
     ;; Author: Eric S. Raymond <esr@snark.thyrsus.com>
     ;; Maintainer: Eric S. Raymond <esr@snark.thyrsus.com>
     ;; Created: 14 Jul 1992
     ;; Version: 1.2
     ;; Keywords: docs
     
     ;; This file is part of GNU Emacs.
     ...
     ;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
     ;; Boston, MA 02111-1307, USA.

   The very first line should have this format:

     ;;; FILENAME --- DESCRIPTION

The description should be complete in one line.

   After the copyright notice come several "header comment" lines, each
beginning with `;; HEADER-NAME:'.  Here is a table of the conventional
possibilities for HEADER-NAME:

`Author'
     This line states the name and net address of at least the principal
     author of the library.

     If there are multiple authors, you can list them on continuation
     lines led by `;;' and a tab character, like this:

          ;; Author: Ashwin Ram <Ram-Ashwin@cs.yale.edu>
          ;;      Dave Sill <de5@ornl.gov>
          ;;      Dave Brennan <brennan@hal.com>
          ;;      Eric Raymond <esr@snark.thyrsus.com>

`Maintainer'
     This line should contain a single name/address as in the Author
     line, or an address only, or the string `FSF'.  If there is no
     maintainer line, the person(s) in the Author field are presumed to
     be the maintainers.  The example above is mildly bogus because the
     maintainer line is redundant.

     The idea behind the `Author' and `Maintainer' lines is to make
     possible a Lisp function to "send mail to the maintainer" without
     having to mine the name out by hand.

     Be sure to surround the network address with `<...>' if you
     include the person's full name as well as the network address.

`Created'
     This optional line gives the original creation date of the file.
     For historical interest only.

`Version'
     If you wish to record version numbers for the individual Lisp
     program, put them in this line.

`Adapted-By'
     In this header line, place the name of the person who adapted the
     library for installation (to make it fit the style conventions, for
     example).

`Keywords'
     This line lists keywords for the `finder-by-keyword' help command.
     Please use that command to see a list of the meaningful keywords.

     This field is important; it's how people will find your package
     when they're looking for things by topic area.  To separate the
     keywords, you can use spaces, commas, or both.

   Just about every Lisp library ought to have the `Author' and
`Keywords' header comment lines.  Use the others if they are
appropriate.  You can also put in header lines with other header
names--they have no standard meanings, so they can't do any harm.

   We use additional stylized comments to subdivide the contents of the
library file.  Here is a table of them:

`;;; Commentary:'
     This begins introductory comments that explain how the library
     works.  It should come right after the copying permissions,
     terminated by a `Change Log', `History' or `Code' comment line.
     This text is used by the Finder package, so it should make sense
     in that context.

`;;; Documentation'
     This has been used in some files in place of `;;; Commentary:',
     but `;;; Commentary:' is preferred.

`;;; Change Log:'
     This begins change log information stored in the library file (if
     you store the change history there).  For most of the Lisp files
     distributed with Emacs, the change history is kept in the file
     `ChangeLog' and not in the source file at all; these files do not
     have a `;;; Change Log:' line.

`;;; Code:'
     This begins the actual code of the program.

`;;; FILENAME ends here'
     This is the "footer line"; it appears at the very end of the file.
     Its purpose is to enable people to detect truncated versions of
     the file from the lack of a footer line.


File: elisp,  Node: GNU Emacs Internals,  Next: Standard Errors,  Prev: Tips,  Up: Top

GNU Emacs Internals
*******************

   This chapter describes how the runnable Emacs executable is dumped
with the preloaded Lisp libraries in it, how storage is allocated, and
some internal aspects of GNU Emacs that may be of interest to C
programmers.

* Menu:

* Building Emacs::      How to the dumped Emacs is made.
* Pure Storage::        A kludge to make preloaded Lisp functions sharable.
* Garbage Collection::  Reclaiming space for Lisp objects no longer used.
* Memory Usage::        Info about total size of Lisp objects made so far.
* Writing Emacs Primitives::   Writing C code for Emacs.
* Object Internals::    Data formats of buffers, windows, processes.


File: elisp,  Node: Building Emacs,  Next: Pure Storage,  Up: GNU Emacs Internals

Building Emacs
==============

   This section explains the steps involved in building the Emacs
executable.  You don't have to know this material to build and install
Emacs, since the makefiles do all these things automatically.  This
information is pertinent to Emacs maintenance.

   Compilation of the C source files in the `src' directory produces an
executable file called `temacs', also called a "bare impure Emacs".  It
contains the Emacs Lisp interpreter and I/O routines, but not the
editing commands.

   The command `temacs -l loadup' uses `temacs' to create the real
runnable Emacs executable.  These arguments direct `temacs' to evaluate
the Lisp files specified in the file `loadup.el'.  These files set up
the normal Emacs editing environment, resulting in an Emacs that is
still impure but no longer bare.

   It takes a substantial time to load the standard Lisp files.
Luckily, you don't have to do this each time you run Emacs; `temacs' can
dump out an executable program called `emacs' that has these files
preloaded.  `emacs' starts more quickly because it does not need to
load the files.  This is the Emacs executable that is normally
installed.

   To create `emacs', use the command `temacs -batch -l loadup dump'.
The purpose of `-batch' here is to prevent `temacs' from trying to
initialize any of its data on the terminal; this ensures that the
tables of terminal information are empty in the dumped Emacs.  The
argument `dump' tells `loadup.el' to dump a new executable named
`emacs'.

   Some operating systems don't support dumping.  On those systems, you
must start Emacs with the `temacs -l loadup' command each time you use
it.  This takes a substantial time, but since you need to start Emacs
once a day at most--or once a week if you never log out--the extra time
is not too severe a problem.

   You can specify additional files to preload by writing a library
named `site-load.el' that loads them.  You may need to increase the
value of `PURESIZE', in `src/puresize.h', to make room for the
additional data.  (Try adding increments of 20000 until it is big
enough.)  However, the advantage of preloading additional files
decreases as machines get faster.  On modern machines, it is usually not
advisable.

   After `loadup.el' reads `site-load.el', it finds the documentation
strings for primitive and preloaded functions (and variables) in the
file `etc/DOC' where they are stored, by calling `Snarf-documentation'
(*note Accessing Documentation::.).

   You can specify other Lisp expressions to execute just before dumping
by putting them in a library named `site-init.el'.  This file is
executed after the documentation strings are found.

   If you want to preload function or variable definitions, there are
three ways you can do this and make their documentation strings
accessible when you subsequently run Emacs:

   * Arrange to scan these files when producing the `etc/DOC' file, and
     load them with `site-load.el'.

   * Load the files with `site-init.el', then copy the files into the
     installation directory for Lisp files when you install Emacs.

   * Specify a non-`nil' value for `byte-compile-dynamic-docstrings' as
     a local variable in each these files, and load them with either
     `site-load.el' or `site-init.el'.  (This method has the drawback
     that the documentation strings take up space in Emacs all the
     time.)

   It is not advisable to put anything in `site-load.el' or
`site-init.el' that would alter any of the features that users expect
in an ordinary unmodified Emacs.  If you feel you must override normal
features for your site, do it with `default.el', so that users can
override your changes if they wish.  *Note Start-up Summary::.

 - Function: dump-emacs TO-FILE FROM-FILE
     This function dumps the current state of Emacs into an executable
     file TO-FILE.  It takes symbols from FROM-FILE (this is normally
     the executable file `temacs').

     If you want to use this function in an Emacs that was already
     dumped, you must run Emacs with `-batch'.


File: elisp,  Node: Pure Storage,  Next: Garbage Collection,  Prev: Building Emacs,  Up: GNU Emacs Internals

Pure Storage
============

   Emacs Lisp uses two kinds of storage for user-created Lisp objects:
"normal storage" and "pure storage".  Normal storage is where all the
new data created during an Emacs session is kept; see the following
section for information on normal storage.  Pure storage is used for
certain data in the preloaded standard Lisp files--data that should
never change during actual use of Emacs.

   Pure storage is allocated only while `temacs' is loading the
standard preloaded Lisp libraries.  In the file `emacs', it is marked
as read-only (on operating systems that permit this), so that the
memory space can be shared by all the Emacs jobs running on the machine
at once.  Pure storage is not expandable; a fixed amount is allocated
when Emacs is compiled, and if that is not sufficient for the preloaded
libraries, `temacs' crashes.  If that happens, you must increase the
compilation parameter `PURESIZE' in the file `src/puresize.h'.  This
normally won't happen unless you try to preload additional libraries or
add features to the standard ones.

 - Function: purecopy OBJECT
     This function makes a copy of OBJECT in pure storage and returns
     it.  It copies strings by simply making a new string with the same
     characters in pure storage.  It recursively copies the contents of
     vectors and cons cells.  It does not make copies of other objects
     such as symbols, but just returns them unchanged.  It signals an
     error if asked to copy markers.

     This function is a no-op except while Emacs is being built and
     dumped; it is usually called only in the file
     `emacs/lisp/loaddefs.el', but a few packages call it just in case
     you decide to preload them.

 - Variable: pure-bytes-used
     The value of this variable is the number of bytes of pure storage
     allocated so far.  Typically, in a dumped Emacs, this number is
     very close to the total amount of pure storage available--if it
     were not, we would preallocate less.

 - Variable: purify-flag
     This variable determines whether `defun' should make a copy of the
     function definition in pure storage.  If it is non-`nil', then the
     function definition is copied into pure storage.

     This flag is `t' while loading all of the basic functions for
     building Emacs initially (allowing those functions to be sharable
     and non-collectible).  Dumping Emacs as an executable always writes
     `nil' in this variable, regardless of the value it actually has
     before and after dumping.

     You should not change this flag in a running Emacs.


File: elisp,  Node: Garbage Collection,  Next: Memory Usage,  Prev: Pure Storage,  Up: GNU Emacs Internals

Garbage Collection
==================

   When a program creates a list or the user defines a new function
(such as by loading a library), that data is placed in normal storage.
If normal storage runs low, then Emacs asks the operating system to
allocate more memory in blocks of 1k bytes.  Each block is used for one
type of Lisp object, so symbols, cons cells, markers, etc., are
segregated in distinct blocks in memory.  (Vectors, long strings,
buffers and certain other editing types, which are fairly large, are
allocated in individual blocks, one per object, while small strings are
packed into blocks of 8k bytes.)

   It is quite common to use some storage for a while, then release it
by (for example) killing a buffer or deleting the last pointer to an
object.  Emacs provides a "garbage collector" to reclaim this abandoned
storage.  (This name is traditional, but "garbage recycler" might be a
more intuitive metaphor for this facility.)

   The garbage collector operates by finding and marking all Lisp
objects that are still accessible to Lisp programs.  To begin with, it
assumes all the symbols, their values and associated function
definitions, and any data presently on the stack, are accessible.  Any
objects that can be reached indirectly through other accessible objects
are also accessible.

   When marking is finished, all objects still unmarked are garbage.  No
matter what the Lisp program or the user does, it is impossible to refer
to them, since there is no longer a way to reach them.  Their space
might as well be reused, since no one will miss them.  The second
("sweep") phase of the garbage collector arranges to reuse them.

   The sweep phase puts unused cons cells onto a "free list" for future
allocation; likewise for symbols and markers.  It compacts the
accessible strings so they occupy fewer 8k blocks; then it frees the
other 8k blocks.  Vectors, buffers, windows, and other large objects are
individually allocated and freed using `malloc' and `free'.

     Common Lisp note: Unlike other Lisps, GNU Emacs Lisp does not call
     the garbage collector when the free list is empty.  Instead, it
     simply requests the operating system to allocate more storage, and
     processing continues until `gc-cons-threshold' bytes have been
     used.

     This means that you can make sure that the garbage collector will
     not run during a certain portion of a Lisp program by calling the
     garbage collector explicitly just before it (provided that portion
     of the program does not use so much space as to force a second
     garbage collection).

 - Command: garbage-collect
     This command runs a garbage collection, and returns information on
     the amount of space in use.  (Garbage collection can also occur
     spontaneously if you use more than `gc-cons-threshold' bytes of
     Lisp data since the previous garbage collection.)

     `garbage-collect' returns a list containing the following
     information:

          ((USED-CONSES . FREE-CONSES)
           (USED-SYMS . FREE-SYMS)
           (USED-MISCS . FREE-MISCS)
           USED-STRING-CHARS
           USED-VECTOR-SLOTS
           (USED-FLOATS . FREE-FLOATS)
           (USED-INTERVALS . FREE-INTERVALS))

     Here is an example:

          (garbage-collect)
               => ((106886 . 13184) (9769 . 0)
                          (7731 . 4651) 347543 121628
                          (31 . 94) (1273 . 168))

     Here is a table explaining each element:

    USED-CONSES
          The number of cons cells in use.

    FREE-CONSES
          The number of cons cells for which space has been obtained
          from the operating system, but that are not currently being
          used.

    USED-SYMS
          The number of symbols in use.

    FREE-SYMS
          The number of symbols for which space has been obtained from
          the operating system, but that are not currently being used.

    USED-MISCS
          The number of miscellaneous objects in use.  These include
          markers and overlays, plus certain objects not visible to
          users.

    FREE-MISCS
          The number of miscellaneous objects for which space has been
          obtained from the operating system, but that are not
          currently being used.

    USED-STRING-CHARS
          The total size of all strings, in characters.

    USED-VECTOR-SLOTS
          The total number of elements of existing vectors.

    USED-FLOATS
          The number of floats in use.

    FREE-FLOATS
          The number of floats for which space has been obtained from
          the operating system, but that are not currently being used.

    USED-INTERVALS
          The number of intervals in use.  Intervals are an internal
          data structure used for representing text properties.

    FREE-INTERVALS
          The number of intervals for which space has been obtained
          from the operating system, but that are not currently being
          used.

 - User Option: garbage-collection-messages
     If this variable is non-`nil', Emacs displays a message at the
     beginning and end of garbage collection.  The default value is
     `nil', meaning there are no such messages.

 - User Option: gc-cons-threshold
     The value of this variable is the number of bytes of storage that
     must be allocated for Lisp objects after one garbage collection in
     order to trigger another garbage collection.  A cons cell counts
     as eight bytes, a string as one byte per character plus a few
     bytes of overhead, and so on; space allocated to the contents of
     buffers does not count.  Note that the subsequent garbage
     collection does not happen immediately when the threshold is
     exhausted, but only the next time the Lisp evaluator is called.

     The initial threshold value is 400,000.  If you specify a larger
     value, garbage collection will happen less often.  This reduces the
     amount of time spent garbage collecting, but increases total
     memory use.  You may want to do this when running a program that
     creates lots of Lisp data.

     You can make collections more frequent by specifying a smaller
     value, down to 10,000.  A value less than 10,000 will remain in
     effect only until the subsequent garbage collection, at which time
     `garbage-collect' will set the threshold back to 10,000.

   The value return by `garbage-collect' describes the amount of memory
used by Lisp data, broken down by data type.  By contrast, the function
`memory-limit' provides information on the total amount of memory Emacs
is currently using.

 - Function: memory-limit
     This function returns the address of the last byte Emacs has
     allocated, divided by 1024.  We divide the value by 1024 to make
     sure it fits in a Lisp integer.

     You can use this to get a general idea of how your actions affect
     the memory usage.


File: elisp,  Node: Memory Usage,  Next: Writing Emacs Primitives,  Prev: Garbage Collection,  Up: GNU Emacs Internals

Memory Usage
============

   These functions and variables give information about the total amount
of memory allocation that Emacs has done, broken down by data type.
Note the difference between these and the values returned by
`(garbage-collect)'; those count objects that currently exist, but
these count the number or size of all allocations, including those for
objects that have since been freed.

 - Variable: cons-cells-consed
     The total number of cons cells that have been allocated so far in
     this Emacs session.

 - Variable: floats-consed
     The total number of floats that have been allocated so far in this
     Emacs session.

 - Variable: vector-cells-consed
     The total number of vector cells that have been allocated so far
     in this Emacs session.

 - Variable: symbols-consed
     The total number of symbols that have been allocated so far in
     this Emacs session.

 - Variable: string-chars-consed
     The total number of string characters that have been allocated so
     far in this Emacs session.

 - Variable: misc-objects-consed
     The total number of miscellaneous objects that have been allocated
     so far in this Emacs session.  These include markers and overlays,
     plus certain objects not visible to users.

 - Variable: intervals-consed
     The total number of intervals that have been allocated so far in
     this Emacs session.

