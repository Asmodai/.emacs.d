This is Info file elisp, produced by Makeinfo version 1.68 from the
input file elisp.texi.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY

   This version is the edition 2.5 of the GNU Emacs Lisp Reference
Manual.  It corresponds to Emacs Version 20.3

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307  USA

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: elisp,  Node: Search-based Fontification,  Next: Other Font Lock Variables,  Prev: Font Lock Basics,  Up: Font Lock Mode

Search-based Fontification
--------------------------

   The most important variable for customizing Font Lock mode is
`font-lock-keywords'.  It specifies the search criteria for
search-based fontification.

 - Variable: font-lock-keywords
     This variable's value is a list of the keywords to highlight.  Be
     careful when composing regular expressions for this list; a poorly
     written pattern can dramatically slow things down!

   Each element of `font-lock-keywords' specifies how to find certain
cases of text, and how to highlight those cases.  Font Lock mode
processes the elements of `font-lock-keywords' one by one, and for each
element, it finds and handles all matches.  Ordinarily, once part of
the text has been fontified already, this cannot be overridden by a
subsequent match in the same text; but you can specify different
behavior using the OVERRIDE element of a HIGHLIGHTER.

   Each element of `font-lock-keywords' should have one of these forms:

`REGEXP'
     Highlight all matches for REGEXP using `font-lock-keyword-face'.
     For example,

          ;; Highlight discrete occurrences of `foo'
          ;; using `font-lock-keyword-face'.
          "\\<foo\\>"

     The function `regexp-opt' (*note Syntax of Regexps::.) is useful
     for calculating optimal regular expressions to match a number of
     different keywords.

`FUNCTION'
     Find text by calling FUNCTION, and highlight the matches it finds
     using `font-lock-keyword-face'.

     When FUNCTION is called, it receives one argument, the limit of
     the search.  It should return non-`nil' if it succeeds, and set the
     match data to describe the match that was found.

`(MATCHER . MATCH)'
     In this kind of element, MATCHER stands for either a regular
     expression or a function, as described above.  The CDR, MATCH,
     specifies which subexpression of MATCHER should be highlighted
     (instead of the entire text that MATCHER matched).

          ;; Highlight the `bar' in each occurrences of `fubar',
          ;; using `font-lock-keyword-face'.
          ("fu\\(bar\\)" . 1)

     If you use `regexp-opt' to produce the regular expression MATCHER,
     then you can use `regexp-opt-depth' (*note Syntax of Regexps::.)
     to calculate the value for MATCH.

`(MATCHER . FACENAME)'
     In this kind of element, FACENAME is an expression whose value
     specifies the face name to use for highlighting.

          ;; Highlight occurrences of `fubar',
          ;; using the face which is the value of `fubar-face'.
          ("fubar" . fubar-face)

`(MATCHER . HIGHLIGHTER)'
     In this kind of element, HIGHLIGHTER is a list which specifies how
     to highlight matches found by MATCHER.  It has the form

          (SUBEXP FACENAME OVERRIDE LAXMATCH)

     The CAR, SUBEXP, is an integer specifying which subexpression of
     the match to fontify (0 means the entire matching text).  The
     second subelement, FACENAME, specifies the face, as described
     above.

     The last two values in HIGHLIGHTER, OVERRIDE and LAXMATCH, are
     flags.  If OVERRIDE is `t', this element can override existing
     fontification made by previous elements of `font-lock-keywords'.
     If it is `keep', then each character is fontified if it has not
     been fontified already by some other element.  If it is `prepend',
     the face FACENAME is added to the beginning of the `face'
     property.  If it is `append', the face FACENAME is added to the
     end of the `face' property.

     If LAXMATCH is non-`nil', it means there should be no error if
     there is no subexpression numbered SUBEXP in MATCHER.

     Here are some examples of elements of this kind, and what they do:

          ;; Highlight occurrences of either `foo' or `bar',
          ;; using `foo-bar-face', even if they have already been highlighted.
          ;; `foo-bar-face' should be a variable whose value is a face.
          ("foo\\|bar" 0 foo-bar-face t)
          
          ;; Highlight the first subexpression within each occurrences
          ;; that the function `fubar-match' finds,
          ;; using the face which is the value of `fubar-face'.
          (fubar-match 1 fubar-face)

`(MATCHER HIGHLIGHTERS...)'
     This sort of element specifies several HIGHLIGHTER lists for a
     single MATCHER.  In order for this to be useful, each HIGHLIGHTER
     should have a different value of SUBEXP; that is, each one should
     apply to a different subexpression of MATCHER.

`(eval . FORM)'
     Here FORM is an expression to be evaluated the first time this
     value of `font-lock-keywords' is used in a buffer.  Its value
     should have one of the forms described in this table.

   *Warning:* Do not design an element of `font-lock-keywords' to match
text which spans lines; this does not work reliably.  While
`font-lock-fontify-buffer' handles multi-line patterns correctly,
updating when you edit the buffer does not, since it considers text one
line at a time.


File: elisp,  Node: Other Font Lock Variables,  Next: Levels of Font Lock,  Prev: Search-based Fontification,  Up: Font Lock Mode

Other Font Lock Variables
-------------------------

   This section describes additional variables that a major mode can
set by means of `font-lock-defaults'.

 - Variable: font-lock-keywords-only
     Non-`nil' means Font Lock should not fontify comments or strings
     syntactically; it should only fontify based on
     `font-lock-keywords'.

 - Variable: font-lock-keywords-case-fold-search
     Non-`nil' means that regular expression matching for the sake of
     `font-lock-keywords' should be case-insensitive.

 - Variable: font-lock-syntax-table
     This variable specifies the syntax table to use for fontification
     of comments and strings.

 - Variable: font-lock-beginning-of-syntax-function
     If this variable is non-`nil', it should be a function to move
     point back to a position that is syntactically at "top level" and
     outside of strings or comments.  Font Lock uses this when necessary
     to get the right results for syntactic fontification.

     This function is called with no arguments.  It should leave point
     at the beginning of any enclosing syntactic block.  Typical values
     are `beginning-of-line' (i.e., the start of the line is known to be
     outside a syntactic block), or `beginning-of-defun' for programming
     modes or `backward-paragraph' for textual modes (i.e., the
     mode-dependent function is known to move outside a syntactic
     block).

     If the value is `nil', the beginning of the buffer is used as a
     position outside of a syntactic block.  This cannot be wrong, but
     it can be slow.

 - Variable: font-lock-mark-block-function
     If this variable is non-`nil', it should be a function that is
     called with no arguments, to choose an enclosing range of text for
     refontification for the command `M-g M-g'
     (`font-lock-fontify-block').

     The function should report its choice by placing the region around
     it.  A good choice is a range of text large enough to give proper
     results, but not too large so that refontification becomes slow.
     Typical values are `mark-defun' for programming modes or
     `mark-paragraph' for textual modes.


File: elisp,  Node: Levels of Font Lock,  Next: Faces for Font Lock,  Prev: Other Font Lock Variables,  Up: Font Lock Mode

Levels of Font Lock
-------------------

   Many major modes offer three different levels of fontification.  You
can define multiple levels by using a list of symbols for KEYWORDS in
`font-lock-defaults'.  Each symbol specifies one level of
fontification; it is up to the user to choose one of these levels.  The
chosen level's symbol value is used to initialize `font-lock-keywords'.

   Here are the conventions for how to define the levels of
fontification:

   * Level 1: highlight function declarations, file directives (such as
     include or import directives), strings and comments.  The idea is
     speed, so only the most important and top-level components are
     fontified.

   * Level 2: in addition to level 1, highlight all language keywords,
     including type names that act like keywords, as well as named
     constant values.  The idea is that all keywords (either syntactic
     or semantic) should be fontified appropriately.

   * Level 3: in addition to level 2, highlight the symbols being
     defined in function and variable declarations, and all builtin
     function names, wherever they appear.


File: elisp,  Node: Faces for Font Lock,  Next: Syntactic Font Lock,  Prev: Levels of Font Lock,  Up: Font Lock Mode

Faces for Font Lock
-------------------

   You can make Font Lock mode use any face, but several faces are
defined specifically for Font Lock mode.  Each of these symbols is both
a face name, and a variable whose default value is the symbol itself.
Thus, the default value of `font-lock-comment-face' is
`font-lock-comment-face'.  This means you can write
`font-lock-comment-face' in a context such as `font-lock-keywords'
where a face-name-valued expression is used.

`font-lock-comment-face'
     Used (typically) for comments.

`font-lock-string-face'
     Used (typically) for string constants.

`font-lock-keyword-face'
     Used (typically) for keywords--names that have special syntactic
     significance, like `for' and `if' in C.

`font-lock-builtin-face'
     Used (typically) for built-in function names.

`font-lock-function-name-face'
     Used (typically) for the name of a function being defined or
     declared, in a function definition or declaration.

`font-lock-variable-name-face'
     Used (typically) for the name of a variable being defined or
     declared, in a variable definition or declaration.

`font-lock-type-face'
     Used (typically) for names of user-defined data types, where they
     are defined and where they are used.

`font-lock-constant-face'
     Used (typically) for constant names.

`font-lock-warning-face'
     Used (typically) for constructs that are peculiar, or that greatly
     change the meaning of other text.  For example, this is used for
     `;;;###autoload' cookies in Emacs Lisp, and for `#error'
     directives in C.


File: elisp,  Node: Syntactic Font Lock,  Prev: Faces for Font Lock,  Up: Font Lock Mode

Syntactic Font Lock
-------------------

   Font Lock mode can be used to update `syntax-table' properties
automatically.  This is useful in languages for which a single syntax
table by itself is not sufficient.

 - Variable: font-lock-syntactic-keywords
     This variable enables and controls syntactic Font Lock.  Its value
     should be a list of elements of this form:

          (MATCHER SUBEXP SYNTAX OVERRIDE LAXMATCH)

     The parts of this element have the same meanings as in the
     corresponding sort of element of `font-lock-keywords',

          (MATCHER SUBEXP FACENAME OVERRIDE LAXMATCH)

     However, instead of specifying the value FACENAME to use for the
     `face' property, it specifies the value SYNTAX to use for the
     `syntax-table' property.  Here, SYNTAX can be a variable whose
     value is a syntax table, a syntax entry of the form `(SYNTAX-CODE
     . MATCHING-CHAR)', or an expression whose value is one of those
     two types.


File: elisp,  Node: Hooks,  Prev: Font Lock Mode,  Up: Modes

Hooks
=====

   A "hook" is a variable where you can store a function or functions
to be called on a particular occasion by an existing program.  Emacs
provides hooks for the sake of customization.  Most often, hooks are set
up in the `.emacs' file, but Lisp programs can set them also.  *Note
Standard Hooks::, for a list of standard hook variables.

   Most of the hooks in Emacs are "normal hooks".  These variables
contain lists of functions to be called with no arguments.  When the
hook name ends in `-hook', that tells you it is normal.  We try to make
all hooks normal, as much as possible, so that you can use them in a
uniform way.

   Every major mode function is supposed to run a normal hook called the
"mode hook" as the last step of initialization.  This makes it easy for
a user to customize the behavior of the mode, by overriding the
buffer-local variable assignments already made by the mode.  But hooks
are used in other contexts too.  For example, the hook `suspend-hook'
runs just before Emacs suspends itself (*note Suspending Emacs::.).

   The recommended way to add a hook function to a normal hook is by
calling `add-hook' (see below).  The hook functions may be any of the
valid kinds of functions that `funcall' accepts (*note What Is a
Function::.).  Most normal hook variables are initially void;
`add-hook' knows how to deal with this.

   If the hook variable's name does not end with `-hook', that
indicates it is probably an "abnormal hook"; you should look at its
documentation to see how to use the hook properly.

   If the variable's name ends in `-functions' or `-hooks', then the
value is a list of functions, but it is abnormal in that either these
functions are called with arguments or their values are used in some
way.  You can use `add-hook' to add a function to the list, but you
must take care in writing the function.  (A few of these variables are
actually normal hooks which were named before we established the
convention of using `-hook' for them.)

   If the variable's name ends in `-function', then its value is just a
single function, not a list of functions.

   Here's an example that uses a mode hook to turn on Auto Fill mode
when in Lisp Interaction mode:

     (add-hook 'lisp-interaction-mode-hook 'turn-on-auto-fill)

   At the appropriate time, Emacs uses the `run-hooks' function to run
particular hooks.  This function calls the hook functions that have
been added with `add-hook'.

 - Function: run-hooks &rest HOOKVAR
     This function takes one or more hook variable names as arguments,
     and runs each hook in turn.  Each HOOKVAR argument should be a
     symbol that is a hook variable.  These arguments are processed in
     the order specified.

     If a hook variable has a non-`nil' value, that value may be a
     function or a list of functions.  If the value is a function
     (either a lambda expression or a symbol with a function
     definition), it is called.  If it is a list, the elements are
     called, in order.  The hook functions are called with no
     arguments.  Nowadays, storing a single function in the hook
     variable is semi-obsolete; you should always use a list of
     functions.

     For example, here's how `emacs-lisp-mode' runs its mode hook:

          (run-hooks 'emacs-lisp-mode-hook)

 - Function: run-hook-with-args HOOK &rest ARGS
     This function is the way to run an abnormal hook which passes
     arguments to the hook functions.  It calls each of the hook
     functions, passing each of them the arguments ARGS.

 - Function: run-hook-with-args-until-failure HOOK &rest ARGS
     This function is the way to run an abnormal hook which passes
     arguments to the hook functions, and stops as soon as any hook
     function fails.  It calls each of the hook functions, passing each
     of them the arguments ARGS, until some hook function returns
     `nil'.  Then it stops, and returns `nil' if some hook function
     did, and otherwise returns a non-`nil' value.

 - Function: run-hook-with-args-until-success HOOK &rest ARGS
     This function is the way to run an abnormal hook which passes
     arguments to the hook functions, and stops as soon as any hook
     function succeeds.  It calls each of the hook functions, passing
     each of them the arguments ARGS, until some hook function returns
     non-`nil'.  Then it stops, and returns whatever was returned by
     the last hook function that was called.

 - Function: add-hook HOOK FUNCTION &optional APPEND LOCAL
     This function is the handy way to add function FUNCTION to hook
     variable HOOK.  The argument FUNCTION may be any valid Lisp
     function with the proper number of arguments.  For example,

          (add-hook 'text-mode-hook 'my-text-hook-function)

     adds `my-text-hook-function' to the hook called `text-mode-hook'.

     You can use `add-hook' for abnormal hooks as well as for normal
     hooks.

     It is best to design your hook functions so that the order in
     which they are executed does not matter.  Any dependence on the
     order is "asking for trouble."  However, the order is predictable:
     normally, FUNCTION goes at the front of the hook list, so it will
     be executed first (barring another `add-hook' call).  If the
     optional argument APPEND is non-`nil', the new hook function goes
     at the end of the hook list and will be executed last.

     If LOCAL is non-`nil', that says to make the new hook function
     buffer-local in the current buffer.  Before you can do this, you
     must make the hook itself buffer-local by calling `make-local-hook'
     (*not* `make-local-variable').  If the hook itself is not
     buffer-local, then the value of LOCAL makes no difference--the
     hook function is always global.

 - Function: remove-hook HOOK FUNCTION &optional LOCAL
     This function removes FUNCTION from the hook variable HOOK.

     If LOCAL is non-`nil', that says to remove FUNCTION from the
     buffer-local hook list instead of from the global hook list.  If
     the hook variable itself is not buffer-local, then the value of
     LOCAL makes no difference.

 - Function: make-local-hook HOOK
     This function makes the hook variable `hook' buffer-local in the
     current buffer.  When a hook variable is buffer-local, it can have
     buffer-local and global hook functions, and `run-hooks' runs all of
     them.

     This function works by making `t' an element of the buffer-local
     value.  That serves as a flag to use the hook functions in the
     default value of the hook variable as well as those in the
     buffer-local value.  Since `run-hooks' understands this flag,
     `make-local-hook' works with all normal hooks.  It works for only
     some non-normal hooks--those whose callers have been updated to
     understand this meaning of `t'.

     Do not use `make-local-variable' directly for hook variables; it is
     not sufficient.


File: elisp,  Node: Documentation,  Next: Files,  Prev: Modes,  Up: Top

Documentation
*************

   GNU Emacs Lisp has convenient on-line help facilities, most of which
derive their information from the documentation strings associated with
functions and variables.  This chapter describes how to write good
documentation strings for your Lisp programs, as well as how to write
programs to access documentation.

   Note that the documentation strings for Emacs are not the same thing
as the Emacs manual.  Manuals have their own source files, written in
the Texinfo language; documentation strings are specified in the
definitions of the functions and variables they apply to.  A collection
of documentation strings is not sufficient as a manual because a good
manual is not organized in that fashion; it is organized in terms of
topics of discussion.

* Menu:

* Documentation Basics::      Good style for doc strings.
                                Where to put them.  How Emacs stores them.
* Accessing Documentation::   How Lisp programs can access doc strings.
* Keys in Documentation::     Substituting current key bindings.
* Describing Characters::     Making printable descriptions of
                                non-printing characters and key sequences.
* Help Functions::            Subroutines used by Emacs help facilities.


File: elisp,  Node: Documentation Basics,  Next: Accessing Documentation,  Up: Documentation

Documentation Basics
====================

   A documentation string is written using the Lisp syntax for strings,
with double-quote characters surrounding the text of the string.  This
is because it really is a Lisp string object.  The string serves as
documentation when it is written in the proper place in the definition
of a function or variable.  In a function definition, the documentation
string follows the argument list.  In a variable definition, the
documentation string follows the initial value of the variable.

   When you write a documentation string, make the first line a complete
sentence (or two complete sentences) since some commands, such as
`apropos', show only the first line of a multi-line documentation
string.  Also, you should not indent the second line of a documentation
string, if it has one, because that looks odd when you use `C-h f'
(`describe-function') or `C-h v' (`describe-variable') to view the
documentation string.  *Note Documentation Tips::.

   Documentation strings can contain several special substrings, which
stand for key bindings to be looked up in the current keymaps when the
documentation is displayed.  This allows documentation strings to refer
to the keys for related commands and be accurate even when a user
rearranges the key bindings.  (*Note Accessing Documentation::.)

   In Emacs Lisp, a documentation string is accessible through the
function or variable that it describes:

   * The documentation for a function is stored in the function
     definition itself (*note Lambda Expressions::.).  The function
     `documentation' knows how to extract it.

   * The documentation for a variable is stored in the variable's
     property list under the property name `variable-documentation'.
     The function `documentation-property' knows how to retrieve it.

   To save space, the documentation for preloaded functions and
variables (including primitive functions and autoloaded functions) is
stored in the file `emacs/etc/DOC-VERSION'--not inside Emacs.  The
documentation strings for functions and variables loaded during the
Emacs session from byte-compiled files are stored in those files (*note
Docs and Compilation::.).

   The data structure inside Emacs has an integer offset into the file,
or a list containing a file name and an integer, in place of the
documentation string.  The functions `documentation' and
`documentation-property' use that information to fetch the
documentation string from the appropriate file; this is transparent to
the user.

   For information on the uses of documentation strings, see *Note
Help: (emacs)Help.

   The `emacs/lib-src' directory contains two utilities that you can
use to print nice-looking hardcopy for the file
`emacs/etc/DOC-VERSION'.  These are `sorted-doc' and `digest-doc'.


File: elisp,  Node: Accessing Documentation,  Next: Keys in Documentation,  Prev: Documentation Basics,  Up: Documentation

Access to Documentation Strings
===============================

 - Function: documentation-property SYMBOL PROPERTY &optional VERBATIM
     This function returns the documentation string that is recorded in
     SYMBOL's property list under property PROPERTY.  It retrieves the
     text from a file if necessary, and runs `substitute-command-keys'
     to substitute actual key bindings.  (This substitution is not done
     if VERBATIM is non-`nil'.)

          (documentation-property 'command-line-processed
             'variable-documentation)
               => "Non-nil once command line has been processed"

          (symbol-plist 'command-line-processed)
               => (variable-documentation 188902)

 - Function: documentation FUNCTION &optional VERBATIM
     This function returns the documentation string of FUNCTION.  It
     reads the text from a file if necessary.  Then (unless VERBATIM is
     non-`nil') it calls `substitute-command-keys', to return a value
     containing the actual (current) key bindings.

     The function `documentation' signals a `void-function' error if
     FUNCTION has no function definition.  However, it is OK if the
     function definition has no documentation string.  In that case,
     `documentation' returns `nil'.

   Here is an example of using the two functions, `documentation' and
`documentation-property', to display the documentation strings for
several symbols in a `*Help*' buffer.

     (defun describe-symbols (pattern)
       "Describe the Emacs Lisp symbols matching PATTERN.
     All symbols that have PATTERN in their name are described
     in the `*Help*' buffer."
       (interactive "sDescribe symbols matching: ")
       (let ((describe-func
              (function
               (lambda (s)

     ;; Print description of symbol.
                 (if (fboundp s)             ; It is a function.
                     (princ
                      (format "%s\t%s\n%s\n\n" s
                        (if (commandp s)
                            (let ((keys (where-is-internal s)))
                              (if keys
                                  (concat
                                   "Keys: "
                                   (mapconcat 'key-description
                                              keys " "))
                                "Keys: none"))
                          "Function")

     (or (documentation s)
                            "not documented"))))
     
                 (if (boundp s)              ; It is a variable.

     (princ
                      (format "%s\t%s\n%s\n\n" s
                        (if (user-variable-p s)
                            "Option " "Variable")

     (or (documentation-property
                              s 'variable-documentation)
                            "not documented")))))))
             sym-list)

     ;; Build a list of symbols that match pattern.
         (mapatoms (function
                    (lambda (sym)
                      (if (string-match pattern (symbol-name sym))
                          (setq sym-list (cons sym sym-list))))))

     ;; Display the data.
         (with-output-to-temp-buffer "*Help*"
           (mapcar describe-func (sort sym-list 'string<))
           (print-help-return-message))))

   The `describe-symbols' function works like `apropos', but provides
more information.

     (describe-symbols "goal")
     
     ---------- Buffer: *Help* ----------
     goal-column     Option
     *Semipermanent goal column for vertical motion, as set by ...

     set-goal-column Keys: C-x C-n
     Set the current horizontal position as a goal for C-n and C-p.

     Those commands will move to this position in the line moved to
     rather than trying to keep the same horizontal position.
     With a non-nil argument, clears out the goal column
     so that C-n and C-p resume vertical motion.
     The goal column is stored in the variable `goal-column'.

     temporary-goal-column   Variable
     Current goal column for vertical motion.
     It is the column where point was
     at the start of current run of vertical motion commands.
     When the `track-eol' feature is doing its job, the value is 9999.
     ---------- Buffer: *Help* ----------

 - Function: Snarf-documentation FILENAME
     This function is used only during Emacs initialization, just before
     the runnable Emacs is dumped.  It finds the file offsets of the
     documentation strings stored in the file FILENAME, and records
     them in the in-core function definitions and variable property
     lists in place of the actual strings.  *Note Building Emacs::.

     Emacs reads the file FILENAME from the `emacs/etc' directory.
     When the dumped Emacs is later executed, the same file will be
     looked for in the directory `doc-directory'.  Usually FILENAME is
     `"DOC-VERSION"'.

 - Variable: doc-directory
     This variable holds the name of the directory which should contain
     the file `"DOC-VERSION"' that contains documentation strings for
     built-in and preloaded functions and variables.

     In most cases, this is the same as `data-directory'.  They may be
     different when you run Emacs from the directory where you built it,
     without actually installing it.  See `data-directory' in *Note
     Help Functions::.

     In older Emacs versions, `exec-directory' was used for this.


File: elisp,  Node: Keys in Documentation,  Next: Describing Characters,  Prev: Accessing Documentation,  Up: Documentation

Substituting Key Bindings in Documentation
==========================================

   When documentation strings refer to key sequences, they should use
the current, actual key bindings.  They can do so using certain special
text sequences described below.  Accessing documentation strings in the
usual way substitutes current key binding information for these special
sequences.  This works by calling `substitute-command-keys'.  You can
also call that function yourself.

   Here is a list of the special sequences and what they mean:

`\[COMMAND]'
     stands for a key sequence that will invoke COMMAND, or `M-x
     COMMAND' if COMMAND has no key bindings.

`\{MAPVAR}'
     stands for a summary of the keymap which is the value of the
     variable MAPVAR.  The summary is made using `describe-bindings'.

`\<MAPVAR>'
     stands for no text itself.  It is used only for a side effect: it
     specifies MAPVAR's value as the keymap for any following
     `\[COMMAND]' sequences in this documentation string.

`\='
     quotes the following character and is discarded; thus, `\=\[' puts
     `\[' into the output, and `\=\=' puts `\=' into the output.

   *Please note:* Each `\' must be doubled when written in a string in
Emacs Lisp.

 - Function: substitute-command-keys STRING
     This function scans STRING for the above special sequences and
     replaces them by what they stand for, returning the result as a
     string.  This permits display of documentation that refers
     accurately to the user's own customized key bindings.

   Here are examples of the special sequences:

     (substitute-command-keys
        "To abort recursive edit, type: \\[abort-recursive-edit]")
     => "To abort recursive edit, type: C-]"

     (substitute-command-keys
        "The keys that are defined for the minibuffer here are:
       \\{minibuffer-local-must-match-map}")
     => "The keys that are defined for the minibuffer here are:
     
     ?               minibuffer-completion-help
     SPC             minibuffer-complete-word
     TAB             minibuffer-complete
     C-j             minibuffer-complete-and-exit
     RET             minibuffer-complete-and-exit
     C-g             abort-recursive-edit
     "
     (substitute-command-keys
        "To abort a recursive edit from the minibuffer, type\
     \\<minibuffer-local-must-match-map>\\[abort-recursive-edit].")
     => "To abort a recursive edit from the minibuffer, type C-g."


File: elisp,  Node: Describing Characters,  Next: Help Functions,  Prev: Keys in Documentation,  Up: Documentation

Describing Characters for Help Messages
=======================================

   These functions convert events, key sequences, or characters to
textual descriptions.  These descriptions are useful for including
arbitrary text characters or key sequences in messages, because they
convert non-printing and whitespace characters to sequences of printing
characters.  The description of a non-whitespace printing character is
the character itself.

 - Function: key-description SEQUENCE
     This function returns a string containing the Emacs standard
     notation for the input events in SEQUENCE.  The argument SEQUENCE
     may be a string, vector or list.  *Note Input Events::, for more
     information about valid events.  See also the examples for
     `single-key-description', below.

 - Function: single-key-description EVENT
     This function returns a string describing EVENT in the standard
     Emacs notation for keyboard input.  A normal printing character
     appears as itself, but a control character turns into a string
     starting with `C-', a meta character turns into a string starting
     with `M-', and space, tab, etc. appear as `SPC', `TAB', etc.  A
     function key symbol appears as itself.  An event that is a list
     appears as the name of the symbol in the CAR of the list.

          (single-key-description ?\C-x)
               => "C-x"

          (key-description "\C-x \M-y \n \t \r \f123")
               => "C-x SPC M-y SPC C-j SPC TAB SPC RET SPC C-l 1 2 3"

          (single-key-description 'C-mouse-1)
               => "C-mouse-1"

 - Function: text-char-description CHARACTER
     This function returns a string describing CHARACTER in the
     standard Emacs notation for characters that appear in text--like
     `single-key-description', except that control characters are
     represented with a leading caret (which is how control characters
     in Emacs buffers are usually displayed).

          (text-char-description ?\C-c)
               => "^C"

          (text-char-description ?\M-m)
               => "M-m"

          (text-char-description ?\C-\M-m)
               => "M-^M"

 - Function: read-kbd-macro STRING
     This function is used mainly for operating on keyboard macros, but
     it can also be used as a rough inverse for `key-description'.  You
     call it with a string containing key descriptions, separated by
     spaces; it returns a string or vector containing the corresponding
     events.  (This may or may not be a single valid key sequence,
     depending on what events you use; *note Keymap Terminology::..)


File: elisp,  Node: Help Functions,  Prev: Describing Characters,  Up: Documentation

Help Functions
==============

   Emacs provides a variety of on-line help functions, all accessible to
the user as subcommands of the prefix `C-h'.  For more information
about them, see *Note Help: (emacs)Help.  Here we describe some
program-level interfaces to the same information.

 - Command: apropos REGEXP &optional DO-ALL
     This function finds all symbols whose names contain a match for the
     regular expression REGEXP, and returns a list of them (*note
     Regular Expressions::.).  It also displays the symbols in a buffer
     named `*Help*', each with a one-line description taken from the
     beginning of its documentation string.

     If DO-ALL is non-`nil', then `apropos' also shows key bindings for
     the functions that are found; it also shows all symbols, even
     those that are neither functions nor variables.

     In the first of the following examples, `apropos' finds all the
     symbols with names containing `exec'.  (We don't show here the
     output that results in the `*Help*' buffer.)

          (apropos "exec")
               => (Buffer-menu-execute command-execute exec-directory
              exec-path execute-extended-command execute-kbd-macro
              executing-kbd-macro executing-macro)

 - Variable: help-map
     The value of this variable is a local keymap for characters
     following the Help key, `C-h'.

 - Prefix Command: help-command
     This symbol is not a function; its function definition cell holds
     the keymap known as `help-map'.  It is defined in `help.el' as
     follows:

          (define-key global-map "\C-h" 'help-command)
          (fset 'help-command help-map)

 - Function: print-help-return-message &optional FUNCTION
     This function builds a string that explains how to restore the
     previous state of the windows after a help command.  After
     building the message, it applies FUNCTION to it if FUNCTION is
     non-`nil'.  Otherwise it calls `message' to display it in the echo
     area.

     This function expects to be called inside a
     `with-output-to-temp-buffer' special form, and expects
     `standard-output' to have the value bound by that special form.
     For an example of its use, see the long example in *Note Accessing
     Documentation::.

 - Variable: help-char
     The value of this variable is the help character--the character
     that Emacs recognizes as meaning Help.  By default, its value is
     8, which stands for `C-h'.  When Emacs reads this character, if
     `help-form' is a non-`nil' Lisp expression, it evaluates that
     expression, and displays the result in a window if it is a string.

     Usually the value of `help-form' is `nil'.  Then the help
     character has no special meaning at the level of command input, and
     it becomes part of a key sequence in the normal way.  The standard
     key binding of `C-h' is a prefix key for several general-purpose
     help features.

     The help character is special after prefix keys, too.  If it has no
     binding as a subcommand of the prefix key, it runs
     `describe-prefix-bindings', which displays a list of all the
     subcommands of the prefix key.

 - Variable: help-event-list
     The value of this variable is a list of event types that serve as
     alternative "help characters."  These events are handled just like
     the event specified by `help-char'.

 - Variable: help-form
     If this variable is non-`nil', its value is a form to evaluate
     whenever the character `help-char' is read.  If evaluating the form
     produces a string, that string is displayed.

     A command that calls `read-event' or `read-char' probably should
     bind `help-form' to a non-`nil' expression while it does input.
     (The time when you should not do this is when `C-h' has some other
     meaning.)  Evaluating this expression should result in a string
     that explains what the input is for and how to enter it properly.

     Entry to the minibuffer binds this variable to the value of
     `minibuffer-help-form' (*note Minibuffer Misc::.).

 - Variable: prefix-help-command
     This variable holds a function to print help for a prefix key.  The
     function is called when the user types a prefix key followed by
     the help character, and the help character has no binding after
     that prefix.  The variable's default value is
     `describe-prefix-bindings'.

 - Function: describe-prefix-bindings
     This function calls `describe-bindings' to display a list of all
     the subcommands of the prefix key of the most recent key sequence.
     The prefix described consists of all but the last event of that
     key sequence.  (The last event is, presumably, the help character.)

   The following two functions are meant for modes that want to provide
help without relinquishing control, such as the "electric" modes.
Their names begin with `Helper' to distinguish them from the ordinary
help functions.

 - Command: Helper-describe-bindings
     This command pops up a window displaying a help buffer containing a
     listing of all of the key bindings from both the local and global
     keymaps.  It works by calling `describe-bindings'.

 - Command: Helper-help
     This command provides help for the current mode.  It prompts the
     user in the minibuffer with the message `Help (Type ? for further
     options)', and then provides assistance in finding out what the key
     bindings are, and what the mode is intended for.  It returns `nil'.

     This can be customized by changing the map `Helper-help-map'.

 - Variable: data-directory
     This variable holds the name of the directory in which Emacs finds
     certain documentation and text files that come with Emacs.  In
     older Emacs versions, `exec-directory' was used for this.

 - Macro: make-help-screen FNAME HELP-LINE HELP-TEXT HELP-MAP
     This macro defines a help command named FNAME that acts like a
     prefix key that shows a list of the subcommands it offers.

     When invoked, FNAME displays HELP-TEXT in a window, then reads and
     executes a key sequence according to HELP-MAP.  The string
     HELP-TEXT should describe the bindings available in HELP-MAP.

     The command FNAME is defined to handle a few events itself, by
     scrolling the display of HELP-TEXT.  When FNAME reads one of those
     special events, it does the scrolling and then reads another
     event.  When it reads an event that is not one of those few, and
     which has a binding in HELP-MAP, it executes that key's binding and
     then returns.

     The argument HELP-LINE should be a single-line summary of the
     alternatives in HELP-MAP.  In the current version of Emacs, this
     argument is used only if you set the option `three-step-help' to
     `t'.

     This macro is used in the command `help-for-help' which is the
     binding of `C-h C-h'.

 - User Option: three-step-help
     If this variable is non-`nil', commands defined with
     `make-help-screen' display their HELP-LINE strings in the echo
     area at first, and display the longer HELP-TEXT strings only if
     the user types the help character again.


File: elisp,  Node: Files,  Next: Backups and Auto-Saving,  Prev: Documentation,  Up: Top

Files
*****

   In Emacs, you can find, create, view, save, and otherwise work with
files and file directories.  This chapter describes most of the
file-related functions of Emacs Lisp, but a few others are described in
*Note Buffers::, and those related to backups and auto-saving are
described in *Note Backups and Auto-Saving::.

   Many of the file functions take one or more arguments that are file
names.  A file name is actually a string.  Most of these functions
expand file name arguments by calling `expand-file-name', so that `~'
is handled correctly, as are relative file names (including `../').
These functions don't recognize environment variable substitutions such
as `$HOME'.  *Note File Name Expansion::.

* Menu:

* Visiting Files::           Reading files into Emacs buffers for editing.
* Saving Buffers::           Writing changed buffers back into files.
* Reading from Files::       Reading files into buffers without visiting.
* Writing to Files::         Writing new files from parts of buffers.
* File Locks::               Locking and unlocking files, to prevent
                               simultaneous editing by two people.
* Information about Files::  Testing existence, accessibility, size of files.
* Changing Files::           Renaming files, changing protection, etc.
* File Names::               Decomposing and expanding file names.
* Contents of Directories::  Getting a list of the files in a directory.
* Create/Delete Dirs::	     Creating and Deleting Directories.
* Magic File Names::	     Defining "magic" special handling
			       for certain file names.
* Format Conversion::        Conversion to and from various file formats.


File: elisp,  Node: Visiting Files,  Next: Saving Buffers,  Up: Files

Visiting Files
==============

   Visiting a file means reading a file into a buffer.  Once this is
done, we say that the buffer is "visiting" that file, and call the file
"the visited file" of the buffer.

   A file and a buffer are two different things.  A file is information
recorded permanently in the computer (unless you delete it).  A buffer,
on the other hand, is information inside of Emacs that will vanish at
the end of the editing session (or when you kill the buffer).  Usually,
a buffer contains information that you have copied from a file; then we
say the buffer is visiting that file.  The copy in the buffer is what
you modify with editing commands.  Such changes to the buffer do not
change the file; therefore, to make the changes permanent, you must
"save" the buffer, which means copying the altered buffer contents back
into the file.

   In spite of the distinction between files and buffers, people often
refer to a file when they mean a buffer and vice-versa.  Indeed, we say,
"I am editing a file," rather than, "I am editing a buffer that I will
soon save as a file of the same name."  Humans do not usually need to
make the distinction explicit.  When dealing with a computer program,
however, it is good to keep the distinction in mind.

* Menu:

* Visiting Functions::         The usual interface functions for visiting.
* Subroutines of Visiting::    Lower-level subroutines that they use.


File: elisp,  Node: Visiting Functions,  Next: Subroutines of Visiting,  Up: Visiting Files

Functions for Visiting Files
----------------------------

   This section describes the functions normally used to visit files.
For historical reasons, these functions have names starting with
`find-' rather than `visit-'.  *Note Buffer File Name::, for functions
and variables that access the visited file name of a buffer or that
find an existing buffer by its visited file name.

   In a Lisp program, if you want to look at the contents of a file but
not alter it, the fastest way is to use `insert-file-contents' in a
temporary buffer.  Visiting the file is not necessary and takes longer.
*Note Reading from Files::.

 - Command: find-file FILENAME
     This command selects a buffer visiting the file FILENAME, using an
     existing buffer if there is one, and otherwise creating a new
     buffer and reading the file into it.  It also returns that buffer.

     The body of the `find-file' function is very simple and looks like
     this:

          (switch-to-buffer (find-file-noselect filename))

     (See `switch-to-buffer' in *Note Displaying Buffers::.)

     When `find-file' is called interactively, it prompts for FILENAME
     in the minibuffer.

 - Function: find-file-noselect FILENAME &optional NOWARN RAWFILE
     This function is the guts of all the file-visiting functions.  It
     finds or creates a buffer visiting the file FILENAME, and returns
     it.  It uses an existing buffer if there is one, and otherwise
     creates a new buffer and reads the file into it.  You may make the
     buffer current or display it in a window if you wish, but this
     function does not do so.

     When `find-file-noselect' uses an existing buffer, it first
     verifies that the file has not changed since it was last visited or
     saved in that buffer.  If the file has changed, then this function
     asks the user whether to reread the changed file.  If the user says
     `yes', any changes previously made in the buffer are lost.

     This function displays warning or advisory messages in various
     peculiar cases, unless the optional argument NOWARN is non-`nil'.
     For example, if it needs to create a buffer, and there is no file
     named FILENAME, it displays the message `New file' in the echo
     area, and leaves the buffer empty.

     The `find-file-noselect' function normally calls `after-find-file'
     after reading the file (*note Subroutines of Visiting::.).  That
     function sets the buffer major mode, parses local variables, warns
     the user if there exists an auto-save file more recent than the
     file just visited, and finishes by running the functions in
     `find-file-hooks'.

     If the optional argument RAWFILE is non-`nil', then
     `after-find-file' is not called, and the
     `find-file-not-found-hooks' are not run in case of failure.  What's
     more, a non-`nil' RAWFILE value suppresses coding system
     conversion (*note Coding Systems::.) and format conversion (*note
     Format Conversion::.).

     The `find-file-noselect' function returns the buffer that is
     visiting the file FILENAME.

          (find-file-noselect "/etc/fstab")
               => #<buffer fstab>

 - Command: find-file-other-window FILENAME
     This command selects a buffer visiting the file FILENAME, but does
     so in a window other than the selected window.  It may use another
     existing window or split a window; see *Note Displaying Buffers::.

     When this command is called interactively, it prompts for FILENAME.

 - Command: find-file-read-only FILENAME
     This command selects a buffer visiting the file FILENAME, like
     `find-file', but it marks the buffer as read-only.  *Note Read
     Only Buffers::, for related functions and variables.

     When this command is called interactively, it prompts for FILENAME.

 - Command: view-file FILENAME
     This command visits FILENAME using View mode, returning to the
     previous buffer when you exit View mode.  View mode is a minor
     mode that provides commands to skim rapidly through the file, but
     does not let you modify the text.  Entering View mode runs the
     normal hook `view-mode-hook'.  *Note Hooks::.

     When `view-file' is called interactively, it prompts for FILENAME.

 - Variable: find-file-hooks
     The value of this variable is a list of functions to be called
     after a file is visited.  The file's local-variables specification
     (if any) will have been processed before the hooks are run.  The
     buffer visiting the file is current when the hook functions are
     run.

     This variable works just like a normal hook, but we think that
     renaming it would not be advisable.  *Note Hooks::.

 - Variable: find-file-not-found-hooks
     The value of this variable is a list of functions to be called when
     `find-file' or `find-file-noselect' is passed a nonexistent file
     name.  `find-file-noselect' calls these functions as soon as it
     detects a nonexistent file.  It calls them in the order of the
     list, until one of them returns non-`nil'.  `buffer-file-name' is
     already set up.

     This is not a normal hook because the values of the functions are
     used, and in many cases only some of the functions are called.

