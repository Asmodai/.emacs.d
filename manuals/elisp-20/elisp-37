This is Info file elisp, produced by Makeinfo version 1.68 from the
input file elisp.texi.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY

   This version is the edition 2.5 of the GNU Emacs Lisp Reference
Manual.  It corresponds to Emacs Version 20.3

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307  USA

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: elisp,  Node: Suspending Emacs,  Prev: Killing Emacs,  Up: Getting Out

Suspending Emacs
----------------

   "Suspending Emacs" means stopping Emacs temporarily and returning
control to its superior process, which is usually the shell.  This
allows you to resume editing later in the same Emacs process, with the
same buffers, the same kill ring, the same undo history, and so on.  To
resume Emacs, use the appropriate command in the parent shell--most
likely `fg'.

   Some operating systems do not support suspension of jobs; on these
systems, "suspension" actually creates a new shell temporarily as a
subprocess of Emacs.  Then you would exit the shell to return to Emacs.

   Suspension is not useful with window systems, because the Emacs job
may not have a parent that can resume it again, and in any case you can
give input to some other job such as a shell merely by moving to a
different window.  Therefore, suspending is not allowed when Emacs is
using a window system.

 - Function: suspend-emacs STRING
     This function stops Emacs and returns control to the superior
     process.  If and when the superior process resumes Emacs,
     `suspend-emacs' returns `nil' to its caller in Lisp.

     If STRING is non-`nil', its characters are sent to be read as
     terminal input by Emacs's superior shell.  The characters in
     STRING are not echoed by the superior shell; only the results
     appear.

     Before suspending, `suspend-emacs' runs the normal hook
     `suspend-hook'.

     After the user resumes Emacs, `suspend-emacs' runs the normal hook
     `suspend-resume-hook'.  *Note Hooks::.

     The next redisplay after resumption will redraw the entire screen,
     unless the variable `no-redraw-on-reenter' is non-`nil' (*note
     Refresh Screen::.).

     In the following example, note that `pwd' is not echoed after
     Emacs is suspended.  But it is read and executed by the shell.

          (suspend-emacs)
               => nil

          (add-hook 'suspend-hook
                    (function (lambda ()
                                (or (y-or-n-p
                                      "Really suspend? ")
                                    (error "Suspend cancelled")))))
               => (lambda nil
                    (or (y-or-n-p "Really suspend? ")
                        (error "Suspend cancelled")))

          (add-hook 'suspend-resume-hook
                    (function (lambda () (message "Resumed!"))))
               => (lambda nil (message "Resumed!"))

          (suspend-emacs "pwd")
               => nil

          ---------- Buffer: Minibuffer ----------
          Really suspend? y
          ---------- Buffer: Minibuffer ----------

          ---------- Parent Shell ----------
          lewis@slug[23] % /user/lewis/manual
          lewis@slug[24] % fg

          ---------- Echo Area ----------
          Resumed!

 - Variable: suspend-hook
     This variable is a normal hook run before suspending.

 - Variable: suspend-resume-hook
     This variable is a normal hook run after suspending.


File: elisp,  Node: System Environment,  Next: User Identification,  Prev: Getting Out,  Up: System Interface

Operating System Environment
============================

   Emacs provides access to variables in the operating system
environment through various functions.  These variables include the
name of the system, the user's UID, and so on.

 - Variable: system-configuration
     This variable holds the GNU configuration name for the
     hardware/software configuration of your system, as a string.  The
     convenient way to test parts of this string is with `string-match'.

 - Variable: system-type
     The value of this variable is a symbol indicating the type of
     operating system Emacs is operating on.  Here is a table of the
     possible values:

    `alpha-vms'
          VMS on the Alpha.

    `aix-v3'
          AIX.

    `berkeley-unix'
          Berkeley BSD.

    `dgux'
          Data General DGUX operating system.

    `gnu'
          the GNU system (using the GNU kernel, which consists of the
          HURD and Mach).

    `gnu/linux'
          A GNU/Linux system--that is, a variant GNU system, using the
          Linux kernel.  (These systems are the ones people often call
          "Linux," but actually Linux is just the kernel, not the whole
          system.)

    `hpux'
          Hewlett-Packard HPUX operating system.

    `irix'
          Silicon Graphics Irix system.

    `ms-dos'
          Microsoft MS-DOS "operating system."

    `next-mach'
          NeXT Mach-based system.

    `rtu'
          Masscomp RTU, UCB universe.

    `unisoft-unix'
          UniSoft UniPlus.

    `usg-unix-v'
          AT&T System V.

    `vax-vms'
          VAX VMS.

    `windows-nt'
          Microsoft windows NT.

    `xenix'
          SCO Xenix 386.

     We do not wish to add new symbols to make finer distinctions
     unless it is absolutely necessary!  In fact, we hope to eliminate
     some of these alternatives in the future.  We recommend using
     `system-configuration' to distinguish between different operating
     systems.

 - Function: system-name
     This function returns the name of the machine you are running on.
          (system-name)
               => "www.gnu.org"

   The symbol `system-name' is a variable as well as a function.  In
fact, the function returns whatever value the variable `system-name'
currently holds.  Thus, you can set the variable `system-name' in case
Emacs is confused about the name of your system.  The variable is also
useful for constructing frame titles (*note Frame Titles::.).

 - Variable: mail-host-address
     If this variable is non-`nil', it is used instead of `system-name'
     for purposes of generating email addresses.  For example, it is
     used when constructing the default value of `user-mail-address'.
     *Note User Identification::.  (Since this is done when Emacs
     starts up, the value actually used is the one saved when Emacs was
     dumped.  *Note Building Emacs::.)

 - Function: getenv VAR
     This function returns the value of the environment variable VAR,
     as a string.  Within Emacs, the environment variable values are
     kept in the Lisp variable `process-environment'.

          (getenv "USER")
               => "lewis"
          
          lewis@slug[10] % printenv
          PATH=.:/user/lewis/bin:/usr/bin:/usr/local/bin
          USER=lewis
          TERM=ibmapa16
          SHELL=/bin/csh
          HOME=/user/lewis

 - Command: setenv VARIABLE VALUE
     This command sets the value of the environment variable named
     VARIABLE to VALUE.  Both arguments should be strings.  This
     function works by modifying `process-environment'; binding that
     variable with `let' is also reasonable practice.

 - Variable: process-environment
     This variable is a list of strings, each describing one environment
     variable.  The functions `getenv' and `setenv' work by means of
     this variable.

          process-environment
          => ("l=/usr/stanford/lib/gnuemacs/lisp"
              "PATH=.:/user/lewis/bin:/usr/class:/nfsusr/local/bin"
              "USER=lewis"

          "TERM=ibmapa16"
              "SHELL=/bin/csh"
              "HOME=/user/lewis")

 - Variable: path-separator
     This variable holds a string which says which character separates
     directories in a search path (as found in an environment
     variable).  Its value is `":"' for Unix and GNU systems, and `";"'
     for MS-DOS and Windows NT.

 - Variable: invocation-name
     This variable holds the program name under which Emacs was
     invoked.  The value is a string, and does not include a directory
     name.

 - Variable: invocation-directory
     This variable holds the directory from which the Emacs executable
     was invoked, or perhaps `nil' if that directory cannot be
     determined.

 - Variable: installation-directory
     If non-`nil', this is a directory within which to look for the
     `lib-src' and `etc' subdirectories.  This is non-`nil' when Emacs
     can't find those directories in their standard installed
     locations, but can find them in a directory related somehow to the
     one containing the Emacs executable.

 - Function: load-average &optional USE-FLOAT
     This function returns the current 1-minute, 5-minute, and
     15-minute load averages, in a list.

     By default, the values are integers that are 100 times the system
     load averages, which indicate the average number of processes
     trying to run.  If USE-FLOAT is non-`nil', then they are returned
     as floating point numbers and without multiplying by 100.

          (load-average)
               => (169 48 36)
          (load-average t)
               => (1.69 0.48 0.36)
          
          lewis@rocky[5] % uptime
           11:55am  up 1 day, 19:37,  3 users,
           load average: 1.69, 0.48, 0.36

 - Function: emacs-pid
     This function returns the process ID of the Emacs process.

 - Variable: tty-erase-char
     This variable holds the erase character that was selected in the
     system's terminal driver, before Emacs was started.

 - Function: setprv PRIVILEGE-NAME &optional SETP GETPRV
     This function sets or resets a VMS privilege.  (It does not exist
     on Unix.)  The first arg is the privilege name, as a string.  The
     second argument, SETP, is `t' or `nil', indicating whether the
     privilege is to be turned on or off.  Its default is `nil'.  The
     function returns `t' if successful, `nil' otherwise.

     If the third argument, GETPRV, is non-`nil', `setprv' does not
     change the privilege, but returns `t' or `nil' indicating whether
     the privilege is currently enabled.


File: elisp,  Node: User Identification,  Next: Time of Day,  Prev: System Environment,  Up: System Interface

User Identification
===================

 - Variable: init-file-user
     This variable says which user's init files should be used by
     Emacs--or `nil' if none.  The value reflects command line options
     such as `-q' or `-u USER'.

     Lisp packages that load files of customizations, or any other sort
     of user profile, should obey this variable in deciding where to
     find it.  They should load the profile of the user name found in
     this variable.  If `init-file-user' is `nil', meaning that the `-q'
     option was used, then Lisp packages should not load any
     customization files or user profile.

 - Variable: user-mail-address
     This holds the nominal email address of the user who is using
     Emacs.  Emacs normally sets this variable to a default value after
     reading your init files, but not if you have already set it.  So
     you can set the variable to some other value in your `~/.emacs'
     file if you do not want to use the default value.

 - Function: user-login-name &optional UID
     If you don't specify UID, this function returns the name under
     which the user is logged in.  If the environment variable `LOGNAME'
     is set, that value is used.  Otherwise, if the environment variable
     `USER' is set, that value is used.  Otherwise, the value is based
     on the effective UID, not the real UID.

     If you specify UID, the value is the user name that corresponds to
     UID (which should be an integer).

          (user-login-name)
               => "lewis"

 - Function: user-real-login-name
     This function returns the user name corresponding to Emacs's real
     UID.  This ignores the effective UID and ignores the environment
     variables `LOGNAME' and `USER'.

 - Function: user-full-name &optional UID
     This function returns the full name of the logged-in user--or the
     value of the environment variables `NAME', if that is set.

          (user-full-name)
               => "Bil Lewis"

     If UID is non-`nil', then it should be an integer, a user-id, or a
     string, a login name.  Then `user-full-name' returns the full name
     corresponding to that user-id or login name.

   The symbols `user-login-name', `user-real-login-name' and
`user-full-name' are variables as well as functions.  The functions
return the same values that the variables hold.  These variables allow
you to "fake out" Emacs by telling the functions what to return.  The
variables are also useful for constructing frame titles (*note Frame
Titles::.).

 - Function: user-real-uid
     This function returns the real UID of the user.

          (user-real-uid)
               => 19

 - Function: user-uid
     This function returns the effective UID of the user.


File: elisp,  Node: Time of Day,  Next: Time Conversion,  Prev: User Identification,  Up: System Interface

Time of Day
===========

   This section explains how to determine the current time and the time
zone.

 - Function: current-time-string &optional TIME-VALUE
     This function returns the current time and date as a human-readable
     string.  The format of the string is unvarying; the number of
     characters used for each part is always the same, so you can
     reliably use `substring' to extract pieces of it.  It is wise to
     count the characters from the beginning of the string rather than
     from the end, as additional information may some day be added at
     the end.

     The argument TIME-VALUE, if given, specifies a time to format
     instead of the current time.  The argument should be a list whose
     first two elements are integers.  Thus, you can use times obtained
     from `current-time' (see below) and from `file-attributes' (*note
     File Attributes::.).

          (current-time-string)
               => "Wed Oct 14 22:21:05 1987"

 - Function: current-time
     This function returns the system's time value as a list of three
     integers: `(HIGH LOW MICROSEC)'.  The integers HIGH and LOW
     combine to give the number of seconds since 0:00 January 1, 1970,
     which is HIGH * 2**16 + LOW.

     The third element, MICROSEC, gives the microseconds since the
     start of the current second (or 0 for systems that return time
     only on the resolution of a second).

     The first two elements can be compared with file time values such
     as you get with the function `file-attributes'.  *Note File
     Attributes::.

 - Function: current-time-zone &optional TIME-VALUE
     This function returns a list describing the time zone that the
     user is in.

     The value has the form `(OFFSET NAME)'.  Here OFFSET is an integer
     giving the number of seconds ahead of UTC (east of Greenwich).  A
     negative value means west of Greenwich.  The second element, NAME
     is a string giving the name of the time zone.  Both elements
     change when daylight savings time begins or ends; if the user has
     specified a time zone that does not use a seasonal time
     adjustment, then the value is constant through time.

     If the operating system doesn't supply all the information
     necessary to compute the value, both elements of the list are
     `nil'.

     The argument TIME-VALUE, if given, specifies a time to analyze
     instead of the current time.  The argument should be a cons cell
     containing two integers, or a list whose first two elements are
     integers.  Thus, you can use times obtained from `current-time'
     (see above) and from `file-attributes' (*note File Attributes::.).


File: elisp,  Node: Time Conversion,  Next: Timers,  Prev: Time of Day,  Up: System Interface

Time Conversion
===============

   These functions convert time values (lists of two or three integers)
to strings or to calendrical information.  There is also a function to
convert calendrical information to a time value.  You can get time
values from the functions `current-time' (*note Time of Day::.) and
`file-attributes' (*note File Attributes::.).

   Many operating systems are limited to time values that contain 32
bits of information; these systems typically handle only the times from
1901-12-13 20:45:52 UTC through 2038-01-19 03:14:07 UTC.  However, some
operating systems have larger time values, and can represent times far
in the past or future.

   Time conversion functions always use the Gregorian calendar, even for
dates before the Gregorian calendar was introduced.  Year numbers count
the number of years since the year 1 B.C., and do not skip zero as
traditional Gregorian years do; for example, the year number -37
represents the Gregorian year 38 B.C.

 - Function: format-time-string FORMAT-STRING TIME
     This function converts TIME to a string according to
     FORMAT-STRING.  The argument FORMAT-STRING may contain
     `%'-sequences which say to substitute parts of the time.  Here is a
     table of what the `%'-sequences mean:

    `%a'
          This stands for the abbreviated name of the day of week.

    `%A'
          This stands for the full name of the day of week.

    `%b'
          This stands for the abbreviated name of the month.

    `%B'
          This stands for the full name of the month.

    `%c'
          This is a synonym for `%x %X'.

    `%C'
          This has a locale-specific meaning.  In the default locale
          (named C), it is equivalent to `%A, %B %e, %Y'.

    `%d'
          This stands for the day of month, zero-padded.

    `%D'
          This is a synonym for `%m/%d/%y'.

    `%e'
          This stands for the day of month, blank-padded.

    `%h'
          This is a synonym for `%b'.

    `%H'
          This stands for the hour (00-23).

    `%I'
          This stands for the hour (00-12).

    `%j'
          This stands for the day of the year (001-366).

    `%k'
          This stands for the hour (0-23), blank padded.

    `%l'
          This stands for the hour (1-12), blank padded.

    `%m'
          This stands for the month (01-12).

    `%M'
          This stands for the minute (00-59).

    `%n'
          This stands for a newline.

    `%p'
          This stands for `AM' or `PM', as appropriate.

    `%r'
          This is a synonym for `%I:%M:%S %p'.

    `%R'
          This is a synonym for `%H:%M'.

    `%S'
          This stands for the seconds (00-60).

    `%t'
          This stands for a tab character.

    `%T'
          This is a synonym for `%H:%M:%S'.

    `%U'
          This stands for the week of the year (01-52), assuming that
          weeks start on Sunday.

    `%w'
          This stands for the numeric day of week (0-6).  Sunday is day
          0.

    `%W'
          This stands for the week of the year (01-52), assuming that
          weeks start on Monday.

    `%x'
          This has a locale-specific meaning.  In the default locale
          (named `C'), it is equivalent to `%D'.

    `%X'
          This has a locale-specific meaning.  In the default locale
          (named `C'), it is equivalent to `%T'.

    `%y'
          This stands for the year without century (00-99).

    `%Y'
          This stands for the year with century.

    `%Z'
          This stands for the time zone abbreviation.

     You can also specify the field width and type of padding for any of
     these `%'-sequences.  This works as in `printf': you write the
     field width as digits in the middle of a `%'-sequences.  If you
     start the field width with `0', it means to pad with zeros.  If you
     start the field width with `_', it means to pad with spaces.

     For example, `%S' specifies the number of seconds since the minute;
     `%03S' means to pad this with zeros to 3 positions, `%_3S' to pad
     with spaces to 3 positions.  Plain `%3S' pads with zeros, because
     that is how `%S' normally pads to two positions.

 - Function: decode-time TIME
     This function converts a time value into calendrical information.
     The return value is a list of nine elements, as follows:

          (SECONDS MINUTES HOUR DAY MONTH YEAR DOW DST ZONE)

     Here is what the elements mean:

    SEC
          The number of seconds past the minute, as an integer between
          0 and 59.

    MINUTE
          The number of minutes past the hour, as an integer between 0
          and 59.

    HOUR
          The hour of the day, as an integer between 0 and 23.

    DAY
          The day of the month, as an integer between 1 and 31.

    MONTH
          The month of the year, as an integer between 1 and 12.

    YEAR
          The year, an integer typically greater than 1900.

    DOW
          The day of week, as an integer between 0 and 6, where 0
          stands for Sunday.

    DST
          `t' if daylight savings time is effect, otherwise `nil'.

    ZONE
          An integer indicating the time zone, as the number of seconds
          east of Greenwich.

     *Common Lisp Note:* Common Lisp has different meanings for DOW and
     ZONE.

 - Function: encode-time SECONDS MINUTES HOUR DAY MONTH YEAR &optional
          ...ZONE
     This function is the inverse of `decode-time'.  It converts seven
     items of calendrical data into a time value.  For the meanings of
     the arguments, see the table above under `decode-time'.

     Year numbers less than 100 are treated just like other year
     numbers.  If you want them to stand for years above 1900, you must
     alter them yourself before you call `encode-time'.

     The optional argument ZONE defaults to the current time zone and
     its daylight savings time rules.  If specified, it can be either a
     list (as you would get from `current-time-zone'), a string as in
     the `TZ' environment variable, or an integer (as you would get from
     `decode-time').  The specified zone is used without any further
     alteration for daylight savings time.

     If you pass more than seven arguments to `encode-time', the first
     six are used as SECONDS through YEAR, the last argument is used as
     ZONE, and the arguments in between are ignored.  This feature
     makes it possible to use the elements of a list returned by
     `decode-time' as the arguments to `encode-time', like this:

          (apply 'encode-time (decode-time ...))

     You can perform simple date arithmetic by using out-of-range
     values for the SEC, MINUTE, HOUR, DAY, and MONTH arguments; for
     example, day 0 means the day preceding the given month.

     The operating system puts limits on the range of possible time
     values; if you try to encode a time that is out of range, an error
     results.


File: elisp,  Node: Timers,  Next: Terminal Input,  Prev: Time Conversion,  Up: System Interface

Timers for Delayed Execution
============================

   You can set up a "timer" to call a function at a specified future
time or after a certain length of idleness.

   Emacs cannot run timers at any arbitrary point in a Lisp program; it
can run them only when Emacs could accept output from a subprocess:
namely, while waiting or inside certain primitive functions such as
`sit-for' or `read-event' which *can* wait.  Therefore, a timer's
execution may be delayed if Emacs is busy.  However, the time of
execution is very precise if Emacs is idle.

 - Function: run-at-time TIME REPEAT FUNCTION &rest ARGS
     This function arranges to call FUNCTION with arguments ARGS at
     time TIME.  The argument FUNCTION is a function to call later, and
     ARGS are the arguments to give it when it is called.  The time
     TIME is specified as a string.

     Absolute times may be specified in a wide variety of formats; this
     function tries to accept all the commonly used date formats.  Valid
     formats include these two,

          YEAR-MONTH-DAY HOUR:MIN:SEC TIMEZONE
          
          HOUR:MIN:SEC TIMEZONE MONTH/DAY/YEAR

     where in both examples all fields are numbers; the format that
     `current-time-string' returns is also allowed, and many others as
     well.

     To specify a relative time, use numbers followed by units.  For
     example:

    `1 min'
          denotes 1 minute from now.

    `1 min 5 sec'
          denotes 65 seconds from now.

    `1 min 2 sec 3 hour 4 day 5 week 6 fortnight 7 month 8 year'
          denotes exactly 103 months, 123 days, and 10862 seconds from
          now.

     If TIME is a number (integer or floating point), that specifies a
     relative time measured in seconds.

     The argument REPEAT specifies how often to repeat the call.  If
     REPEAT is `nil', there are no repetitions; FUNCTION is called just
     once, at TIME.  If REPEAT is a number, it specifies a repetition
     period measured in seconds.

     In most cases, REPEAT has no effect on when *first* call takes
     place--TIME alone specifies that.  There is one exception: if TIME
     is `t', then the timer runs whenever the time is a multiple of
     REPEAT seconds after the epoch.  This is useful for functions like
     `display-time'.

     The function `run-at-time' returns a timer value that identifies
     the particular scheduled future action.  You can use this value to
     call `cancel-timer' (see below).

 - Macro: with-timeout (SECONDS TIMEOUT-FORMS...) BODY...
     Execute BODY, but give up after SECONDS seconds.  If BODY finishes
     before the time is up, `with-timeout' returns the value of the
     last form in BODY.  If, however, the execution of BODY is cut
     short by the timeout, then `with-timeout' executes all the
     TIMEOUT-FORMS and returns the value of the last of them.

     This macro works by setting a timer to run after SECONDS seconds.
     If BODY finishes before that time, it cancels the timer.  If the
     timer actually runs, it terminates execution of BODY, then
     executes TIMEOUT-FORMS.

     Since timers can run within a Lisp program only when the program
     calls a primitive that can wait, `with-timeout' cannot stop
     executing BODY while it is in the midst of a computation--only
     when it calls one of those primitives.  So use `with-timeout' only
     with a BODY that waits for input, not one that does a long
     computation.

   The function `y-or-n-p-with-timeout' provides a simple way to use a
timer to avoid waiting too long for an answer.  *Note Yes-or-No
Queries::.

 - Function: run-with-idle-timer SECS REPEAT FUNCTION &rest ARGS
     Set up a timer which runs when Emacs has been idle for SECS
     seconds.  The value of SECS may be an integer or a floating point
     number.

     If REPEAT is `nil', the timer runs just once, the first time Emacs
     remains idle for a long enough time.  More often REPEAT is
     non-`nil', which means to run the timer *each time* Emacs remains
     idle for SECS seconds.

     The function `run-with-idle-timer' returns a timer value which you
     can use in calling `cancel-timer' (see below).

   Emacs becomes "idle" when it starts waiting for user input, and it
remains idle until the user provides some input.  If a timer is set for
five seconds of idleness, it runs approximately five seconds after Emacs
first became idle.  Even if its REPEAT is true, this timer will not run
again as long as Emacs remains idle, because the duration of idleness
will continue to increase and will not go down to five seconds again.

   Emacs can do various things while idle: garbage collect, autosave or
handle data from a subprocess.  But these interludes during idleness do
not interfere with idle timers, because they do not reset the clock of
idleness to zero.  An idle timer set for 600 seconds will run when ten
minutes have elapsed since the last user command was finished, even if
subprocess output has been accepted thousands of times within those ten
minutes, even if there have been garbage collections and autosaves.

   When the user supplies input, Emacs becomes non-idle while executing
the input.  Then it becomes idle again, and all the idle timers that are
set up to repeat will subsequently run another time, one by one.

 - Function: cancel-timer TIMER
     Cancel the requested action for TIMER, which should be a value
     previously returned by `run-at-time' or `run-with-idle-timer'.
     This cancels the effect of that call to `run-at-time'; the arrival
     of the specified time will not cause anything special to happen.


File: elisp,  Node: Terminal Input,  Next: Terminal Output,  Prev: Timers,  Up: System Interface

Terminal Input
==============

   This section describes functions and variables for recording or
manipulating terminal input.  See *Note Display::, for related
functions.

* Menu:

* Input Modes::		Options for how input is processed.
* Translating Input::   Low level conversion of some characters or events
			  into others.
* Recording Input::	Saving histories of recent or all input events.


File: elisp,  Node: Input Modes,  Next: Translating Input,  Up: Terminal Input

Input Modes
-----------

 - Function: set-input-mode INTERRUPT FLOW META QUIT-CHAR
     This function sets the mode for reading keyboard input.  If
     INTERRUPT is non-null, then Emacs uses input interrupts.  If it is
     `nil', then it uses CBREAK mode.  The default setting is system
     dependent.  Some systems always use CBREAK mode regardless of what
     is specified.

     When Emacs communicates directly with X, it ignores this argument
     and uses interrupts if that is the way it knows how to communicate.

     If FLOW is non-`nil', then Emacs uses XON/XOFF (`C-q', `C-s') flow
     control for output to the terminal.  This has no effect except in
     CBREAK mode.  *Note Flow Control::.

     The argument META controls support for input character codes above
     127.  If META is `t', Emacs converts characters with the 8th bit
     set into Meta characters.  If META is `nil', Emacs disregards the
     8th bit; this is necessary when the terminal uses it as a parity
     bit.  If META is neither `t' nor `nil', Emacs uses all 8 bits of
     input unchanged.  This is good for terminals that use 8-bit
     character sets.

     If QUIT-CHAR is non-`nil', it specifies the character to use for
     quitting.  Normally this character is `C-g'.  *Note Quitting::.

   The `current-input-mode' function returns the input mode settings
Emacs is currently using.

 - Function: current-input-mode
     This function returns current mode for reading keyboard input.  It
     returns a list, corresponding to the arguments of `set-input-mode',
     of the form `(INTERRUPT FLOW META QUIT)' in which:
    INTERRUPT
          is non-`nil' when Emacs is using interrupt-driven input.  If
          `nil', Emacs is using CBREAK mode.

    FLOW
          is non-`nil' if Emacs uses XON/XOFF (`C-q', `C-s') flow
          control for output to the terminal.  This value is meaningful
          only when INTERRUPT is `nil'.

    META
          is `t' if Emacs treats the eighth bit of input characters as
          the meta bit; `nil' means Emacs clears the eighth bit of every
          input character; any other value means Emacs uses all eight
          bits as the basic character code.

    QUIT
          is the character Emacs currently uses for quitting, usually
          `C-g'.


File: elisp,  Node: Translating Input,  Next: Recording Input,  Prev: Input Modes,  Up: Terminal Input

Translating Input Events
------------------------

   This section describes features for translating input events into
other input events before they become part of key sequences.  These
features apply to each event in the order they are described here: each
event is first modified according to `extra-keyboard-modifiers', then
translated through `keyboard-translate-table' (if applicable), and
finally decoded with the specified keyboard coding system.  If it is
being read as part of a key sequence, it is then added to the sequence
being read; then subsequences containing it are checked first with
`function-key-map' and then with `key-translation-map'.

 - Variable: extra-keyboard-modifiers
     This variable lets Lisp programs "press" the modifier keys on the
     keyboard.  The value is a bit mask:

    1
          The <SHIFT> key.

    2
          The <LOCK> key.

    4
          The <CTL> key.

    8
          The <META> key.

     Each time the user types a keyboard key, it is altered as if the
     modifier keys specified in the bit mask were held down.

     When using a window system, the program can "press" any of the
     modifier keys in this way.  Otherwise, only the <CTL> and <META>
     keys can be virtually pressed.

 - Variable: keyboard-translate-table
     This variable is the translate table for keyboard characters.  It
     lets you reshuffle the keys on the keyboard without changing any
     command bindings.  Its value is normally a char-table, or else
     `nil'.

     If `keyboard-translate-table' is a char-table, then each character
     read from the keyboard is looked up in this character.  If the
     value found there is non-`nil', then it is used instead of the
     actual input character.

     In the example below, we set `keyboard-translate-table' to a
     char-table.  Then we fill it in to swap the characters `C-s' and
     `C-\' and the characters `C-q' and `C-^'.  Subsequently, typing
     `C-\' has all the usual effects of typing `C-s', and vice versa.
     (*Note Flow Control:: for more information on this subject.)

          (defun evade-flow-control ()
            "Replace C-s with C-\ and C-q with C-^."
            (interactive)
            (setq keyboard-translate-table
                  (make-char-table 'keyboard-translate-table nil))
            ;; Swap `C-s' and `C-\'.
            (aset keyboard-translate-table ?\034 ?\^s)
            (aset keyboard-translate-table ?\^s ?\034)
            ;; Swap `C-q' and `C-^'.
            (aset keyboard-translate-table ?\036 ?\^q)
            (aset keyboard-translate-table ?\^q ?\036))

     Note that this translation is the first thing that happens to a
     character after it is read from the terminal.  Record-keeping
     features such as `recent-keys' and dribble files record the
     characters after translation.

 - Function: keyboard-translate FROM TO
     This function modifies `keyboard-translate-table' to translate
     character code FROM into character code TO.  It creates the
     keyboard translate table if necessary.

   The remaining translation features translate subsequences of key
sequences being read.  They are implemented in `read-key-sequence' and
have no effect on input read with `read-event'.

 - Variable: function-key-map
     This variable holds a keymap that describes the character
     sequences sent by function keys on an ordinary character terminal.
     This keymap has the same structure as other keymaps, but is used
     differently: it specifies translations to make while reading key
     sequences, rather than bindings for key sequences.

     If `function-key-map' "binds" a key sequence K to a vector V, then
     when K appears as a subsequence *anywhere* in a key sequence, it
     is replaced with the events in V.

     For example, VT100 terminals send `<ESC> O P' when the keypad
     <PF1> key is pressed.  Therefore, we want Emacs to translate that
     sequence of events into the single event `pf1'.  We accomplish
     this by "binding" `<ESC> O P' to `[pf1]' in `function-key-map',
     when using a VT100.

     Thus, typing `C-c <PF1>' sends the character sequence `C-c <ESC> O
     P'; later the function `read-key-sequence' translates this back
     into `C-c <PF1>', which it returns as the vector `[?\C-c pf1]'.

     Entries in `function-key-map' are ignored if they conflict with
     bindings made in the minor mode, local, or global keymaps.  The
     intent is that the character sequences that function keys send
     should not have command bindings in their own right--but if they
     do, the ordinary bindings take priority.

     The value of `function-key-map' is usually set up automatically
     according to the terminal's Terminfo or Termcap entry, but
     sometimes those need help from terminal-specific Lisp files.
     Emacs comes with terminal-specific files for many common
     terminals; their main purpose is to make entries in
     `function-key-map' beyond those that can be deduced from Termcap
     and Terminfo.  *Note Terminal-Specific::.

 - Variable: key-translation-map
     This variable is another keymap used just like `function-key-map'
     to translate input events into other events.  It differs from
     `function-key-map' in two ways:

        * `key-translation-map' goes to work after `function-key-map' is
          finished; it receives the results of translation by
          `function-key-map'.

        * `key-translation-map' overrides actual key bindings.  For
          example, if `C-x f' has a binding in `key-translation-map',
          that translation takes effect even though `C-x f' also has a
          key binding in the global map.

     The intent of `key-translation-map' is for users to map one
     character set to another, including ordinary characters normally
     bound to `self-insert-command'.

   You can use `function-key-map' or `key-translation-map' for more
than simple aliases, by using a function, instead of a key sequence, as
the "translation" of a key.  Then this function is called to compute
the translation of that key.

   The key translation function receives one argument, which is the
prompt that was specified in `read-key-sequence'--or `nil' if the key
sequence is being read by the editor command loop.  In most cases you
can ignore the prompt value.

   If the function reads input itself, it can have the effect of
altering the event that follows.  For example, here's how to define
`C-c h' to turn the character that follows into a Hyper character:

     (defun hyperify (prompt)
       (let ((e (read-event)))
         (vector (if (numberp e)
                     (logior (lsh 1 24) e)
                   (if (memq 'hyper (event-modifiers e))
                       e
                     (add-event-modifier "H-" e))))))
     
     (defun add-event-modifier (string e)
       (let ((symbol (if (symbolp e) e (car e))))
         (setq symbol (intern (concat string
                                      (symbol-name symbol))))
         (if (symbolp e)
             symbol
           (cons symbol (cdr e)))))
     
     (define-key function-key-map "\C-ch" 'hyperify)

   Finally, if you have enabled keyboard character set decoding using
`set-keyboard-coding-system', decoding is done after the translations
listed above.  *Note Specifying Coding Systems::.  In future Emacs
versions, character set decoding may be done before the other
translations.


File: elisp,  Node: Recording Input,  Prev: Translating Input,  Up: Terminal Input

Recording Input
---------------

 - Function: recent-keys
     This function returns a vector containing the last 100 input
     events from the keyboard or mouse.  All input events are included,
     whether or not they were used as parts of key sequences.  Thus,
     you always get the last 100 input events, not counting events
     generated by keyboard macros.  (These are excluded because they
     are less interesting for debugging; it should be enough to see the
     events that invoked the macros.)

 - Command: open-dribble-file FILENAME
     This function opens a "dribble file" named FILENAME.  When a
     dribble file is open, each input event from the keyboard or mouse
     (but not those from keyboard macros) is written in that file.  A
     non-character event is expressed using its printed representation
     surrounded by `<...>'.

     You close the dribble file by calling this function with an
     argument of `nil'.

     This function is normally used to record the input necessary to
     trigger an Emacs bug, for the sake of a bug report.

          (open-dribble-file "~/dribble")
               => nil

   See also the `open-termscript' function (*note Terminal Output::.).


File: elisp,  Node: Terminal Output,  Next: Special Keysyms,  Prev: Terminal Input,  Up: System Interface

Terminal Output
===============

   The terminal output functions send output to the terminal or keep
track of output sent to the terminal.  The variable `baud-rate' tells
you what Emacs thinks is the output speed of the terminal.

 - Variable: baud-rate
     This variable's value is the output speed of the terminal, as far
     as Emacs knows.  Setting this variable does not change the speed
     of actual data transmission, but the value is used for
     calculations such as padding.  It also affects decisions about
     whether to scroll part of the screen or repaint--even when using a
     window system.  (We designed it this way despite the fact that a
     window system has no true "output speed", to give you a way to
     tune these decisions.)

     The value is measured in baud.

   If you are running across a network, and different parts of the
network work at different baud rates, the value returned by Emacs may be
different from the value used by your local terminal.  Some network
protocols communicate the local terminal speed to the remote machine, so
that Emacs and other programs can get the proper value, but others do
not.  If Emacs has the wrong value, it makes decisions that are less
than optimal.  To fix the problem, set `baud-rate'.

 - Function: baud-rate
     This obsolete function returns the value of the variable
     `baud-rate'.

 - Function: send-string-to-terminal STRING
     This function sends STRING to the terminal without alteration.
     Control characters in STRING have terminal-dependent effects.

     One use of this function is to define function keys on terminals
     that have downloadable function key definitions.  For example,
     this is how on certain terminals to define function key 4 to move
     forward four characters (by transmitting the characters `C-u C-f'
     to the computer):

          (send-string-to-terminal "\eF4\^U\^F")
               => nil

 - Command: open-termscript FILENAME
     This function is used to open a "termscript file" that will record
     all the characters sent by Emacs to the terminal.  It returns
     `nil'.  Termscript files are useful for investigating problems
     where Emacs garbles the screen, problems that are due to incorrect
     Termcap entries or to undesirable settings of terminal options more
     often than to actual Emacs bugs.  Once you are certain which
     characters were actually output, you can determine reliably
     whether they correspond to the Termcap specifications in use.

     See also `open-dribble-file' in *Note Terminal Input::.

          (open-termscript "../junk/termscript")
               => nil


File: elisp,  Node: Special Keysyms,  Next: Flow Control,  Prev: Terminal Output,  Up: System Interface

System-Specific X11 Keysyms
===========================

   To define system-specific X11 keysyms, set the variable
`system-key-alist'.

 - Variable: system-key-alist
     This variable's value should be an alist with one element for each
     system-specific keysym.  An element has this form: `(CODE .
     SYMBOL)', where CODE is the numeric keysym code (not including the
     "vendor specific" bit, -2**28, and SYMBOL is the name for the
     function key.

     For example `(168 . mute-acute)' defines a system-specific key used
     by HP X servers whose numeric code is -2**28 + 168.

     It is not crucial to exclude from the alist the keysyms of other X
     servers; those do no harm, as long as they don't conflict with the
     ones used by the X server actually in use.

     The variable is always local to the current terminal, and cannot be
     buffer-local.  *Note Multiple Displays::.


File: elisp,  Node: Flow Control,  Next: Batch Mode,  Prev: Special Keysyms,  Up: System Interface

Flow Control
============

   This section attempts to answer the question "Why does Emacs use
flow-control characters in its command character set?"  For a second
view on this issue, read the comments on flow control in the
`emacs/INSTALL' file from the distribution; for help with Termcap
entries and DEC terminal concentrators, see `emacs/etc/TERMS'.

   At one time, most terminals did not need flow control, and none used
`C-s' and `C-q' for flow control.  Therefore, the choice of `C-s' and
`C-q' as command characters for searching and quoting was natural and
uncontroversial.  With so many commands needing key assignments, of
course we assigned meanings to nearly all ASCII control characters.

   Later, some terminals were introduced which required these characters
for flow control.  They were not very good terminals for full-screen
editing, so Emacs maintainers ignored them.  In later years, flow
control with `C-s' and `C-q' became widespread among terminals, but by
this time it was usually an option.  And the majority of Emacs users,
who can turn flow control off, did not want to switch to less mnemonic
key bindings for the sake of flow control.

   So which usage is "right"--Emacs's or that of some terminal and
concentrator manufacturers?  This question has no simple answer.

   One reason why we are reluctant to cater to the problems caused by
`C-s' and `C-q' is that they are gratuitous.  There are other
techniques (albeit less common in practice) for flow control that
preserve transparency of the character stream.  Note also that their use
for flow control is not an official standard.  Interestingly, on the
model 33 teletype with a paper tape punch (around 1970), `C-s' and
`C-q' were sent by the computer to turn the punch on and off!

   As window systems and PC terminal emulators replace character-only
terminals, the flow control problem is gradually disappearing.  For the
mean time, Emacs provides a convenient way of enabling flow control if
you want it: call the function `enable-flow-control'.

 - Command: enable-flow-control
     This function enables use of `C-s' and `C-q' for output flow
     control, and provides the characters `C-\' and `C-^' as aliases
     for them using `keyboard-translate-table' (*note Translating
     Input::.).

   You can use the function `enable-flow-control-on' in your `.emacs'
file to enable flow control automatically on certain terminal types.

 - Function: enable-flow-control-on &rest TERMTYPES
     This function enables flow control, and the aliases `C-\' and
     `C-^', if the terminal type is one of TERMTYPES.  For example:

          (enable-flow-control-on "vt200" "vt300" "vt101" "vt131")

   Here is how `enable-flow-control' does its job:

  1. It sets CBREAK mode for terminal input, and tells the operating
     system to handle flow control, with `(set-input-mode nil t)'.

  2. It sets up `keyboard-translate-table' to translate `C-\' and `C-^'
     into `C-s' and `C-q'.  Except at its very lowest level, Emacs
     never knows that the characters typed were anything but `C-s' and
     `C-q', so you can in effect type them as `C-\' and `C-^' even when
     they are input for other commands.  *Note Translating Input::.

   If the terminal is the source of the flow control characters, then
once you enable kernel flow control handling, you probably can make do
with less padding than normal for that terminal.  You can reduce the
amount of padding by customizing the Termcap entry.  You can also
reduce it by setting `baud-rate' to a smaller value so that Emacs uses
a smaller speed when calculating the padding needed.  *Note Terminal
Output::.


File: elisp,  Node: Batch Mode,  Prev: Flow Control,  Up: System Interface

Batch Mode
==========

   The command line option `-batch' causes Emacs to run
noninteractively.  In this mode, Emacs does not read commands from the
terminal, it does not alter the terminal modes, and it does not expect
to be outputting to an erasable screen.  The idea is that you specify
Lisp programs to run; when they are finished, Emacs should exit.  The
way to specify the programs to run is with `-l FILE', which loads the
library named FILE, and `-f FUNCTION', which calls FUNCTION with no
arguments.

   Any Lisp program output that would normally go to the echo area,
either using `message' or using `prin1', etc., with `t' as the stream,
goes instead to Emacs's standard error descriptor when in batch mode.
Thus, Emacs behaves much like a noninteractive application program.
(The echo area output that Emacs itself normally generates, such as
command echoing, is suppressed entirely.)

 - Variable: noninteractive
     This variable is non-`nil' when Emacs is running in batch mode.


File: elisp,  Node: Display,  Next: Calendar,  Prev: Processes,  Up: Top

Emacs Display
*************

   This chapter describes a number of features related to the display
that Emacs presents to the user.

* Menu:

* Refresh Screen::      Clearing the screen and redrawing everything on it.
* Truncation::          Folding or wrapping long text lines.
* The Echo Area::       Where messages are displayed.
* Invisible Text::      Hiding part of the buffer text.
* Selective Display::   Hiding part of the buffer text (the old way).
* Overlay Arrow::       Display of an arrow to indicate position.
* Temporary Displays::  Displays that go away automatically.
* Overlays::		Use overlays to highlight parts of the buffer.
* Width::               How wide is a character or string.
* Faces::		A face defines a graphics appearance: font, color, etc.
* Blinking::            How Emacs shows the matching open parenthesis.
* Inverse Video::	Specifying how the screen looks.
* Usual Display::	The usual conventions for displaying nonprinting chars.
* Display Tables::	How to specify other conventions.
* Beeping::             Audible signal to the user.
* Window Systems::      Which window system is being used.

