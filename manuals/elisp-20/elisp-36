This is Info file elisp, produced by Makeinfo version 1.68 from the
input file elisp.texi.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY

   This version is the edition 2.5 of the GNU Emacs Lisp Reference
Manual.  It corresponds to Emacs Version 20.3

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307  USA

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: elisp,  Node: Process Information,  Next: Input to Processes,  Prev: Deleting Processes,  Up: Processes

Process Information
===================

   Several functions return information about processes.
`list-processes' is provided for interactive use.

 - Command: list-processes
     This command displays a listing of all living processes.  In
     addition, it finally deletes any process whose status was `Exited'
     or `Signaled'.  It returns `nil'.

 - Function: process-list
     This function returns a list of all processes that have not been
     deleted.

          (process-list)
               => (#<process display-time> #<process shell>)

 - Function: get-process NAME
     This function returns the process named NAME, or `nil' if there is
     none.  An error is signaled if NAME is not a string.

          (get-process "shell")
               => #<process shell>

 - Function: process-command PROCESS
     This function returns the command that was executed to start
     PROCESS.  This is a list of strings, the first string being the
     program executed and the rest of the strings being the arguments
     that were given to the program.

          (process-command (get-process "shell"))
               => ("/bin/csh" "-i")

 - Function: process-id PROCESS
     This function returns the PID of PROCESS.  This is an integer that
     distinguishes the process PROCESS from all other processes running
     on the same computer at the current time.  The PID of a process is
     chosen by the operating system kernel when the process is started
     and remains constant as long as the process exists.

 - Function: process-name PROCESS
     This function returns the name of PROCESS.

 - Function: process-contact PROCESS
     This function returns `t' for an ordinary child process, and
     `(HOSTNAME SERVICE)' for a net connection (*note Network::.).

 - Function: process-status PROCESS-NAME
     This function returns the status of PROCESS-NAME as a symbol.  The
     argument PROCESS-NAME must be a process, a buffer, a process name
     (string) or a buffer name (string).

     The possible values for an actual subprocess are:

    `run'
          for a process that is running.

    `stop'
          for a process that is stopped but continuable.

    `exit'
          for a process that has exited.

    `signal'
          for a process that has received a fatal signal.

    `open'
          for a network connection that is open.

    `closed'
          for a network connection that is closed.  Once a connection
          is closed, you cannot reopen it, though you might be able to
          open a new connection to the same place.

    `nil'
          if PROCESS-NAME is not the name of an existing process.

          (process-status "shell")
               => run

          (process-status (get-buffer "*shell*"))
               => run

          x
               => #<process xx<1>>
          (process-status x)
               => exit

     For a network connection, `process-status' returns one of the
     symbols `open' or `closed'.  The latter means that the other side
     closed the connection, or Emacs did `delete-process'.

 - Function: process-exit-status PROCESS
     This function returns the exit status of PROCESS or the signal
     number that killed it.  (Use the result of `process-status' to
     determine which of those it is.)  If PROCESS has not yet
     terminated, the value is 0.

 - Function: process-tty-name PROCESS
     This function returns the terminal name that PROCESS is using for
     its communication with Emacs--or `nil' if it is using pipes
     instead of a terminal (see `process-connection-type' in *Note
     Asynchronous Processes::).

 - Function: process-coding-system PROCESS
     This function returns a cons cell describing the coding systems in
     use for decoding output from PROCESS and for encoding input to
     PROCESS (*note Coding Systems::.).  The value has this form:

          (CODING-SYSTEM-FOR-DECODING . CODING-SYSTEM-FOR-ENCODING)

 - Function: set-process-coding-system PROCESS DECODING-SYSTEM
          ENCODING-SYSTEM
     This function specifies the coding systems to use for subsequent
     output from and input to PROCESS.  It will use DECODING-SYSTEM to
     decode subprocess output, and ENCODING-SYSTEM to encode subprocess
     input.


File: elisp,  Node: Input to Processes,  Next: Signals to Processes,  Prev: Process Information,  Up: Processes

Sending Input to Processes
==========================

   Asynchronous subprocesses receive input when it is sent to them by
Emacs, which is done with the functions in this section.  You must
specify the process to send input to, and the input data to send.  The
data appears on the "standard input" of the subprocess.

   Some operating systems have limited space for buffered input in a
PTY.  On these systems, Emacs sends an EOF periodically amidst the
other characters, to force them through.  For most programs, these EOFs
do no harm.

   Subprocess input is normally encoded using a coding system before the
subprocess receives it, much like text written into a file.  You can use
`set-process-coding-system' to specify which coding system to use
(*note Process Information::.).  Otherwise, the coding system comes from
`coding-system-for-write', if that is non-`nil'; or else from the
defaulting mechanism (*note Default Coding Systems::.).

 - Function: process-send-string PROCESS-NAME STRING
     This function sends PROCESS-NAME the contents of STRING as
     standard input.  The argument PROCESS-NAME must be a process or
     the name of a process.  If it is `nil', the current buffer's
     process is used.

     The function returns `nil'.

          (process-send-string "shell<1>" "ls\n")
               => nil

          ---------- Buffer: *shell* ----------
          ...
          introduction.texi               syntax-tables.texi~
          introduction.texi~              text.texi
          introduction.txt                text.texi~
          ...
          ---------- Buffer: *shell* ----------

 - Command: process-send-region PROCESS-NAME START END
     This function sends the text in the region defined by START and
     END as standard input to PROCESS-NAME, which is a process or a
     process name.  (If it is `nil', the current buffer's process is
     used.)

     An error is signaled unless both START and END are integers or
     markers that indicate positions in the current buffer.  (It is
     unimportant which number is larger.)

 - Function: process-send-eof &optional PROCESS-NAME
     This function makes PROCESS-NAME see an end-of-file in its input.
     The EOF comes after any text already sent to it.

     If PROCESS-NAME is not supplied, or if it is `nil', then this
     function sends the EOF to the current buffer's process.  An error
     is signaled if the current buffer has no process.

     The function returns PROCESS-NAME.

          (process-send-eof "shell")
               => "shell"


File: elisp,  Node: Signals to Processes,  Next: Output from Processes,  Prev: Input to Processes,  Up: Processes

Sending Signals to Processes
============================

   "Sending a signal" to a subprocess is a way of interrupting its
activities.  There are several different signals, each with its own
meaning.  The set of signals and their names is defined by the operating
system.  For example, the signal `SIGINT' means that the user has typed
`C-c', or that some analogous thing has happened.

   Each signal has a standard effect on the subprocess.  Most signals
kill the subprocess, but some stop or resume execution instead.  Most
signals can optionally be handled by programs; if the program handles
the signal, then we can say nothing in general about its effects.

   You can send signals explicitly by calling the functions in this
section.  Emacs also sends signals automatically at certain times:
killing a buffer sends a `SIGHUP' signal to all its associated
processes; killing Emacs sends a `SIGHUP' signal to all remaining
processes.  (`SIGHUP' is a signal that usually indicates that the user
hung up the phone.)

   Each of the signal-sending functions takes two optional arguments:
PROCESS-NAME and CURRENT-GROUP.

   The argument PROCESS-NAME must be either a process, the name of one,
or `nil'.  If it is `nil', the process defaults to the process
associated with the current buffer.  An error is signaled if
PROCESS-NAME does not identify a process.

   The argument CURRENT-GROUP is a flag that makes a difference when
you are running a job-control shell as an Emacs subprocess.  If it is
non-`nil', then the signal is sent to the current process-group of the
terminal that Emacs uses to communicate with the subprocess.  If the
process is a job-control shell, this means the shell's current subjob.
If it is `nil', the signal is sent to the process group of the
immediate subprocess of Emacs.  If the subprocess is a job-control
shell, this is the shell itself.

   The flag CURRENT-GROUP has no effect when a pipe is used to
communicate with the subprocess, because the operating system does not
support the distinction in the case of pipes.  For the same reason,
job-control shells won't work when a pipe is used.  See
`process-connection-type' in *Note Asynchronous Processes::.

 - Function: interrupt-process &optional PROCESS-NAME CURRENT-GROUP
     This function interrupts the process PROCESS-NAME by sending the
     signal `SIGINT'.  Outside of Emacs, typing the "interrupt
     character" (normally `C-c' on some systems, and `DEL' on others)
     sends this signal.  When the argument CURRENT-GROUP is non-`nil',
     you can think of this function as "typing `C-c'" on the terminal
     by which Emacs talks to the subprocess.

 - Function: kill-process &optional PROCESS-NAME CURRENT-GROUP
     This function kills the process PROCESS-NAME by sending the signal
     `SIGKILL'.  This signal kills the subprocess immediately, and
     cannot be handled by the subprocess.

 - Function: quit-process &optional PROCESS-NAME CURRENT-GROUP
     This function sends the signal `SIGQUIT' to the process
     PROCESS-NAME.  This signal is the one sent by the "quit character"
     (usually `C-b' or `C-\') when you are not inside Emacs.

 - Function: stop-process &optional PROCESS-NAME CURRENT-GROUP
     This function stops the process PROCESS-NAME by sending the signal
     `SIGTSTP'.  Use `continue-process' to resume its execution.

     Outside of Emacs, on systems with job control, the "stop character"
     (usually `C-z') normally sends this signal.  When CURRENT-GROUP is
     non-`nil', you can think of this function as "typing `C-z'" on the
     terminal Emacs uses to communicate with the subprocess.

 - Function: continue-process &optional PROCESS-NAME CURRENT-GROUP
     This function resumes execution of the process PROCESS by sending
     it the signal `SIGCONT'.  This presumes that PROCESS-NAME was
     stopped previously.

 - Function: signal-process PID SIGNAL
     This function sends a signal to process PID, which need not be a
     child of Emacs.  The argument SIGNAL specifies which signal to
     send; it should be an integer.


File: elisp,  Node: Output from Processes,  Next: Sentinels,  Prev: Signals to Processes,  Up: Processes

Receiving Output from Processes
===============================

   There are two ways to receive the output that a subprocess writes to
its standard output stream.  The output can be inserted in a buffer,
which is called the associated buffer of the process, or a function
called the "filter function" can be called to act on the output.  If
the process has no buffer and no filter function, its output is
discarded.

   Output from a subprocess can arrive only while Emacs is waiting: when
reading terminal input, in `sit-for' and `sleep-for' (*note
Waiting::.), and in `accept-process-output' (*note Accepting
Output::.).  This minimizes the problem of timing errors that usually
plague parallel programming.  For example, you can safely create a
process and only then specify its buffer or filter function; no output
can arrive before you finish, if the code in between does not call any
primitive that waits.

   Subprocess output is normally decoded using a coding system before
the buffer or filter function receives it, much like text read from a
file.  You can use `set-process-coding-system' to specify which coding
system to use (*note Process Information::.).  Otherwise, the coding
system comes from `coding-system-for-read', if that is non-`nil'; or
else from the defaulting mechanism (*note Default Coding Systems::.).

   *Warning:* Coding systems such as `undecided' which determine the
coding system from the data do not work entirely reliably with
asynchronous subprocess output.  This is because Emacs has to process
asynchronous subprocess output in batches, as it arrives.  Emacs must
try to detect the proper coding system from one batch at a time, and
this does not always work.  Therefore, if at all possible, use a coding
system which determines both the character code conversion and the end
of line conversion--that is, one like `latin-1-unix', rather than
`undecided' or `latin-1'.

* Menu:

* Process Buffers::       If no filter, output is put in a buffer.
* Filter Functions::      Filter functions accept output from the process.
* Accepting Output::      Explicitly permitting subprocess output.
                            Waiting for subprocess output.


File: elisp,  Node: Process Buffers,  Next: Filter Functions,  Up: Output from Processes

Process Buffers
---------------

   A process can (and usually does) have an "associated buffer", which
is an ordinary Emacs buffer that is used for two purposes: storing the
output from the process, and deciding when to kill the process.  You
can also use the buffer to identify a process to operate on, since in
normal practice only one process is associated with any given buffer.
Many applications of processes also use the buffer for editing input to
be sent to the process, but this is not built into Emacs Lisp.

   Unless the process has a filter function (*note Filter Functions::.),
its output is inserted in the associated buffer.  The position to insert
the output is determined by the `process-mark', which is then updated
to point to the end of the text just inserted.  Usually, but not
always, the `process-mark' is at the end of the buffer.

 - Function: process-buffer PROCESS
     This function returns the associated buffer of the process PROCESS.

          (process-buffer (get-process "shell"))
               => #<buffer *shell*>

 - Function: process-mark PROCESS
     This function returns the process marker for PROCESS, which is the
     marker that says where to insert output from the process.

     If PROCESS does not have a buffer, `process-mark' returns a marker
     that points nowhere.

     Insertion of process output in a buffer uses this marker to decide
     where to insert, and updates it to point after the inserted text.
     That is why successive batches of output are inserted
     consecutively.

     Filter functions normally should use this marker in the same
     fashion as is done by direct insertion of output in the buffer.  A
     good example of a filter function that uses `process-mark' is
     found at the end of the following section.

     When the user is expected to enter input in the process buffer for
     transmission to the process, the process marker separates the new
     input from previous output.

 - Function: set-process-buffer PROCESS BUFFER
     This function sets the buffer associated with PROCESS to BUFFER.
     If BUFFER is `nil', the process becomes associated with no buffer.

 - Function: get-buffer-process BUFFER-OR-NAME
     This function returns the process associated with BUFFER-OR-NAME.
     If there are several processes associated with it, then one is
     chosen.  (Currently, the one chosen is the one most recently
     created.)  It is usually a bad idea to have more than one process
     associated with the same buffer.

          (get-buffer-process "*shell*")
               => #<process shell>

     Killing the process's buffer deletes the process, which kills the
     subprocess with a `SIGHUP' signal (*note Signals to Processes::.).


File: elisp,  Node: Filter Functions,  Next: Accepting Output,  Prev: Process Buffers,  Up: Output from Processes

Process Filter Functions
------------------------

   A process "filter function" is a function that receives the standard
output from the associated process.  If a process has a filter, then
*all* output from that process is passed to the filter.  The process
buffer is used directly for output from the process only when there is
no filter.

   The filter function can only be called when Emacs is waiting for
something, because process output arrives only at such times.  Emacs
waits when reading terminal input, in `sit-for' and `sleep-for' (*note
Waiting::.), and in `accept-process-output' (*note Accepting Output::.).

   A filter function must accept two arguments: the associated process
and a string, which is output just received from it.  The function is
then free to do whatever it chooses with the output.

   Quitting is normally inhibited within a filter function--otherwise,
the effect of typing `C-g' at command level or to quit a user command
would be unpredictable.  If you want to permit quitting inside a filter
function, bind `inhibit-quit' to `nil'.  *Note Quitting::.

   If an error happens during execution of a filter function, it is
caught automatically, so that it doesn't stop the execution of whatever
program was running when the filter function was started.  However, if
`debug-on-error' is non-`nil', the error-catching is turned off.  This
makes it possible to use the Lisp debugger to debug the filter
function.  *Note Debugger::.

   Many filter functions sometimes or always insert the text in the
process's buffer, mimicking the actions of Emacs when there is no
filter.  Such filter functions need to use `set-buffer' in order to be
sure to insert in that buffer.  To avoid setting the current buffer
semipermanently, these filter functions must save and restore the
current buffer.  They should also update the process marker, and in some
cases update the value of point.  Here is how to do these things:

     (defun ordinary-insertion-filter (proc string)
       (with-current-buffer (process-buffer proc)
         (let ((moving (= (point) (process-mark proc))))

     (save-excursion
             ;; Insert the text, advancing the process marker.
             (goto-char (process-mark proc))
             (insert string)
             (set-marker (process-mark proc) (point)))
           (if moving (goto-char (process-mark proc))))))

The reason to use `with-current-buffer', rather than using
`save-excursion' to save and restore the current buffer, is so as to
preserve the change in point made by the second call to `goto-char'.

   To make the filter force the process buffer to be visible whenever
new text arrives, insert the following line just before the
`with-current-buffer' construct:

     (display-buffer (process-buffer proc))

   To force point to the end of the new output, no matter where it was
previously, eliminate the variable `moving' and call `goto-char'
unconditionally.

   In earlier Emacs versions, every filter function that did regular
expression searching or matching had to explicitly save and restore the
match data.  Now Emacs does this automatically for filter functions;
they never need to do it explicitly.  *Note Match Data::.

   A filter function that writes the output into the buffer of the
process should check whether the buffer is still alive.  If it tries to
insert into a dead buffer, it will get an error.  The expression
`(buffer-name (process-buffer PROCESS))' returns `nil' if the buffer is
dead.

   The output to the function may come in chunks of any size.  A program
that produces the same output twice in a row may send it as one batch of
200 characters one time, and five batches of 40 characters the next.  If
the filter looks for certain text strings in the subprocess output, make
sure to handle the case where one of these strings is split across two
or more batches of output.

 - Function: set-process-filter PROCESS FILTER
     This function gives PROCESS the filter function FILTER.  If FILTER
     is `nil', it gives the process no filter.

 - Function: process-filter PROCESS
     This function returns the filter function of PROCESS, or `nil' if
     it has none.

   Here is an example of use of a filter function:

     (defun keep-output (process output)
        (setq kept (cons output kept)))
          => keep-output

     (setq kept nil)
          => nil

     (set-process-filter (get-process "shell") 'keep-output)
          => keep-output

     (process-send-string "shell" "ls ~/other\n")
          => nil
     kept
          => ("lewis@slug[8] % "

     "FINAL-W87-SHORT.MSS    backup.otl              kolstad.mss~
     address.txt             backup.psf              kolstad.psf
     backup.bib~             david.mss               resume-Dec-86.mss~
     backup.err              david.psf               resume-Dec.psf
     backup.mss              dland                   syllabus.mss
     "
     "#backups.mss#          backup.mss~             kolstad.mss
     ")


File: elisp,  Node: Accepting Output,  Prev: Filter Functions,  Up: Output from Processes

Accepting Output from Processes
-------------------------------

   Output from asynchronous subprocesses normally arrives only while
Emacs is waiting for some sort of external event, such as elapsed time
or terminal input.  Occasionally it is useful in a Lisp program to
explicitly permit output to arrive at a specific point, or even to wait
until output arrives from a process.

 - Function: accept-process-output &optional PROCESS SECONDS MILLISEC
     This function allows Emacs to read pending output from processes.
     The output is inserted in the associated buffers or given to their
     filter functions.  If PROCESS is non-`nil' then this function does
     not return until some output has been received from PROCESS.

     The arguments SECONDS and MILLISEC let you specify timeout
     periods.  The former specifies a period measured in seconds and the
     latter specifies one measured in milliseconds.  The two time
     periods thus specified are added together, and
     `accept-process-output' returns after that much time whether or
     not there has been any subprocess output.

     The argument SECONDS need not be an integer.  If it is a floating
     point number, this function waits for a fractional number of
     seconds.  Some systems support only a whole number of seconds; on
     these systems, SECONDS is rounded down.

     Not all operating systems support waiting periods other than
     multiples of a second; on those that do not, you get an error if
     you specify nonzero MILLISEC.

     The function `accept-process-output' returns non-`nil' if it did
     get some output, or `nil' if the timeout expired before output
     arrived.


File: elisp,  Node: Sentinels,  Next: Transaction Queues,  Prev: Output from Processes,  Up: Processes

Sentinels: Detecting Process Status Changes
===========================================

   A "process sentinel" is a function that is called whenever the
associated process changes status for any reason, including signals
(whether sent by Emacs or caused by the process's own actions) that
terminate, stop, or continue the process.  The process sentinel is also
called if the process exits.  The sentinel receives two arguments: the
process for which the event occurred, and a string describing the type
of event.

   The string describing the event looks like one of the following:

   * `"finished\n"'.

   * `"exited abnormally with code EXITCODE\n"'.

   * `"NAME-OF-SIGNAL\n"'.

   * `"NAME-OF-SIGNAL (core dumped)\n"'.

   A sentinel runs only while Emacs is waiting (e.g., for terminal
input, or for time to elapse, or for process output).  This avoids the
timing errors that could result from running them at random places in
the middle of other Lisp programs.  A program can wait, so that
sentinels will run, by calling `sit-for' or `sleep-for' (*note
Waiting::.), or `accept-process-output' (*note Accepting Output::.).
Emacs also allows sentinels to run when the command loop is reading
input.

   Quitting is normally inhibited within a sentinel--otherwise, the
effect of typing `C-g' at command level or to quit a user command would
be unpredictable.  If you want to permit quitting inside a sentinel,
bind `inhibit-quit' to `nil'.  *Note Quitting::.

   A sentinel that writes the output into the buffer of the process
should check whether the buffer is still alive.  If it tries to insert
into a dead buffer, it will get an error.  If the buffer is dead,
`(buffer-name (process-buffer PROCESS))' returns `nil'.

   If an error happens during execution of a sentinel, it is caught
automatically, so that it doesn't stop the execution of whatever
programs was running when the sentinel was started.  However, if
`debug-on-error' is non-`nil', the error-catching is turned off.  This
makes it possible to use the Lisp debugger to debug the sentinel.
*Note Debugger::.

   In earlier Emacs versions, every sentinel that did regular expression
searching or matching had to explicitly save and restore the match data.
Now Emacs does this automatically for sentinels; they never need to do
it explicitly.  *Note Match Data::.

 - Function: set-process-sentinel PROCESS SENTINEL
     This function associates SENTINEL with PROCESS.  If SENTINEL is
     `nil', then the process will have no sentinel.  The default
     behavior when there is no sentinel is to insert a message in the
     process's buffer when the process status changes.

          (defun msg-me (process event)
             (princ
               (format "Process: %s had the event `%s'" process event)))
          (set-process-sentinel (get-process "shell") 'msg-me)
               => msg-me

          (kill-process (get-process "shell"))
               -| Process: #<process shell> had the event `killed'
               => #<process shell>

 - Function: process-sentinel PROCESS
     This function returns the sentinel of PROCESS, or `nil' if it has
     none.

 - Function: waiting-for-user-input-p
     While a sentinel or filter function is running, this function
     returns non-`nil' if Emacs was waiting for keyboard input from the
     user at the time the sentinel or filter function was called, `nil'
     if it was not.


File: elisp,  Node: Transaction Queues,  Next: Network,  Prev: Sentinels,  Up: Processes

Transaction Queues
==================

   You can use a "transaction queue" to communicate with a subprocess
using transactions.  First use `tq-create' to create a transaction
queue communicating with a specified process.  Then you can call
`tq-enqueue' to send a transaction.

 - Function: tq-create PROCESS
     This function creates and returns a transaction queue
     communicating with PROCESS.  The argument PROCESS should be a
     subprocess capable of sending and receiving streams of bytes.  It
     may be a child process, or it may be a TCP connection to a server,
     possibly on another machine.

 - Function: tq-enqueue QUEUE QUESTION REGEXP CLOSURE FN
     This function sends a transaction to queue QUEUE.  Specifying the
     queue has the effect of specifying the subprocess to talk to.

     The argument QUESTION is the outgoing message that starts the
     transaction.  The argument FN is the function to call when the
     corresponding answer comes back; it is called with two arguments:
     CLOSURE, and the answer received.

     The argument REGEXP is a regular expression that should match the
     entire answer, but nothing less; that's how `tq-enqueue' determines
     where the answer ends.

     The return value of `tq-enqueue' itself is not meaningful.

 - Function: tq-close QUEUE
     Shut down transaction queue QUEUE, waiting for all pending
     transactions to complete, and then terminate the connection or
     child process.

   Transaction queues are implemented by means of a filter function.
*Note Filter Functions::.


File: elisp,  Node: Network,  Prev: Transaction Queues,  Up: Processes

Network Connections
===================

   Emacs Lisp programs can open TCP network connections to other
processes on the same machine or other machines.  A network connection
is handled by Lisp much like a subprocess, and is represented by a
process object.  However, the process you are communicating with is not
a child of the Emacs process, so you can't kill it or send it signals.
All you can do is send and receive data.  `delete-process' closes the
connection, but does not kill the process at the other end; that
process must decide what to do about closure of the connection.

   You can distinguish process objects representing network connections
from those representing subprocesses with the `process-status'
function.  It always returns either `open' or `closed' for a network
connection, and it never returns either of those values for a real
subprocess.  *Note Process Information::.

 - Function: open-network-stream NAME BUFFER-OR-NAME HOST SERVICE
     This function opens a TCP connection for a service to a host.  It
     returns a process object to represent the connection.

     The NAME argument specifies the name for the process object.  It
     is modified as necessary to make it unique.

     The BUFFER-OR-NAME argument is the buffer to associate with the
     connection.  Output from the connection is inserted in the buffer,
     unless you specify a filter function to handle the output.  If
     BUFFER-OR-NAME is `nil', it means that the connection is not
     associated with any buffer.

     The arguments HOST and SERVICE specify where to connect to; HOST
     is the host name (a string), and SERVICE is the name of a defined
     network service (a string) or a port number (an integer).


File: elisp,  Node: System Interface,  Next: Tips,  Prev: Calendar,  Up: Top

Operating System Interface
**************************

   This chapter is about starting and getting out of Emacs, access to
values in the operating system environment, and terminal input, output,
and flow control.

   *Note Building Emacs::, for related information.  See also *Note
Display::, for additional operating system status information
pertaining to the terminal and the screen.

* Menu:

* Starting Up::         Customizing Emacs start-up processing.
* Getting Out::         How exiting works (permanent or temporary).
* System Environment::  Distinguish the name and kind of system.
* User Identification:: Finding the name and user id of the user.
* Time of Day::		Getting the current time.
* Time Conversion::     Converting a time from numeric form to a string, or
                          to calendrical data (or vice versa).
* Timers::		Setting a timer to call a function at a certain time.
* Terminal Input::      Recording terminal input for debugging.
* Terminal Output::     Recording terminal output for debugging.
* Special Keysyms::     Defining system-specific key symbols for X windows.
* Flow Control::        How to turn output flow control on or off.
* Batch Mode::          Running Emacs without terminal interaction.


File: elisp,  Node: Starting Up,  Next: Getting Out,  Up: System Interface

Starting Up Emacs
=================

   This section describes what Emacs does when it is started, and how
you can customize these actions.

* Menu:

* Start-up Summary::        Sequence of actions Emacs performs at start-up.
* Init File::               Details on reading the init file (`.emacs').
* Terminal-Specific::       How the terminal-specific Lisp file is read.
* Command Line Arguments::  How command line arguments are processed,
                              and how you can customize them.


File: elisp,  Node: Start-up Summary,  Next: Init File,  Up: Starting Up

Summary: Sequence of Actions at Start Up
----------------------------------------

   The order of operations performed (in `startup.el') by Emacs when it
is started up is as follows:

  1. It adds subdirectories to `load-path', by running the file named
     `subdirs.el' in each directory that is listed.

  2. It sets the language environment and the terminal coding system,
     if requested by environment variables such as `LANG'.

  3. It loads the initialization library for the window system, if you
     are using a window system.  This library's name is
     `term/WINDOWSYSTEM-win.el'.

  4. It processes the initial options.  (Some of them are handled even
     earlier than this.)

  5. It initializes the window frame and faces, if appropriate.

  6. It runs the normal hook `before-init-hook'.

  7. It loads the library `site-start', unless the option
     `-no-site-file' was specified.  The library's file name is usually
     `site-start.el'.

  8. It loads the file `~/.emacs', unless `-q' or `-batch' was
     specified on the command line.  The `-u' option can specify another
     user name whose home directory should be used instead of `~'.

  9. It loads the library `default', unless `inhibit-default-init' is
     non-`nil'.  (This is not done in `-batch' mode or if `-q' was
     specified on the command line.)  The library's file name is
     usually `default.el'.

 10. It runs the normal hook `after-init-hook'.

 11. It sets the major mode according to `initial-major-mode', provided
     the buffer `*scratch*' is still current and still in Fundamental
     mode.

 12. It loads the terminal-specific Lisp file, if any, except when in
     batch mode or using a window system.

 13. It displays the initial echo area message, unless you have
     suppressed that with `inhibit-startup-echo-area-message'.

 14. It processes the action arguments from the command line.

 15. It runs `term-setup-hook'.

 16. It calls `frame-notice-user-settings', which modifies the
     parameters of the selected frame according to whatever the init
     files specify.

 17. It runs `window-setup-hook'.  *Note Window Systems::.

 18. It displays copyleft, nonwarranty, and basic use information,
     provided there were no remaining command line arguments (a few
     steps above), the value of `inhibit-startup-message' is `nil', and
     the buffer is still empty.

 - User Option: inhibit-startup-message
     This variable inhibits the initial startup messages (the
     nonwarranty, etc.).  If it is non-`nil', then the messages are not
     printed.

     This variable exists so you can set it in your personal init file,
     once you are familiar with the contents of the startup message.
     Do not set this variable in the init file of a new user, or in a
     way that affects more than one user, because that would prevent
     new users from receiving the information they are supposed to see.

 - User Option: inhibit-startup-echo-area-message
     This variable controls the display of the startup echo area
     message.  You can suppress the startup echo area message by adding
     text with this form to your `.emacs' file:

          (setq inhibit-startup-echo-area-message
                "YOUR-LOGIN-NAME")

     Emacs explicitly checks for an expression as shown above in your
     `.emacs' file; your login name must appear in the expression as a
     Lisp string constant.  Other methods of setting
     `inhibit-startup-echo-area-message' to the same value do not
     inhibit the startup message.

     This way, you can easily inhibit the message for yourself if you
     wish, but thoughtless copying of your `.emacs' file will not
     inhibit the message for someone else.


File: elisp,  Node: Init File,  Next: Terminal-Specific,  Prev: Start-up Summary,  Up: Starting Up

The Init File: `.emacs'
-----------------------

   When you start Emacs, it normally attempts to load the file `.emacs'
from your home directory.  This file, if it exists, must contain Lisp
code.  It is called your "init file".  The command line switches `-q'
and `-u' affect the use of the init file; `-q' says not to load an init
file, and `-u' says to load a specified user's init file instead of
yours.  *Note Entering Emacs: (emacs)Entering Emacs.

   A site may have a "default init file", which is the library named
`default.el'.  Emacs finds the `default.el' file through the standard
search path for libraries (*note How Programs Do Loading::.).  The
Emacs distribution does not come with this file; sites may provide one
for local customizations.  If the default init file exists, it is
loaded whenever you start Emacs, except in batch mode or if `-q' is
specified.  But your own personal init file, if any, is loaded first; if
it sets `inhibit-default-init' to a non-`nil' value, then Emacs does
not subsequently load the `default.el' file.

   Another file for site-customization is `site-start.el'.  Emacs loads
this *before* the user's init file.  You can inhibit the loading of
this file with the option `-no-site-file'.

 - Variable: site-run-file
     This variable specifies the site-customization file to load before
     the user's init file.  Its normal value is `"site-start"'.  The
     only way you can change it with real effect is to do so before
     dumping Emacs.

   If there is a great deal of code in your `.emacs' file, you should
move it into another file named `SOMETHING.el', byte-compile it (*note
Byte Compilation::.), and make your `.emacs' file load the other file
using `load' (*note Loading::.).

   *Note Init File Examples: (emacs)Init File Examples, for examples of
how to make various commonly desired customizations in your `.emacs'
file.

 - User Option: inhibit-default-init
     This variable prevents Emacs from loading the default
     initialization library file for your session of Emacs.  If its
     value is non-`nil', then the default library is not loaded.  The
     default value is `nil'.

 - Variable: before-init-hook
     This normal hook is run, once, just before loading all the init
     files (the user's init file, `default.el', and/or `site-start.el').
     (The only way to change it with real effect is before dumping
     Emacs.)

 - Variable: after-init-hook
     This normal hook is run, once, just after loading all the init
     files (the user's init file, `default.el', and/or `site-start.el'),
     before the terminal-specific initialization.


File: elisp,  Node: Terminal-Specific,  Next: Command Line Arguments,  Prev: Init File,  Up: Starting Up

Terminal-Specific Initialization
--------------------------------

   Each terminal type can have its own Lisp library that Emacs loads
when run on that type of terminal.  The library's name is constructed by
concatenating the value of the variable `term-file-prefix' and the
terminal type.  Normally, `term-file-prefix' has the value `"term/"';
changing this is not recommended.  Emacs finds the file in the normal
manner, by searching the `load-path' directories, and trying the `.elc'
and `.el' suffixes.

   The usual function of a terminal-specific library is to enable
special keys to send sequences that Emacs can recognize.  It may also
need to set or add to `function-key-map' if the Termcap entry does not
specify all the terminal's function keys.  *Note Terminal Input::.

   When the name of the terminal type contains a hyphen, only the part
of the name before the first hyphen is significant in choosing the
library name.  Thus, terminal types `aaa-48' and `aaa-30-rv' both use
the `term/aaa' library.  If necessary, the library can evaluate
`(getenv "TERM")' to find the full name of the terminal type.

   Your `.emacs' file can prevent the loading of the terminal-specific
library by setting the variable `term-file-prefix' to `nil'.  This
feature is useful when experimenting with your own peculiar
customizations.

   You can also arrange to override some of the actions of the
terminal-specific library by setting the variable `term-setup-hook'.
This is a normal hook which Emacs runs using `run-hooks' at the end of
Emacs initialization, after loading both your `.emacs' file and any
terminal-specific libraries.  You can use this variable to define
initializations for terminals that do not have their own libraries.
*Note Hooks::.

 - Variable: term-file-prefix
     If the `term-file-prefix' variable is non-`nil', Emacs loads a
     terminal-specific initialization file as follows:

          (load (concat term-file-prefix (getenv "TERM")))

     You may set the `term-file-prefix' variable to `nil' in your
     `.emacs' file if you do not wish to load the
     terminal-initialization file.  To do this, put the following in
     your `.emacs' file: `(setq term-file-prefix nil)'.

 - Variable: term-setup-hook
     This variable is a normal hook that Emacs runs after loading your
     `.emacs' file, the default initialization file (if any) and the
     terminal-specific Lisp file.

     You can use `term-setup-hook' to override the definitions made by a
     terminal-specific file.

   See `window-setup-hook' in *Note Window Systems::, for a related
feature.


File: elisp,  Node: Command Line Arguments,  Prev: Terminal-Specific,  Up: Starting Up

Command Line Arguments
----------------------

   You can use command line arguments to request various actions when
you start Emacs.  Since you do not need to start Emacs more than once
per day, and will often leave your Emacs session running longer than
that, command line arguments are hardly ever used.  As a practical
matter, it is best to avoid making the habit of using them, since this
habit would encourage you to kill and restart Emacs unnecessarily
often.  These options exist for two reasons: to be compatible with
other editors (for invocation by other programs) and to enable shell
scripts to run specific Lisp programs.

   This section describes how Emacs processes command line arguments,
and how you can customize them.

 - Function: command-line
     This function parses the command line that Emacs was called with,
     processes it, loads the user's `.emacs' file and displays the
     startup messages.

 - Variable: command-line-processed
     The value of this variable is `t' once the command line has been
     processed.

     If you redump Emacs by calling `dump-emacs', you may wish to set
     this variable to `nil' first in order to cause the new dumped Emacs
     to process its new command line arguments.

 - Variable: command-switch-alist
     The value of this variable is an alist of user-defined command-line
     options and associated handler functions.  This variable exists so
     you can add elements to it.

     A "command line option" is an argument on the command line of the
     form:

          -OPTION

     The elements of the `command-switch-alist' look like this:

          (OPTION . HANDLER-FUNCTION)

     The HANDLER-FUNCTION is called to handle OPTION and receives the
     option name as its sole argument.

     In some cases, the option is followed in the command line by an
     argument.  In these cases, the HANDLER-FUNCTION can find all the
     remaining command-line arguments in the variable
     `command-line-args-left'.  (The entire list of command-line
     arguments is in `command-line-args'.)

     The command line arguments are parsed by the `command-line-1'
     function in the `startup.el' file.  See also *Note Command Line
     Switches and Arguments: (emacs)Command Switches.

 - Variable: command-line-args
     The value of this variable is the list of command line arguments
     passed to Emacs.

 - Variable: command-line-functions
     This variable's value is a list of functions for handling an
     unrecognized command-line argument.  Each time the next argument
     to be processed has no special meaning, the functions in this list
     are called, in order of appearance, until one of them returns a
     non-`nil' value.

     These functions are called with no arguments.  They can access the
     command-line argument under consideration through the variable
     `argi', which is bound temporarily at this point.  The remaining
     arguments (not including the current one) are in the variable
     `command-line-args-left'.

     When a function recognizes and processes the argument in `argi', it
     should return a non-`nil' value to say it has dealt with that
     argument.  If it has also dealt with some of the following
     arguments, it can indicate that by deleting them from
     `command-line-args-left'.

     If all of these functions return `nil', then the argument is used
     as a file name to visit.


File: elisp,  Node: Getting Out,  Next: System Environment,  Prev: Starting Up,  Up: System Interface

Getting Out of Emacs
====================

   There are two ways to get out of Emacs: you can kill the Emacs job,
which exits permanently, or you can suspend it, which permits you to
reenter the Emacs process later.  As a practical matter, you seldom kill
Emacs--only when you are about to log out.  Suspending is much more
common.

* Menu:

* Killing Emacs::        Exiting Emacs irreversibly.
* Suspending Emacs::     Exiting Emacs reversibly.


File: elisp,  Node: Killing Emacs,  Next: Suspending Emacs,  Up: Getting Out

Killing Emacs
-------------

   Killing Emacs means ending the execution of the Emacs process.  The
parent process normally resumes control.  The low-level primitive for
killing Emacs is `kill-emacs'.

 - Function: kill-emacs &optional EXIT-DATA
     This function exits the Emacs process and kills it.

     If EXIT-DATA is an integer, then it is used as the exit status of
     the Emacs process.  (This is useful primarily in batch operation;
     see *Note Batch Mode::.)

     If EXIT-DATA is a string, its contents are stuffed into the
     terminal input buffer so that the shell (or whatever program next
     reads input) can read them.

   All the information in the Emacs process, aside from files that have
been saved, is lost when the Emacs is killed.  Because killing Emacs
inadvertently can lose a lot of work, Emacs queries for confirmation
before actually terminating if you have buffers that need saving or
subprocesses that are running.  This is done in the function
`save-buffers-kill-emacs'.

 - Variable: kill-emacs-query-functions
     After asking the standard questions, `save-buffers-kill-emacs'
     calls the functions in the list `kill-emacs-query-functions', in
     order of appearance, with no arguments.  These functions can ask
     for additional confirmation from the user.  If any of them returns
     `nil', Emacs is not killed.

 - Variable: kill-emacs-hook
     This variable is a normal hook; once `save-buffers-kill-emacs' is
     finished with all file saving and confirmation, it runs the
     functions in this hook.

