This is ../info/lispref.info, produced by makeinfo version 4.3 from
lispref/lispref.texi.

INFO-DIR-SECTION XEmacs Editor
START-INFO-DIR-ENTRY
* Lispref: (lispref).		XEmacs Lisp Reference Manual.
END-INFO-DIR-ENTRY

   Edition History:

   GNU Emacs Lisp Reference Manual Second Edition (v2.01), May 1993 GNU
Emacs Lisp Reference Manual Further Revised (v2.02), August 1993 Lucid
Emacs Lisp Reference Manual (for 19.10) First Edition, March 1994
XEmacs Lisp Programmer's Manual (for 19.12) Second Edition, April 1995
GNU Emacs Lisp Reference Manual v2.4, June 1995 XEmacs Lisp
Programmer's Manual (for 19.13) Third Edition, July 1995 XEmacs Lisp
Reference Manual (for 19.14 and 20.0) v3.1, March 1996 XEmacs Lisp
Reference Manual (for 19.15 and 20.1, 20.2, 20.3) v3.2, April, May,
November 1997 XEmacs Lisp Reference Manual (for 21.0) v3.3, April 1998

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995 Free Software
Foundation, Inc.  Copyright (C) 1994, 1995 Sun Microsystems, Inc.
Copyright (C) 1995, 1996 Ben Wing.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: lispref.info,  Node: Edebug,  Prev: Compilation Errors,  Up: Top

Edebug
======

   Edebug is a source-level debugger for XEmacs Lisp programs that
provides the following features:

   * Step through evaluation, stopping before and after each expression.

   * Set conditional or unconditional breakpoints, install embedded
     breakpoints, or a global break event.

   * Trace slow or fast stopping briefly at each stop point, or each
     breakpoint.

   * Display expression results and evaluate expressions as if outside
     of Edebug.  Interface with the custom printing package for
     printing circular structures.

   * Automatically reevaluate a list of expressions and display their
     results each time Edebug updates the display.

   * Output trace info on function enter and exit.

   * Errors stop before the source causing the error.

   * Display backtrace without Edebug calls.

   * Allow specification of argument evaluation for macros and defining
     forms.

   * Provide rudimentary coverage testing and display of frequency
     counts.


   The first three sections should tell you enough about Edebug to
enable you to use it.

* Menu:

* Using Edebug::		Introduction to use of Edebug.
* Instrumenting::		You must first instrument code.
* Edebug Execution Modes::	Execution modes, stopping more or less often.
* Jumping::			Commands to jump to a specified place.
* Edebug Misc::			Miscellaneous commands.
* Breakpoints::			Setting breakpoints to make the program stop.
* Trapping Errors::		trapping errors with Edebug.
* Edebug Views::		Views inside and outside of Edebug.
* Edebug Eval::			Evaluating expressions within Edebug.
* Eval List::			Automatic expression evaluation.
* Reading in Edebug::		Customization of reading.
* Printing in Edebug::		Customization of printing.
* Tracing::			How to produce tracing output.
* Coverage Testing::		How to test evaluation coverage.
* The Outside Context::		Data that Edebug saves and restores.
* Instrumenting Macro Calls::	Specifying how to handle macro calls.
* Edebug Options::		Option variables for customizing Edebug.


File: lispref.info,  Node: Using Edebug,  Next: Instrumenting,  Up: Edebug

Using Edebug
------------

   To debug an XEmacs Lisp program with Edebug, you must first
"instrument" the Lisp code that you want to debug.  If you want to just
try it now, load `edebug.el', move point into a definition and do `C-u
C-M-x' (`eval-defun' with a prefix argument).  See *Note
Instrumenting:: for alternative ways to instrument code.

   Once a function is instrumented, any call to the function activates
Edebug.  Activating Edebug may stop execution and let you step through
the function, or it may update the display and continue execution while
checking for debugging commands, depending on the selected Edebug
execution mode.  The initial execution mode is `step', by default,
which does stop execution.  *Note Edebug Execution Modes::.

   Within Edebug, you normally view an XEmacs buffer showing the source
of the Lisp function you are debugging.  This is referred to as the
"source code buffer"--but note that it is not always the same buffer
depending on which function is currently being executed.

   An arrow at the left margin indicates the line where the function is
executing.  Point initially shows where within the line the function is
executing, but you can move point yourself.

   If you instrument the definition of `fac' (shown below) and then
execute `(fac 3)', here is what you normally see.  Point is at the
open-parenthesis before `if'.

     (defun fac (n)
     =>-!-(if (< 0 n)
           (* n (fac (1- n)))
         1))

   The places within a function where Edebug can stop execution are
called "stop points".  These occur both before and after each
subexpression that is a list, and also after each variable reference.
Here we show with periods the stop points found in the function `fac':

     (defun fac (n)
       .(if .(< 0 n.).
           .(* n. .(fac (1- n.).).).
         1).)

   While the source code buffer is selected, the special commands of
Edebug are available in it, in addition to the commands of XEmacs Lisp
mode.  (The buffer is temporarily made read-only, however.)  For
example, you can type the Edebug command <SPC> to execute until the
next stop point.  If you type <SPC> once after entry to `fac', here is
the display you will see:

     (defun fac (n)
     =>(if -!-(< 0 n)
           (* n (fac (1- n)))
         1))

   When Edebug stops execution after an expression, it displays the
expression's value in the echo area.

   Other frequently used commands are `b' to set a breakpoint at a stop
point, `g' to execute until a breakpoint is reached, and `q' to exit to
the top-level command loop.  Type `?' to display a list of all Edebug
commands.


File: lispref.info,  Node: Instrumenting,  Next: Edebug Execution Modes,  Prev: Using Edebug,  Up: Edebug

Instrumenting for Edebug
------------------------

   In order to use Edebug to debug Lisp code, you must first
"instrument" the code.  Instrumenting a form inserts additional code
into it which invokes Edebug at the proper places.  Furthermore, if
Edebug detects a syntax error while instrumenting, point is left at the
erroneous code and an `invalid-read-syntax' error is signaled.

   Once you have loaded Edebug, the command `C-M-x' (`eval-defun') is
redefined so that when invoked with a prefix argument on a definition,
it instruments the definition before evaluating it.  (The source code
itself is not modified.)  If the variable `edebug-all-defs' is
non-`nil', that inverts the meaning of the prefix argument: then
`C-M-x' instruments the definition _unless_ it has a prefix argument.
The default value of `edebug-all-defs' is `nil'.  The command `M-x
edebug-all-defs' toggles the value of the variable `edebug-all-defs'.

   If `edebug-all-defs' is non-`nil', then the commands `eval-region',
`eval-current-buffer', and `eval-buffer' also instrument any
definitions they evaluate.  Similarly, `edebug-all-forms' controls
whether `eval-region' should instrument _any_ form, even non-defining
forms.  This doesn't apply to loading or evaluations in the minibuffer.
The command `M-x edebug-all-forms' toggles this option.

   Another command, `M-x edebug-eval-top-level-form', is available to
instrument any top-level form regardless of the value of
`edebug-all-defs' or `edebug-all-forms'.

   Just before Edebug instruments any code, it calls any functions in
the variable `edebug-setup-hook' and resets its value to `nil'.  You
could use this to load up Edebug specifications associated with a
package you are using but only when you also use Edebug.  For example,
`my-specs.el' may be loaded automatically when you use `my-package'
with Edebug by including the following code in `my-package.el'.

     (add-hook 'edebug-setup-hook
       (function (lambda () (require 'my-specs))))

   While Edebug is active, the command `I' (`edebug-instrument-callee')
instruments the definition of the function or macro called by the list
form after point, if is not already instrumented.  If the location of
the definition is not known to Edebug, this command cannot be used.
After loading Edebug, `eval-region' records the position of every
definition it evaluates, even if not instrumenting it.  Also see the
command `i' (*Note Jumping::) which steps into the callee.

   Edebug knows how to instrument all the standard special forms, an
interactive form with an expression argument, anonymous lambda
expressions, and other defining forms.  (Specifications for macros
defined by `cl.el' (version 2.03) are provided in `cl-specs.el'.)
Edebug cannot know what a user-defined macro will do with the arguments
of a macro call so you must tell it.  See *Note Instrumenting Macro
Calls:: for the details.

   Note that a couple ways remain to evaluate expressions without
instrumenting them.  Loading a file via the `load' subroutine does not
instrument expressions for Edebug.  Evaluations in the minibuffer via
`eval-expression' (`M-ESC') are not instrumented.

   To remove instrumentation from a definition, simply reevaluate it
with one of the non-instrumenting commands, or reload the file.

   See *Note Edebug Eval:: for other evaluation functions available
inside of Edebug.


File: lispref.info,  Node: Edebug Execution Modes,  Next: Jumping,  Prev: Instrumenting,  Up: Edebug

Edebug Execution Modes
----------------------

   Edebug supports several execution modes for running the program you
are debugging.  We call these alternatives "Edebug execution modes"; do
not confuse them with major or minor modes.  The current Edebug
execution mode determines how Edebug displays the progress of the
evaluation, whether it stops at each stop point, or continues to the
next breakpoint, for example.

   Normally, you specify the Edebug execution mode by typing a command
to continue the program in a certain mode.  Here is a table of these
commands.  All except for `S' resume execution of the program, at least
for a certain distance.

`S'
     Stop: don't execute any more of the program for now, just wait for
     more Edebug commands (`edebug-stop').

`<SPC>'
     Step: stop at the next stop point encountered (`edebug-step-mode').

`n'
     Next: stop at the next stop point encountered after an expression
     (`edebug-next-mode').  Also see `edebug-forward-sexp' in *Note
     Edebug Misc::.

`t'
     Trace: pause one second at each Edebug stop point
     (`edebug-trace-mode').

`T'
     Rapid trace: update at each stop point, but don't actually pause
     (`edebug-Trace-fast-mode').

`g'
     Go: run until the next breakpoint (`edebug-go-mode').  *Note
     Breakpoints::.

`c'
     Continue: pause for one second at each breakpoint, but don't stop
     (`edebug-continue-mode').

`C'
     Rapid continue: update at each breakpoint, but don't actually pause
     (`edebug-Continue-fast-mode').

`G'
     Go non-stop: ignore breakpoints (`edebug-Go-nonstop-mode').  You
     can still stop the program by hitting any key.

   In general, the execution modes earlier in the above list run the
program more slowly or stop sooner.

   When you enter a new Edebug level, the initial execution mode comes
from the value of the variable `edebug-initial-mode'.  By default, this
specifies `step' mode.  Note that you may reenter the same Edebug level
several times if, for example, an instrumented function is called
several times from one command.

   While executing or tracing, you can interrupt the execution by typing
any Edebug command.  Edebug stops the program at the next stop point and
then executes the command that you typed.  For example, typing `t'
during execution switches to trace mode at the next stop point.  You can
use `S' to stop execution without doing anything else.

   If your function happens to read input, a character you hit
intending to interrupt execution may be read by the function instead.
You can avoid such unintended results by paying attention to when your
program wants input.

   Keyboard macros containing Edebug commands do not work; when you exit
from Edebug, to resume the program, whether you are defining or
executing a keyboard macro is forgotten.  Also, defining or executing a
keyboard macro outside of Edebug does not affect the command loop inside
Edebug.  This is usually an advantage.  But see
`edebug-continue-kbd-macro'.


File: lispref.info,  Node: Jumping,  Next: Edebug Misc,  Prev: Edebug Execution Modes,  Up: Edebug

Jumping
-------

   Commands described here let you jump to a specified location.  All,
except `i', use temporary breakpoints to establish the stop point and
then switch to `go' mode.  Any other breakpoint reached before the
intended stop point will also stop execution.  See *Note Breakpoints::
for the details on breakpoints.

`f'
     Run the program forward over one expression
     (`edebug-forward-sexp').  More precisely, set a temporary
     breakpoint at the position that `C-M-f' would reach, then execute
     in `go' mode so that the program will stop at breakpoints.

     With a prefix argument N, the temporary breakpoint is placed N
     sexps beyond point.  If the containing list ends before N more
     elements, then the place to stop is after the containing
     expression.

     Be careful that the position `C-M-f' finds is a place that the
     program will really get to; this may not be true in a `cond', for
     example.

     This command does `forward-sexp' starting at point rather than the
     stop point.  If you want to execute one expression from the
     current stop point, type `w' first, to move point there.

`o'
     Continue "out of" an expression (`edebug-step-out').  It places a
     temporary breakpoint at the end of the sexp containing point.

     If the containing sexp is a function definition itself, it
     continues until just before the last sexp in the definition.  If
     that is where you are now, it returns from the function and then
     stops.  In other words, this command does not exit the currently
     executing function unless you are positioned after the last sexp.

`I'
     Step into the function or macro after point after first ensuring
     that it is instrumented.  It does this by calling
     `edebug-on-entry' and then switching to `go' mode.

     Although the automatic instrumentation is convenient, it is not
     later automatically uninstrumented.

`h'
     Proceed to the stop point near where point is using a temporary
     breakpoint (`edebug-goto-here').

   All the commands in this section may fail to work as expected in case
of nonlocal exit, because a nonlocal exit can bypass the temporary
breakpoint where you expected the program to stop.


File: lispref.info,  Node: Edebug Misc,  Next: Breakpoints,  Prev: Jumping,  Up: Edebug

Miscellaneous
-------------

   Some miscellaneous commands are described here.

`?'
     Display the help message for Edebug (`edebug-help').

`C-]'
     Abort one level back to the previous command level
     (`abort-recursive-edit').

`q'
     Return to the top level editor command loop (`top-level').  This
     exits all recursive editing levels, including all levels of Edebug
     activity.  However, instrumented code protected with
     `unwind-protect' or `condition-case' forms may resume debugging.

`Q'
     Like `q' but don't stop even for protected code
     (`top-level-nonstop').

`r'
     Redisplay the most recently known expression result in the echo
     area (`edebug-previous-result').

`d'
     Display a backtrace, excluding Edebug's own functions for clarity
     (`edebug-backtrace').

     You cannot use debugger commands in the backtrace buffer in Edebug
     as you would in the standard debugger.

     The backtrace buffer is killed automatically when you continue
     execution.

   From the Edebug recursive edit, you may invoke commands that activate
Edebug again recursively.  Any time Edebug is active, you can quit to
the top level with `q' or abort one recursive edit level with `C-]'.
You can display a backtrace of all the pending evaluations with `d'.


File: lispref.info,  Node: Breakpoints,  Next: Trapping Errors,  Prev: Edebug Misc,  Up: Edebug

Breakpoints
-----------

   There are three more ways to stop execution once it has started:
breakpoints, the global break condition, and embedded breakpoints.

   While using Edebug, you can specify "breakpoints" in the program you
are testing: points where execution should stop.  You can set a
breakpoint at any stop point, as defined in *Note Using Edebug::.  For
setting and unsetting breakpoints, the stop point that is affected is
the first one at or after point in the source code buffer.  Here are the
Edebug commands for breakpoints:

`b'
     Set a breakpoint at the stop point at or after point
     (`edebug-set-breakpoint').  If you use a prefix argument, the
     breakpoint is temporary (it turns off the first time it stops the
     program).

`u'
     Unset the breakpoint (if any) at the stop point at or after the
     current point (`edebug-unset-breakpoint').

`x CONDITION <RET>'
     Set a conditional breakpoint which stops the program only if
     CONDITION evaluates to a non-`nil' value
     (`edebug-set-conditional-breakpoint').  If you use a prefix
     argument, the breakpoint is temporary (it turns off the first time
     it stops the program).

`B'
     Move point to the next breakpoint in the definition
     (`edebug-next-breakpoint').

   While in Edebug, you can set a breakpoint with `b' and unset one
with `u'.  First you must move point to a position at or before the
desired Edebug stop point, then hit the key to change the breakpoint.
Unsetting a breakpoint that has not been set does nothing.

   Reevaluating or reinstrumenting a definition clears all its
breakpoints.

   A "conditional breakpoint" tests a condition each time the program
gets there.  To set a conditional breakpoint, use `x', and specify the
condition expression in the minibuffer.  Setting a conditional
breakpoint at a stop point that already has a conditional breakpoint
puts the current condition expression in the minibuffer so you can edit
it.

   You can make both conditional and unconditional breakpoints
"temporary" by using a prefix arg to the command to set the breakpoint.
After breaking at a temporary breakpoint, it is automatically cleared.

   Edebug always stops or pauses at a breakpoint except when the Edebug
mode is `Go-nonstop'.  In that mode, it ignores breakpoints entirely.

   To find out where your breakpoints are, use `B', which moves point
to the next breakpoint in the definition following point, or to the
first breakpoint if there are no following breakpoints.  This command
does not continue execution--it just moves point in the buffer.

* Menu:

* Global Break Condition::	Breaking on an event.
* Embedded Breakpoints::	Embedding breakpoints in code.


File: lispref.info,  Node: Global Break Condition,  Next: Embedded Breakpoints,  Up: Breakpoints

Global Break Condition
......................

   In contrast to breaking when execution reaches specified locations,
you can also cause a break when a certain event occurs.  The "global
break condition" is a condition that is repeatedly evaluated at every
stop point.  If it evaluates to a non-`nil' value, then execution is
stopped or paused depending on the execution mode, just like a
breakpoint.  Any errors that might occur as a result of evaluating the
condition are ignored, as if the result were `nil'.

   You can set or edit the condition expression, stored in
`edebug-global-break-condition', using `X'
(`edebug-set-global-break-condition').

   Using the global break condition is perhaps the fastest way to find
where in your code some event occurs, but since it is rather expensive
you should reset the condition to `nil' when not in use.


File: lispref.info,  Node: Embedded Breakpoints,  Prev: Global Break Condition,  Up: Breakpoints

Embedded Breakpoints
....................

   Since all breakpoints in a definition are cleared each time you
reinstrument it, you might rather create an "embedded breakpoint" which
is simply a call to the function `edebug'.  You can, of course, make
such a call conditional.  For example, in the `fac' function, insert
the first line as shown below to stop when the argument reaches zero:

     (defun fac (n)
       (if (= n 0) (edebug))
       (if (< 0 n)
           (* n (fac (1- n)))
         1))

   When the `fac' definition is instrumented and the function is
called, Edebug will stop before the call to `edebug'.  Depending on the
execution mode, Edebug will stop or pause.

   However, if no instrumented code is being executed, calling `edebug'
will instead invoke `debug'.  Calling `debug' will always invoke the
standard backtrace debugger.


File: lispref.info,  Node: Trapping Errors,  Next: Edebug Views,  Prev: Breakpoints,  Up: Edebug

Trapping Errors
---------------

   An error may be signaled by subroutines or XEmacs Lisp code.  If a
signal is not handled by a `condition-case', this indicates an
unrecognized situation has occurred.  If Edebug is not active when an
unhandled error is signaled, `debug' is run normally (if
`debug-on-error' is non-`nil').  But while Edebug is active,
`debug-on-error' and `debug-on-quit' are bound to `edebug-on-error' and
`edebug-on-quit', which are both `t' by default.  Actually, if
`debug-on-error' already has a non-`nil' value, that value is still
used.

   It is best to change the values of `edebug-on-error' or
`edebug-on-quit' when Edebug is not active since their values won't be
used until the next time Edebug is invoked at a deeper command level.
If you only change `debug-on-error' or `debug-on-quit' while Edebug is
active, these changes will be forgotten when Edebug becomes inactive.
Furthermore, during Edebug's recursive edit, these variables are bound
to the values they had outside of Edebug.

   Edebug shows you the last stop point that it knew about before the
error was signaled.  This may be the location of a call to a function
which was not instrumented, within which the error actually occurred.
For an unbound variable error, the last known stop point might be quite
distant from the offending variable.  If the cause of the error is not
obvious at first, note that you can also get a full backtrace inside of
Edebug (see *Note Edebug Misc::).

   Edebug can also trap signals even if they are handled.  If
`debug-on-error' is a list of signal names, Edebug will stop when any
of these errors are signaled.  Edebug shows you the last known stop
point just as for unhandled errors.  After you continue execution, the
error is signaled again (but without being caught by Edebug).  Edebug
can only trap errors that are handled if they are signaled in Lisp code
(not subroutines) since it does so by temporarily replacing the
`signal' function.


File: lispref.info,  Node: Edebug Views,  Next: Edebug Eval,  Prev: Trapping Errors,  Up: Edebug

Edebug Views
------------

   The following Edebug commands let you view aspects of the buffer and
window status that obtained before entry to Edebug.

`v'
     View the outside window configuration (`edebug-view-outside').

`p'
     Temporarily display the outside current buffer with point at its
     outside position (`edebug-bounce-point'). If prefix arg is
     supplied, sit for that many seconds instead.

`w'
     Move point back to the current stop point (`edebug-where') in the
     source code buffer.  Also, if you use this command in another
     window displaying the same buffer, this window will be used
     instead to display the buffer in the future.

`W'
     Toggle the `edebug-save-windows' variable which indicates whether
     the outside window configuration is saved and restored
     (`edebug-toggle-save-windows').  Also, each time it is toggled on,
     make the outside window configuration the same as the current
     window configuration.

     With a prefix argument, `edebug-toggle-save-windows' only toggles
     saving and restoring of the selected window.  To specify a window
     that is not displaying the source code buffer, you must use
     `C-xXW' from the global keymap.

   You can view the outside window configuration with `v' or just
bounce to the current point in the current buffer with `p', even if it
is not normally displayed.  After moving point, you may wish to pop
back to the stop point with `w' from a source code buffer.

   By using `W' twice, Edebug again saves and restores the outside
window configuration, but to the current configuration.  This is a
convenient way to, for example, add another buffer to be displayed
whenever Edebug is active.  However, the automatic redisplay of
`*edebug*' and `*edebug-trace*' may conflict with the buffers you wish
to see unless you have enough windows open.


File: lispref.info,  Node: Edebug Eval,  Next: Eval List,  Prev: Edebug Views,  Up: Edebug

Evaluation
----------

   While within Edebug, you can evaluate expressions "as if" Edebug were
not running.  Edebug tries to be invisible to the expression's
evaluation and printing.  Evaluation of expressions that cause side
effects will work as expected except for things that Edebug explicitly
saves and restores.  See *Note The Outside Context:: for details on this
process.  Also see *Note Reading in Edebug:: and *Note Printing in
Edebug:: for topics related to evaluation.

`e EXP <RET>'
     Evaluate expression EXP in the context outside of Edebug
     (`edebug-eval-expression').  In other words, Edebug tries to avoid
     altering the effect of EXP.

`M-<ESC> EXP <RET>'
     Evaluate expression EXP in the context of Edebug itself.

`C-x C-e'
     Evaluate the expression before point, in the context outside of
     Edebug (`edebug-eval-last-sexp').

   Edebug supports evaluation of expressions containing references to
lexically bound symbols created by the following constructs in `cl.el'
(version 2.03 or later): `lexical-let', `macrolet', and
`symbol-macrolet'.


File: lispref.info,  Node: Eval List,  Next: Reading in Edebug,  Prev: Edebug Eval,  Up: Edebug

Evaluation List Buffer
----------------------

   You can use the "evaluation list buffer", called `*edebug*', to
evaluate expressions interactively.  You can also set up the
"evaluation list" of expressions to be evaluated automatically each
time Edebug updates the display.

`E'
     Switch to the evaluation list buffer `*edebug*'
     (`edebug-visit-eval-list').

   In the `*edebug*' buffer you can use the commands of Lisp
Interaction as well as these special commands:

`LFD'
     Evaluate the expression before point, in the outside context, and
     insert the value in the buffer (`edebug-eval-print-last-sexp').

`C-x C-e'
     Evaluate the expression before point, in the context outside of
     Edebug (`edebug-eval-last-sexp').

`C-c C-u'
     Build a new evaluation list from the first expression of each
     group, reevaluate and redisplay (`edebug-update-eval-list').
     Groups are separated by comment lines.

`C-c C-d'
     Delete the evaluation list group that point is in
     (`edebug-delete-eval-item').

`C-c C-w'
     Switch back to the source code buffer at the current stop point
     (`edebug-where').

   You can evaluate expressions in the evaluation list window with
`LFD' or `C-x C-e', just as you would in `*scratch*'; but they are
evaluated in the context outside of Edebug.

   The expressions you enter interactively (and their results) are lost
when you continue execution unless you add them to the evaluation list
with `C-c C-u'.  This command builds a new list from the first
expression of each "evaluation list group".  Groups are separated by
comment lines.  Be careful not to add expressions that execute
instrumented code otherwise an infinite loop will result.

   When the evaluation list is redisplayed, each expression is displayed
followed by the result of evaluating it, and a comment line.  If an
error occurs during an evaluation, the error message is displayed in a
string as if it were the result.  Therefore expressions that, for
example, use variables not currently valid do not interrupt your
debugging.

   Here is an example of what the evaluation list window looks like
after several expressions have been added to it:

     (current-buffer)
     #<buffer *scratch*>
     ;---------------------------------------------------------------
     (selected-window)
     #<window 16 on *scratch*>
     ;---------------------------------------------------------------
     (point)
     196
     ;---------------------------------------------------------------
     bad-var
     "Symbol's value as variable is void: bad-var"
     ;---------------------------------------------------------------
     (recursion-depth)
     0
     ;---------------------------------------------------------------
     this-command
     eval-last-sexp
     ;---------------------------------------------------------------

   To delete a group, move point into it and type `C-c C-d', or simply
delete the text for the group and update the evaluation list with `C-c
C-u'.  When you add a new group, be sure it is separated from its
neighbors by a comment line.

   After selecting `*edebug*', you can return to the source code buffer
with `C-c C-w'.  The `*edebug*' buffer is killed when you continue
execution, and recreated next time it is needed.


File: lispref.info,  Node: Reading in Edebug,  Next: Printing in Edebug,  Prev: Eval List,  Up: Edebug

Reading in Edebug
-----------------

   To instrument a form, Edebug first reads the whole form.  Edebug
replaces the standard Lisp Reader with its own reader that remembers the
positions of expressions.  This reader is used by the Edebug
replacements for `eval-region', `eval-defun', `eval-buffer', and
`eval-current-buffer'.

   Another package, `cl-read.el', replaces the standard reader with one
that understands Common Lisp reader macros.  If you use that package,
Edebug will automatically load `edebug-cl-read.el' to provide
corresponding reader macros that remember positions of expressions.  If
you define new reader macros, you will have to define similar reader
macros for Edebug.


File: lispref.info,  Node: Printing in Edebug,  Next: Tracing,  Prev: Reading in Edebug,  Up: Edebug

Printing in Edebug
------------------

   If the result of an expression in your program contains a circular
reference, you may get an error when Edebug attempts to print it.  You
can set `print-length' to a non-zero value to limit the print length of
lists (the number of cdrs), and in Emacs 19, set `print-level' to a
non-zero value to limit the print depth of lists.  But you can print
such circular structures and structures that share elements more
informatively by using the `cust-print' package.

   To load `cust-print' and activate custom printing only for Edebug,
simply use the command `M-x edebug-install-custom-print'.  To restore
the standard print functions, use `M-x edebug-uninstall-custom-print'.
You can also activate custom printing for printing in any Lisp code;
see the package for details.

   Here is an example of code that creates a circular structure:

     (progn
       (edebug-install-custom-print)
       (setq a '(x y))
       (setcar a a))

   Edebug will print the result of the `setcar' as `Result: #1=(#1#
y)'.  The `#1=' notation names the structure that follows it, and the
`#1#' notation references the previously named structure.  This
notation is used for any shared elements of lists or vectors.

   Independent of whether `cust-print' is active, while printing
results Edebug binds `print-length', `print-level', and `print-circle'
to `edebug-print-length' (`50'), `edebug-print-level' (`50'), and
`edebug-print-circle' (`t') respectively, if these values are
non-`nil'.  Also, `print-readably' is bound to `nil' since some objects
simply cannot be printed readably.


File: lispref.info,  Node: Tracing,  Next: Coverage Testing,  Prev: Printing in Edebug,  Up: Edebug

Tracing
-------

   In addition to automatic stepping through source code, which is also
called _tracing_ (see *Note Edebug Execution Modes::), Edebug can
produce a traditional trace listing of execution in a separate buffer,
`*edebug-trace*'.

   If the variable `edebug-trace' is non-`nil', each function entry and
exit adds lines to the trace buffer.  On function entry, Edebug prints
`::::{' followed by the function name and argument values.  On function
exit, Edebug prints `::::}' followed by the function name and result of
the function.  The number of `:'s is computed from the recursion depth.
The balanced braces in the trace buffer can be used to find the
matching beginning or end of function calls. These displays may be
customized by replacing the functions `edebug-print-trace-before' and
`edebug-print-trace-after', which take an arbitrary message string to
print.

   The macro `edebug-tracing' provides tracing similar to function
enter and exit tracing, but for arbitrary expressions.  This macro
should be explicitly inserted by you around expressions you wish to
trace the execution of.  The first argument is a message string
(evaluated), and the rest are expressions to evaluate.  The result of
the last expression is returned.

   Finally, you can insert arbitrary strings into the trace buffer with
explicit calls to `edebug-trace'.  The arguments of this function are
the same as for `message', but a newline is always inserted after each
string printed in this way.

   `edebug-tracing' and `edebug-trace' insert lines in the trace buffer
even if Edebug is not active.  Every time the trace buffer is added to,
the window is scrolled to show the last lines inserted.  (There may be
some display problems if you use tracing along with the evaluation
list.)


File: lispref.info,  Node: Coverage Testing,  Next: The Outside Context,  Prev: Tracing,  Up: Edebug

Coverage Testing
----------------

   Edebug provides a rudimentary coverage tester and display of
execution frequency.  Frequency counts are always accumulated, both
before and after evaluation of each instrumented expression, even if
the execution mode is `Go-nonstop'.  Coverage testing is only done if
the option `edebug-test-coverage' is non-`nil' because this is
relatively expensive.  Both data sets are displayed by `M-x
edebug-display-freq-count'.

 - Command: edebug-display-freq-count
     Display the frequency count data for each line of the current
     definition.  The frequency counts are inserted as comment lines
     after each line, and you can undo all insertions with one `undo'
     command.  The counts are inserted starting under the `(' before an
     expression or the `)' after an expression, or on the last char of
     a symbol.  The counts are only displayed when they differ from
     previous counts on the same line.

     If coverage is being tested, whenever all known results of an
     expression are `eq', the char `=' will be appended after the count
     for that expression.  Note that this is always the case for an
     expression only evaluated once.

     To clear the frequency count and coverage data for a definition,
     reinstrument it.


   For example, after evaluating `(fac 5)' with an embedded breakpoint,
and setting `edebug-test-coverage' to `t', when the breakpoint is
reached, the frequency data is looks like this:

     (defun fac (n)
       (if (= n 0) (edebug))
     ;#6           1      0 =5
       (if (< 0 n)
     ;#5         =
           (* n (fac (1- n)))
     ;#    5               0
         1))
     ;#   0

   The comment lines show that `fac' has been called 6 times.  The
first `if' statement has returned 5 times with the same result each
time, and the same is true for the condition on the second `if'.  The
recursive call of `fac' has not returned at all.


File: lispref.info,  Node: The Outside Context,  Next: Instrumenting Macro Calls,  Prev: Coverage Testing,  Up: Edebug

The Outside Context
-------------------

   Edebug tries to be transparent to the program you are debugging.  In
addition, most evaluations you do within Edebug (see *Note Edebug
Eval::) occur in the same outside context which is temporarily restored
for the evaluation.  But Edebug is not completely successful and this
section explains precisely how it fails.  Edebug operation unavoidably
alters some data in XEmacs, and this can interfere with debugging
certain programs.  Also notice that Edebug's protection against change
of outside data means that any side effects _intended_ by the user in
the course of debugging will be defeated.

* Menu:

* Checking Whether to Stop::	When Edebug decides what to do.
* Edebug Display Update::	When Edebug updates the display.
* Edebug Recursive Edit::	When Edebug stops execution.


File: lispref.info,  Node: Checking Whether to Stop,  Next: Edebug Display Update,  Up: The Outside Context

Checking Whether to Stop
........................

   Whenever Edebug is entered just to think about whether to take some
action, it needs to save and restore certain data.

   * `max-lisp-eval-depth' and `max-specpdl-size' are both incremented
     one time to reduce Edebug's impact on the stack.  You could,
     however, still run out of stack space when using Edebug.

   * The state of keyboard macro execution is saved and restored.  While
     Edebug is active, `executing-macro' is bound to
     `edebug-continue-kbd-macro'.



File: lispref.info,  Node: Edebug Display Update,  Next: Edebug Recursive Edit,  Prev: Checking Whether to Stop,  Up: The Outside Context

Edebug Display Update
.....................

   When Edebug needs to display something (e.g., in trace mode), it
saves the current window configuration from "outside" Edebug.  When you
exit Edebug (by continuing the program), it restores the previous window
configuration.

   XEmacs redisplays only when it pauses.  Usually, when you continue
execution, the program comes back into Edebug at a breakpoint or after
stepping without pausing or reading input in between.  In such cases,
XEmacs never gets a chance to redisplay the "outside" configuration.
What you see is the same window configuration as the last time Edebug
was active, with no interruption.

   Entry to Edebug for displaying something also saves and restores the
following data, but some of these are deliberately not restored if an
error or quit signal occurs.

   * Which buffer is current, and where point and mark are in the
     current buffer are saved and restored.

   * The Edebug Display Update, is saved and restored if
     `edebug-save-windows' is non-`nil'.  It is not restored on error
     or quit, but the outside selected window _is_ reselected even on
     error or quit in case a `save-excursion' is active.  If the value
     of `edebug-save-windows' is a list, only the listed windows are
     saved and restored.

     The window start and horizontal scrolling of the source code
     buffer are not restored, however, so that the display remains
     coherent.

   * The value of point in each displayed buffer is saved and restored
     if `edebug-save-displayed-buffer-points' is non-`nil'.

   * The variables `overlay-arrow-position' and `overlay-arrow-string'
     are saved and restored.  So you can safely invoke Edebug from the
     recursive edit elsewhere in the same buffer.

   * `cursor-in-echo-area' is locally bound to `nil' so that the cursor
     shows up in the window.



File: lispref.info,  Node: Edebug Recursive Edit,  Prev: Edebug Display Update,  Up: The Outside Context

Edebug Recursive Edit
.....................

   When Edebug is entered and actually reads commands from the user, it
saves (and later restores) these additional data:

   * The current match data, for whichever buffer was current.

   * `last-command', `this-command', `last-command-char',
     `last-input-char', `last-input-event', `last-command-event',
     `last-event-frame', `last-nonmenu-event', and `track-mouse' .
     Commands used within Edebug do not affect these variables outside
     of Edebug.

     The key sequence returned by `this-command-keys' is changed by
     executing commands within Edebug and there is no way to reset the
     key sequence from Lisp.

     For Emacs 18, Edebug cannot save and restore the value of
     `unread-command-char'.  Entering Edebug while this variable has a
     nontrivial value can interfere with execution of the program you
     are debugging.

   * Complex commands executed while in Edebug are added to the variable
     `command-history'.  In rare cases this can alter execution.

   * Within Edebug, the recursion depth appears one deeper than the
     recursion depth outside Edebug.  This is not true of the
     automatically updated evaluation list window.

   * `standard-output' and `standard-input' are bound to `nil' by the
     `recursive-edit', but Edebug temporarily restores them during
     evaluations.

   * The state of keyboard macro definition is saved and restored.
     While Edebug is active, `defining-kbd-macro' is bound to
     `edebug-continue-kbd-macro'.



File: lispref.info,  Node: Instrumenting Macro Calls,  Next: Edebug Options,  Prev: The Outside Context,  Up: Edebug

Instrumenting Macro Calls
-------------------------

   When Edebug instruments an expression that calls a Lisp macro, it
needs additional advice to do the job properly.  This is because there
is no way to tell which subexpressions of the macro call may be
evaluated.  (Evaluation may occur explicitly in the macro body, or when
the resulting expansion is evaluated, or any time later.)  You must
explain the format of macro call arguments by using `def-edebug-spec' to
define an "Edebug specification" for each macro.

 - Macro: def-edebug-spec macro specification
     Specify which expressions of a call to macro MACRO are forms to be
     evaluated.  For simple macros, the SPECIFICATION often looks very
     similar to the formal argument list of the macro definition, but
     specifications are much more general than macro arguments.

     The MACRO argument may actually be any symbol, not just a macro
     name.

     Unless you are using Emacs 19 or XEmacs, this macro is only defined
     in Edebug, so you may want to use the following which is
     equivalent: `(put 'MACRO 'edebug-form-spec 'SPECIFICATION)'

   Here is a simple example that defines the specification for the
`for' macro described in the XEmacs Lisp Reference Manual, followed by
an alternative, equivalent specification.

     (def-edebug-spec for
       (symbolp "from" form "to" form "do" &rest form))
     
     (def-edebug-spec for
       (symbolp ['from form] ['to form] ['do body]))

   Here is a table of the possibilities for SPECIFICATION and how each
directs processing of arguments.

*`t'
     All arguments are instrumented for evaluation.

*`0'
     None of the arguments is instrumented.

*a symbol
     The symbol must have an Edebug specification which is used instead.
     This indirection is repeated until another kind of specification is
     found.  This allows you to inherit the specification for another
     macro.

*a list
     The elements of the list describe the types of the arguments of a
     calling form.  The possible elements of a specification list are
     described in the following sections.

* Menu:

* Specification List::		How to specify complex patterns of evaluation.
* Backtracking::		What Edebug does when matching fails.
* Debugging Backquote::	Debugging Backquote
* Specification Examples::	To help understand specifications.

