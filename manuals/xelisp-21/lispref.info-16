This is ../info/lispref.info, produced by makeinfo version 4.3 from
lispref/lispref.texi.

INFO-DIR-SECTION XEmacs Editor
START-INFO-DIR-ENTRY
* Lispref: (lispref).		XEmacs Lisp Reference Manual.
END-INFO-DIR-ENTRY

   Edition History:

   GNU Emacs Lisp Reference Manual Second Edition (v2.01), May 1993 GNU
Emacs Lisp Reference Manual Further Revised (v2.02), August 1993 Lucid
Emacs Lisp Reference Manual (for 19.10) First Edition, March 1994
XEmacs Lisp Programmer's Manual (for 19.12) Second Edition, April 1995
GNU Emacs Lisp Reference Manual v2.4, June 1995 XEmacs Lisp
Programmer's Manual (for 19.13) Third Edition, July 1995 XEmacs Lisp
Reference Manual (for 19.14 and 20.0) v3.1, March 1996 XEmacs Lisp
Reference Manual (for 19.15 and 20.1, 20.2, 20.3) v3.2, April, May,
November 1997 XEmacs Lisp Reference Manual (for 21.0) v3.3, April 1998

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995 Free Software
Foundation, Inc.  Copyright (C) 1994, 1995 Sun Microsystems, Inc.
Copyright (C) 1995, 1996 Ben Wing.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: lispref.info,  Node: Specification List,  Next: Backtracking,  Up: Instrumenting Macro Calls

Specification List
..................

   A "specification list" is required for an Edebug specification if
some arguments of a macro call are evaluated while others are not.  Some
elements in a specification list match one or more arguments, but others
modify the processing of all following elements.  The latter, called
"keyword specifications", are symbols beginning with ``&'' (e.g.
`&optional').

   A specification list may contain sublists which match arguments that
are themselves lists, or it may contain vectors used for grouping.
Sublists and groups thus subdivide the specification list into a
hierarchy of levels.  Keyword specifications only apply to the
remainder of the sublist or group they are contained in and there is an
implicit grouping around a keyword specification and all following
elements in the sublist or group.

   If a specification list fails at some level, then backtracking may
be invoked to find some alternative at a higher level, or if no
alternatives remain, an error will be signaled.  See *Note
Backtracking:: for more details.

   Edebug specifications provide at least the power of regular
expression matching.  Some context-free constructs are also supported:
the matching of sublists with balanced parentheses, recursive
processing of forms, and recursion via indirect specifications.

   Each element of a specification list may be one of the following,
with the corresponding type of argument:

`sexp'
     A single unevaluated expression.

`form'
     A single evaluated expression, which is instrumented.

`place'
     A place as in the Common Lisp `setf' place argument.  It will be
     instrumented just like a form, but the macro is expected to strip
     the instrumentation.  Two functions, `edebug-unwrap' and
     `edebug-unwrap*', are provided to strip the instrumentation one
     level or recursively at all levels.

`body'
     Short for `&rest form'.  See `&rest' below.

`function-form'
     A function form: either a quoted function symbol, a quoted lambda
     expression, or a form (that should evaluate to a function symbol
     or lambda expression).  This is useful when function arguments
     might be quoted with `quote' rather than `function' since the body
     of a lambda expression will be instrumented either way.

`lambda-expr'
     An unquoted anonymous lambda expression.

`&optional'
     All following elements in the specification list are optional; as
     soon as one does not match, Edebug stops matching at this level.

     To make just a few elements optional followed by non-optional
     elements, use `[&optional SPECS...]'.  To specify that several
     elements should all succeed together, use `&optional [SPECS...]'.
     See the `defun' example below.

`&rest'
     All following elements in the specification list are repeated zero
     or more times.  All the elements need not match in the last
     repetition, however.

     To repeat only a few elements, use `[&rest SPECS...]'.  To specify
     all elements must match on every repetition, use `&rest
     [SPECS...]'.

`&or'
     Each of the following elements in the specification list is an
     alternative, processed left to right until one matches.  One of the
     alternatives must match otherwise the `&or' specification fails.

     Each list element following `&or' is a single alternative even if
     it is a keyword specification. (This breaks the implicit grouping
     rule.)  To group two or more list elements as a single
     alternative, enclose them in `[...]'.

`&not'
     Each of the following elements is matched as alternatives as if by
     using `&or', but if any of them match, the specification fails.
     If none of them match, nothing is matched, but the `&not'
     specification succeeds.

`&define'
     Indicates that the specification is for a defining form.  The
     defining form itself is not instrumented (i.e. Edebug does not
     stop before and after the defining form), but forms inside it
     typically will be instrumented.  The `&define' keyword should be
     the first element in a list specification.

     Additional specifications that may only appear after `&define' are
     described here.  See the `defun' example below.

    `name'
          The argument, a symbol, is the name of the defining form.
          But a defining form need not be named at all, in which case a
          unique name will be created for it.

          The `name' specification may be used more than once in the
          specification and each subsequent use will append the
          corresponding symbol argument to the previous name with ``@''
          between them.  This is useful for generating unique but
          meaningful names for definitions such as `defadvice' and
          `defmethod'.

    `:name'
          The element following `:name' should be a symbol; it is used
          as an additional name component for the definition.  This is
          useful to add a unique, static component to the name of the
          definition.  It may be used more than once.  No argument is
          matched.

    `arg'
          The argument, a symbol, is the name of an argument of the
          defining form.  However, lambda list keywords (symbols
          starting with ``&'') are not allowed.  See `lambda-list' and
          the example below.

    `lambda-list'
          This matches the whole argument list of an XEmacs Lisp lambda
          expression, which is a list of symbols and the keywords
          `&optional' and `&rest'

    `def-body'
          The argument is the body of code in a definition.  This is
          like `body', described above, but a definition body must be
          instrumented with a different Edebug call that looks up
          information associated with the definition.  Use `def-body'
          for the highest level list of forms within the definition.

    `def-form'
          The argument is a single, highest-level form in a definition.
          This is like `def-body', except use this to match a single
          form rather than a list of forms.  As a special case,
          `def-form' also means that tracing information is not output
          when the form is executed.  See the `interactive' example
          below.

`nil'
     This is successful when there are no more arguments to match at the
     current argument list level; otherwise it fails.  See sublist
     specifications and the backquote example below.

`gate'
     No argument is matched but backtracking through the gate is
     disabled while matching the remainder of the specifications at
     this level.  This is primarily used to generate more specific
     syntax error messages.  See *Note Backtracking:: for more details.
     Also see the `let' example below.

`OTHER-SYMBOL'
     Any other symbol in a specification list may be a predicate or an
     indirect specification.

     If the symbol has an Edebug specification, this "indirect
     specification" should be either a list specification that is used
     in place of the symbol, or a function that is called to process the
     arguments.  The specification may be defined with `def-edebug-spec'
     just as for macros. See the `defun' example below.

     Otherwise, the symbol should be a predicate.  The predicate is
     called with the argument and the specification fails if the
     predicate fails.  The argument is not instrumented.

     Predicates that may be used include: `symbolp', `integerp',
     `stringp', `vectorp', `atom' (which matches a number, string,
     symbol, or vector), `keywordp', and `lambda-list-keywordp'.  The
     last two, defined in `edebug.el', test whether the argument is a
     symbol starting with ``:'' and ``&'' respectively.

`[ELEMENTS...]'
     Rather than matching a vector argument, a vector treats the
     ELEMENTS as a single "group specification".

`"STRING"'
     The argument should be a symbol named STRING.  This specification
     is equivalent to the quoted symbol, `'SYMBOL', where the name of
     SYMBOL is the STRING, but the string form is preferred.

`'SYMBOL or (quote SYMBOL)'
     The argument should be the symbol SYMBOL.  But use a string
     specification instead.

`(vector ELEMENTS...)'
     The argument should be a vector whose elements must match the
     ELEMENTS in the specification.  See the backquote example below.

`(ELEMENTS...)'
     Any other list is a "sublist specification" and the argument must
     be a list whose elements match the specification ELEMENTS.

     A sublist specification may be a dotted list and the corresponding
     list argument may then be a dotted list.  Alternatively, the last
     cdr of a dotted list specification may be another sublist
     specification (via a grouping or an indirect specification, e.g.
     `(spec .  [(more specs...)])') whose elements match the non-dotted
     list arguments.  This is useful in recursive specifications such
     as in the backquote example below.  Also see the description of a
     `nil' specification above for terminating such recursion.

     Note that a sublist specification of the form `(specs .  nil)'
     means the same as `(specs)', and `(specs .
     (sublist-elements...))' means the same as `(specs
     sublist-elements...)'.


File: lispref.info,  Node: Backtracking,  Next: Debugging Backquote,  Prev: Specification List,  Up: Instrumenting Macro Calls

Backtracking
............

   If a specification fails to match at some point, this does not
necessarily mean a syntax error will be signaled; instead,
"backtracking" will take place until all alternatives have been
exhausted.  Eventually every element of the argument list must be
matched by some element in the specification, and every required element
in the specification must match some argument.

   Backtracking is disabled for the remainder of a sublist or group when
certain conditions occur, described below.  Backtracking is reenabled
when a new alternative is established by `&optional', `&rest', or
`&or'.  It is also reenabled initially when processing a sublist or
group specification or an indirect specification.

   You might want to disable backtracking to commit to some alternative
so that Edebug can provide a more specific syntax error message.
Normally, if no alternative matches, Edebug reports that none matched,
but if one alternative is committed to, Edebug can report how it failed
to match.

   First, backtracking is disabled while matching any of the form
specifications (i.e. `form', `body', `def-form', and `def-body').
These specifications will match any form so any error must be in the
form itself rather than at a higher level.

   Second, backtracking is disabled after successfully matching a quoted
symbol or string specification, since this usually indicates a
recognized construct.  If you have a set of alternative constructs that
all begin with the same symbol, you can usually work around this
constraint by factoring the symbol out of the alternatives, e.g.,
`["foo" &or [first case] [second case] ...]'.

   Third, backtracking may be explicitly disabled by using the `gate'
specification.  This is useful when you know that no higher
alternatives may apply.


File: lispref.info,  Node: Debugging Backquote,  Next: Specification Examples,  Prev: Backtracking,  Up: Instrumenting Macro Calls

Debugging Backquote
...................

   Backquote (``') is a macro that results in an expression that may or
may not be evaluated.  It is often used to simplify the definition of a
macro to return an expression that is evaluated, but Edebug does not
know when this is the case.  However, the forms inside unquotes (`,' and
`,@') are evaluated and Edebug instruments them.

   Nested backquotes are supported by Edebug, but there is a limit on
the support of quotes inside of backquotes.  Quoted forms (with `'')
are not normally evaluated, but if the quoted form appears immediately
within `,' and `,@' forms, Edebug treats this as a backquoted form at
the next higher level (even if there is not a next higher level - this
is difficult to fix).

   If the backquoted forms happen to be code intended to be evaluated,
you can have Edebug instrument them by using `edebug-`' instead of the
regular ``'.  Unquoted forms can always appear inside `edebug-`'
anywhere a form is normally allowed.  But `(, FORM)' may be used in two
other places specially recognized by Edebug: wherever a predicate
specification would match, and at the head of a list form in place of a
function name or lambda expression.  The FORM inside a spliced unquote,
`(,@ FORM)', will be wrapped, but the unquote form itself will not be
wrapped since this would interfere with the splicing.

   There is one other complication with using `edebug-`'.  If the
`edebug-`' call is in a macro and the macro may be called from code
that is also instrumented, and if unquoted forms contain any macro
arguments bound to instrumented forms, then you should modify the
specification for the macro as follows: the specifications for those
arguments must use `def-form' instead of `form'.  (This is to
reestablish the Edebugging context for those external forms.)

   For example, the `for' macro (*note Problems with Macros: ()Problems
with Macros.) is shown here but with `edebug-`' substituted for regular
``'.

     (defmacro inc (var)
       (list 'setq var (list '1+ var)))
     
     (defmacro for (var from init to final do &rest body)
       (let ((tempvar (make-symbol "max")))
         (edebug-` (let (((, var) (, init))
                         ((, tempvar) (, final)))
                     (while (<= (, var) (, tempvar))
                       (, body)
                       (inc (, var)))))))

   Here is the corresponding modified Edebug specification and some code
that calls the macro:

     (def-edebug-spec for
       (symbolp "from" def-form "to" def-form "do" &rest def-form))
     
     (let ((n 5))
       (for i from n to (* n (+ n 1)) do
         (message "%s" i)))

   After instrumenting the `for' macro and the macro call, Edebug first
steps to the beginning of the macro call, then into the macro body,
then through each of the unquoted expressions in the backquote showing
the expressions that will be embedded in the backquote form.  Then when
the macro expansion is evaluated, Edebug will step through the `let'
form and each time it gets to an unquoted form, it will jump back to an
argument of the macro call to step through that expression.  Finally
stepping will continue after the macro call.  Even more convoluted
execution paths may result when using anonymous functions.

   When the result of an expression is an instrumented expression, it is
difficult to see the expression inside the instrumentation.  So you may
want to set the option `edebug-unwrap-results' to a non-`nil' value
while debugging such expressions, but it would slow Edebug down to
always do this.


File: lispref.info,  Node: Specification Examples,  Prev: Debugging Backquote,  Up: Instrumenting Macro Calls

Specification Examples
......................

   Here we provide several examples of Edebug specifications to show
many of its capabilities.

   A `let' special form has a sequence of bindings and a body.  Each of
the bindings is either a symbol or a sublist with a symbol and optional
value.  In the specification below, notice the `gate' inside of the
sublist to prevent backtracking.

     (def-edebug-spec let
       ((&rest
         &or symbolp (gate symbolp &optional form))
        body))

   Edebug uses the following specifications for `defun' and `defmacro'
and the associated argument list and `interactive' specifications.  It
is necessary to handle the expression argument of an interactive form
specially since it is actually evaluated outside of the function body.

     (def-edebug-spec defmacro defun)      ; Indirect ref to `defun' spec
     (def-edebug-spec defun
       (&define name lambda-list
                [&optional stringp]        ; Match the doc string, if present.
                [&optional ("interactive" interactive)]
                def-body))
     
     (def-edebug-spec lambda-list
       (([&rest arg]
         [&optional ["&optional" arg &rest arg]]
         &optional ["&rest" arg]
         )))
     
     (def-edebug-spec interactive
       (&optional &or stringp def-form))    ; Notice: `def-form'

   The specification for backquote below illustrates how to match
dotted lists and use `nil' to terminate recursion.  It also illustrates
how components of a vector may be matched.  (The actual specification
provided by Edebug does not support dotted lists because doing so
causes very deep recursion that could fail.)

     (def-edebug-spec ` (backquote-form))  ;; alias just for clarity
     
     (def-edebug-spec backquote-form
       (&or ([&or "," ",@"] &or ("quote" backquote-form) form)
            (backquote-form . [&or nil backquote-form])
            (vector &rest backquote-form)
            sexp))


File: lispref.info,  Node: Edebug Options,  Prev: Instrumenting Macro Calls,  Up: Edebug

Edebug Options
--------------

   These options affect the behavior of Edebug:

 - User Option: edebug-setup-hook
     Functions to call before Edebug is used.  Each time it is set to a
     new value, Edebug will call those functions once and then
     `edebug-setup-hook' is reset to `nil'.  You could use this to load
     up Edebug specifications associated with a package you are using
     but only when you also use Edebug.  See *Note Instrumenting::.

 - User Option: edebug-all-defs
     If non-`nil', normal evaluation of any defining forms (e.g.
     `defun' and `defmacro') will instrument them for Edebug.  This
     applies to `eval-defun', `eval-region', and `eval-current-buffer'.

     Use the command `M-x edebug-all-defs' to toggle the value of this
     variable. You may want to make this variable local to each buffer
     by calling `(make-local-variable 'edebug-all-defs)' in your
     `emacs-lisp-mode-hook'.  See *Note Instrumenting::.

 - User Option: edebug-all-forms
     If non-`nil', normal evaluation of any forms by `eval-defun',
     `eval-region', and `eval-current-buffer' will instrument them for
     Edebug.

     Use the command `M-x edebug-all-forms' to toggle the value of this
     option.  See *Note Instrumenting::.

 - User Option: edebug-save-windows
     If non-`nil', save and restore window configuration on Edebug
     calls.  It takes some time to do this, so if your program does not
     care what happens to data about windows, you may want to set this
     variable to `nil'.

     If the value is a list, only the listed windows are saved and
     restored.

     `M-x edebug-toggle-save-windows' may be used to change this
     variable.  This command is bound to `W' in source code buffers.
     See *Note Edebug Display Update::.

 - User Option: edebug-save-displayed-buffer-points
     If non-`nil', save and restore point in all displayed buffers.
     This is necessary if you are debugging code that changes the point
     of a buffer which is displayed in a non-selected window.  If
     Edebug or the user then selects the window, the buffer's point
     will be changed to the window's point.

     This is an expensive operation since it visits each window and
     therefore each displayed buffer twice for each Edebug activation,
     so it is best to avoid it if you can.  See *Note Edebug Display
     Update::.

 - User Option: edebug-initial-mode
     If this variable is non-`nil', it specifies the initial execution
     mode for Edebug when it is first activated.  Possible values are
     `step', `next', `go', `Go-nonstop', `trace', `Trace-fast',
     `continue', and `Continue-fast'.

     The default value is `step'.  See *Note Edebug Execution Modes::.

 - User Option: edebug-trace
     Non-`nil' means display a trace of function entry and exit.
     Tracing output is displayed in a buffer named `*edebug-trace*', one
     function entry or exit per line, indented by the recursion level.

     The default value is `nil'.

     Also see `edebug-tracing'.  See *Note Tracing::.

 - User Option: edebug-test-coverage
     If non-`nil', Edebug tests coverage of all expressions debugged.
     This is done by comparing the result of each expression with the
     previous result. Coverage is considered OK if two different
     results are found.  So to sufficiently test the coverage of your
     code, try to execute it under conditions that evaluate all
     expressions more than once, and produce different results for each
     expression.

     Use `M-x edebug-display-freq-count' to display the frequency count
     and coverage information for a definition.  See *Note Coverage
     Testing::.

 - User Option: edebug-continue-kbd-macro
     If non-`nil', continue defining or executing any keyboard macro
     that is executing outside of Edebug.   Use this with caution since
     it is not debugged.  See *Note Edebug Execution Modes::.

 - User Option: edebug-print-length
     If non-`nil', bind `print-length' to this while printing results
     in Edebug.  The default value is `50'.  See *Note Printing in
     Edebug::.

 - User Option: edebug-print-level
     If non-`nil', bind `print-level' to this while printing results in
     Edebug.  The default value is `50'.

 - User Option: edebug-print-circle
     If non-`nil', bind `print-circle' to this while printing results
     in Edebug.  The default value is `nil'.

 - User Option: edebug-on-error
     `debug-on-error' is bound to this while Edebug is active.  See
     *Note Trapping Errors::.

 - User Option: edebug-on-quit
     `debug-on-quit' is bound to this while Edebug is active.  See
     *Note Trapping Errors::.

 - User Option: edebug-unwrap-results
     Non-`nil' if Edebug should unwrap results of expressions.  This is
     useful when debugging macros where the results of expressions are
     instrumented expressions.  But don't do this when results might be
     circular or an infinite loop will result.  See *Note Debugging
     Backquote::.

 - User Option: edebug-global-break-condition
     If non-`nil', an expression to test for at every stop point.  If
     the result is non-`nil', then break.  Errors are ignored.  See
     *Note Global Break Condition::.


File: lispref.info,  Node: Read and Print,  Next: Minibuffers,  Prev: Debugging,  Up: Top

Reading and Printing Lisp Objects
*********************************

   "Printing" and "reading" are the operations of converting Lisp
objects to textual form and vice versa.  They use the printed
representations and read syntax described in *Note Lisp Data Types::.

   This chapter describes the Lisp functions for reading and printing.
It also describes "streams", which specify where to get the text (if
reading) or where to put it (if printing).

* Menu:

* Streams Intro::     Overview of streams, reading and printing.
* Input Streams::     Various data types that can be used as input streams.
* Input Functions::   Functions to read Lisp objects from text.
* Output Streams::    Various data types that can be used as output streams.
* Output Functions::  Functions to print Lisp objects as text.
* Output Variables::  Variables that control what the printing functions do.


File: lispref.info,  Node: Streams Intro,  Next: Input Streams,  Up: Read and Print

Introduction to Reading and Printing
====================================

   "Reading" a Lisp object means parsing a Lisp expression in textual
form and producing a corresponding Lisp object.  This is how Lisp
programs get into Lisp from files of Lisp code.  We call the text the
"read syntax" of the object.  For example, the text `(a . 5)' is the
read syntax for a cons cell whose CAR is `a' and whose CDR is the
number 5.

   "Printing" a Lisp object means producing text that represents that
object--converting the object to its printed representation.  Printing
the cons cell described above produces the text `(a . 5)'.

   Reading and printing are more or less inverse operations: printing
the object that results from reading a given piece of text often
produces the same text, and reading the text that results from printing
an object usually produces a similar-looking object.  For example,
printing the symbol `foo' produces the text `foo', and reading that text
returns the symbol `foo'.  Printing a list whose elements are `a' and
`b' produces the text `(a b)', and reading that text produces a list
(but not the same list) with elements `a' and `b'.

   However, these two operations are not precisely inverses.  There are
three kinds of exceptions:

   * Printing can produce text that cannot be read.  For example,
     buffers, windows, frames, subprocesses and markers print into text
     that starts with `#'; if you try to read this text, you get an
     error.  There is no way to read those data types.

   * One object can have multiple textual representations.  For example,
     `1' and `01' represent the same integer, and `(a b)' and `(a .
     (b))' represent the same list.  Reading will accept any of the
     alternatives, but printing must choose one of them.

   * Comments can appear at certain points in the middle of an object's
     read sequence without affecting the result of reading it.


File: lispref.info,  Node: Input Streams,  Next: Input Functions,  Prev: Streams Intro,  Up: Read and Print

Input Streams
=============

   Most of the Lisp functions for reading text take an "input stream"
as an argument.  The input stream specifies where or how to get the
characters of the text to be read.  Here are the possible types of input
stream:

BUFFER
     The input characters are read from BUFFER, starting with the
     character directly after point.  Point advances as characters are
     read.

MARKER
     The input characters are read from the buffer that MARKER is in,
     starting with the character directly after the marker.  The marker
     position advances as characters are read.  The value of point in
     the buffer has no effect when the stream is a marker.

STRING
     The input characters are taken from STRING, starting at the first
     character in the string and using as many characters as required.

FUNCTION
     The input characters are generated by FUNCTION, one character per
     call.  Normally FUNCTION is called with no arguments, and should
     return a character.

     Occasionally FUNCTION is called with one argument (always a
     character).  When that happens, FUNCTION should save the argument
     and arrange to return it on the next call.  This is called
     "unreading" the character; it happens when the Lisp reader reads
     one character too many and wants to "put it back where it came
     from".

`t'
     `t' used as a stream means that the input is read from the
     minibuffer.  In fact, the minibuffer is invoked once and the text
     given by the user is made into a string that is then used as the
     input stream.

`nil'
     `nil' supplied as an input stream means to use the value of
     `standard-input' instead; that value is the "default input
     stream", and must be a non-`nil' input stream.

SYMBOL
     A symbol as input stream is equivalent to the symbol's function
     definition (if any).

   Here is an example of reading from a stream that is a buffer, showing
where point is located before and after:

     ---------- Buffer: foo ----------
     This-!- is the contents of foo.
     ---------- Buffer: foo ----------
     
     (read (get-buffer "foo"))
          => is
     (read (get-buffer "foo"))
          => the
     
     ---------- Buffer: foo ----------
     This is the-!- contents of foo.
     ---------- Buffer: foo ----------

Note that the first read skips a space.  Reading skips any amount of
whitespace preceding the significant text.

   In Emacs 18, reading a symbol discarded the delimiter terminating the
symbol.  Thus, point would end up at the beginning of `contents' rather
than after `the'.  The Emacs 19 behavior is superior because it
correctly handles input such as `bar(foo)', where the open-parenthesis
that ends one object is needed as the beginning of another object.

   Here is an example of reading from a stream that is a marker,
initially positioned at the beginning of the buffer shown.  The value
read is the symbol `This'.


     ---------- Buffer: foo ----------
     This is the contents of foo.
     ---------- Buffer: foo ----------
     
     (setq m (set-marker (make-marker) 1 (get-buffer "foo")))
          => #<marker at 1 in foo>
     (read m)
          => This
     m
          => #<marker at 5 in foo>   ;; Before the first space.

   Here we read from the contents of a string:

     (read "(When in) the course")
          => (When in)

   The following example reads from the minibuffer.  The prompt is:
`Lisp expression: '.  (That is always the prompt used when you read
from the stream `t'.)  The user's input is shown following the prompt.

     (read t)
          => 23
     ---------- Buffer: Minibuffer ----------
     Lisp expression: 23 <RET>
     ---------- Buffer: Minibuffer ----------

   Finally, here is an example of a stream that is a function, named
`useless-stream'.  Before we use the stream, we initialize the variable
`useless-list' to a list of characters.  Then each call to the function
`useless-stream' obtains the next character in the list or unreads a
character by adding it to the front of the list.

     (setq useless-list (append "XY()" nil))
          => (88 89 40 41)
     
     (defun useless-stream (&optional unread)
       (if unread
           (setq useless-list (cons unread useless-list))
         (prog1 (car useless-list)
                (setq useless-list (cdr useless-list)))))
          => useless-stream

Now we read using the stream thus constructed:

     (read 'useless-stream)
          => XY
     
     useless-list
          => (40 41)

Note that the open and close parentheses remains in the list.  The Lisp
reader encountered the open parenthesis, decided that it ended the
input, and unread it.  Another attempt to read from the stream at this
point would read `()' and return `nil'.


File: lispref.info,  Node: Input Functions,  Next: Output Streams,  Prev: Input Streams,  Up: Read and Print

Input Functions
===============

   This section describes the Lisp functions and variables that pertain
to reading.

   In the functions below, STREAM stands for an input stream (see the
previous section).  If STREAM is `nil' or omitted, it defaults to the
value of `standard-input'.

   An `end-of-file' error is signaled if reading encounters an
unterminated list, vector, or string.

 - Function: read &optional stream
     This function reads one textual Lisp expression from STREAM,
     returning it as a Lisp object.  This is the basic Lisp input
     function.

 - Function: read-from-string string &optional start end
     This function reads the first textual Lisp expression from the
     text in STRING.  It returns a cons cell whose CAR is that
     expression, and whose CDR is an integer giving the position of the
     next remaining character in the string (i.e., the first one not
     read).

     If START is supplied, then reading begins at index START in the
     string (where the first character is at index 0).  If END is also
     supplied, then reading stops just before that index, as if the rest
     of the string were not there.

     For example:

          (read-from-string "(setq x 55) (setq y 5)")
               => ((setq x 55) . 11)
          (read-from-string "\"A short string\"")
               => ("A short string" . 16)
          
          ;; Read starting at the first character.
          (read-from-string "(list 112)" 0)
               => ((list 112) . 10)
          ;; Read starting at the second character.
          (read-from-string "(list 112)" 1)
               => (list . 5)
          ;; Read starting at the seventh character,
          ;;   and stopping at the ninth.
          (read-from-string "(list 112)" 6 8)
               => (11 . 8)

 - Variable: standard-input
     This variable holds the default input stream--the stream that
     `read' uses when the STREAM argument is `nil'.


File: lispref.info,  Node: Output Streams,  Next: Output Functions,  Prev: Input Functions,  Up: Read and Print

Output Streams
==============

   An output stream specifies what to do with the characters produced
by printing.  Most print functions accept an output stream as an
optional argument.  Here are the possible types of output stream:

BUFFER
     The output characters are inserted into BUFFER at point.  Point
     advances as characters are inserted.

MARKER
     The output characters are inserted into the buffer that MARKER
     points into, at the marker position.  The marker position advances
     as characters are inserted.  The value of point in the buffer has
     no effect on printing when the stream is a marker.

FUNCTION
     The output characters are passed to FUNCTION, which is responsible
     for storing them away.  It is called with a single character as
     argument, as many times as there are characters to be output, and
     is free to do anything at all with the characters it receives.

`t'
     The output characters are displayed in the echo area.

`nil'
     `nil' specified as an output stream means to the value of
     `standard-output' instead; that value is the "default output
     stream", and must be a non-`nil' output stream.

SYMBOL
     A symbol as output stream is equivalent to the symbol's function
     definition (if any).

   Many of the valid output streams are also valid as input streams.
The difference between input and output streams is therefore mostly one
of how you use a Lisp object, not a distinction of types of object.

   Here is an example of a buffer used as an output stream.  Point is
initially located as shown immediately before the `h' in `the'.  At the
end, point is located directly before that same `h'.

     ---------- Buffer: foo ----------
     This is t-!-he contents of foo.
     ---------- Buffer: foo ----------
     
     (print "This is the output" (get-buffer "foo"))
          => "This is the output"
     
     ---------- Buffer: foo ----------
     This is t
     "This is the output"
     -!-he contents of foo.
     ---------- Buffer: foo ----------

   Now we show a use of a marker as an output stream.  Initially, the
marker is in buffer `foo', between the `t' and the `h' in the word
`the'.  At the end, the marker has advanced over the inserted text so
that it remains positioned before the same `h'.  Note that the location
of point, shown in the usual fashion, has no effect.

     ---------- Buffer: foo ----------
     "This is the -!-output"
     ---------- Buffer: foo ----------
     
     m
          => #<marker at 11 in foo>
     
     (print "More output for foo." m)
          => "More output for foo."
     
     ---------- Buffer: foo ----------
     "This is t
     "More output for foo."
     he -!-output"
     ---------- Buffer: foo ----------
     
     m
          => #<marker at 35 in foo>

   The following example shows output to the echo area:

     (print "Echo Area output" t)
          => "Echo Area output"
     ---------- Echo Area ----------
     "Echo Area output"
     ---------- Echo Area ----------

   Finally, we show the use of a function as an output stream.  The
function `eat-output' takes each character that it is given and conses
it onto the front of the list `last-output' (*note Building Lists::).
At the end, the list contains all the characters output, but in reverse
order.

     (setq last-output nil)
          => nil
     
     (defun eat-output (c)
       (setq last-output (cons c last-output)))
          => eat-output
     
     (print "This is the output" 'eat-output)
          => "This is the output"
     
     last-output
          => (?\n ?\" ?t ?u ?p ?t ?u ?o ?\  ?e ?h ?t
                     ?\  ?s ?i ?\  ?s ?i ?h ?T ?\" ?\n)

Now we can put the output in the proper order by reversing the list:

     (concat (nreverse last-output))
          => "
     \"This is the output\"
     "

Calling `concat' converts the list to a string so you can see its
contents more clearly.


File: lispref.info,  Node: Output Functions,  Next: Output Variables,  Prev: Output Streams,  Up: Read and Print

Output Functions
================

   This section describes the Lisp functions for printing Lisp objects.

   Some of the XEmacs printing functions add quoting characters to the
output when necessary so that it can be read properly.  The quoting
characters used are `"' and `\'; they distinguish strings from symbols,
and prevent punctuation characters in strings and symbols from being
taken as delimiters when reading.  *Note Printed Representation::, for
full details.  You specify quoting or no quoting by the choice of
printing function.

   If the text is to be read back into Lisp, then it is best to print
with quoting characters to avoid ambiguity.  Likewise, if the purpose is
to describe a Lisp object clearly for a Lisp programmer.  However, if
the purpose of the output is to look nice for humans, then it is better
to print without quoting.

   Printing a self-referent Lisp object requires an infinite amount of
text.  In certain cases, trying to produce this text leads to a stack
overflow.  XEmacs detects such recursion and prints `#LEVEL' instead of
recursively printing an object already being printed.  For example,
here `#0' indicates a recursive reference to the object at level 0 of
the current print operation:

     (setq foo (list nil))
          => (nil)
     (setcar foo foo)
          => (#0)

   In the functions below, STREAM stands for an output stream.  (See
the previous section for a description of output streams.)  If STREAM
is `nil' or omitted, it defaults to the value of `standard-output'.

 - Function: print object &optional stream
     The `print' function is a convenient way of printing.  It outputs
     the printed representation of OBJECT to STREAM, printing in
     addition one newline before OBJECT and another after it.  Quoting
     characters are used.  `print' returns OBJECT.  For example:

          (progn (print 'The\ cat\ in)
                 (print "the hat")
                 (print " came back"))
               -|
               -| The\ cat\ in
               -|
               -| "the hat"
               -|
               -| " came back"
               -|
               => " came back"

 - Function: prin1 object &optional stream
     This function outputs the printed representation of OBJECT to
     STREAM.  It does not print newlines to separate output as `print'
     does, but it does use quoting characters just like `print'.  It
     returns OBJECT.

          (progn (prin1 'The\ cat\ in)
                 (prin1 "the hat")
                 (prin1 " came back"))
               -| The\ cat\ in"the hat"" came back"
               => " came back"

 - Function: princ object &optional stream
     This function outputs the printed representation of OBJECT to
     STREAM.  It returns OBJECT.

     This function is intended to produce output that is readable by
     people, not by `read', so it doesn't insert quoting characters and
     doesn't put double-quotes around the contents of strings.  It does
     not add any spacing between calls.

          (progn
            (princ 'The\ cat)
            (princ " in the \"hat\""))
               -| The cat in the "hat"
               => " in the \"hat\""

 - Function: terpri &optional stream
     This function outputs a newline to STREAM.  The name stands for
     "terminate print".

 - Function: write-char character &optional stream
     This function outputs CHARACTER to STREAM.  It returns CHARACTER.

 - Function: prin1-to-string object &optional noescape
     This function returns a string containing the text that `prin1'
     would have printed for the same argument.

          (prin1-to-string 'foo)
               => "foo"
          (prin1-to-string (mark-marker))
               => "#<marker at 2773 in strings.texi>"

     If NOESCAPE is non-`nil', that inhibits use of quoting characters
     in the output.  (This argument is supported in Emacs versions 19
     and later.)

          (prin1-to-string "foo")
               => "\"foo\""
          (prin1-to-string "foo" t)
               => "foo"

     See `format', in *Note String Conversion::, for other ways to
     obtain the printed representation of a Lisp object as a string.


File: lispref.info,  Node: Output Variables,  Prev: Output Functions,  Up: Read and Print

Variables Affecting Output
==========================

 - Variable: standard-output
     The value of this variable is the default output stream--the stream
     that print functions use when the STREAM argument is `nil'.

 - Variable: print-escape-newlines
     If this variable is non-`nil', then newline characters in strings
     are printed as `\n' and formfeeds are printed as `\f'.  Normally
     these characters are printed as actual newlines and formfeeds.

     This variable affects the print functions `prin1' and `print', as
     well as everything that uses them.  It does not affect `princ'.
     Here is an example using `prin1':

          (prin1 "a\nb")
               -| "a
               -| b"
               => "a
          b"
          
          (let ((print-escape-newlines t))
            (prin1 "a\nb"))
               -| "a\nb"
               => "a
          b"

     In the second expression, the local binding of
     `print-escape-newlines' is in effect during the call to `prin1',
     but not during the printing of the result.

 - Variable: print-readably
     If non-`nil', then all objects will be printed in a readable form.
     If an object has no readable representation, then an error is
     signalled.  When `print-readably' is true, compiled-function
     objects will be written in `#[...]' form instead of in
     `#<compiled-function [...]>' form, and two-element lists of the
     form `(quote object)' will be written as the equivalent `'object'.
     Do not _set_ this variable; bind it instead.

 - Variable: print-length
     The value of this variable is the maximum number of elements of a
     list that will be printed.  If a list being printed has more than
     this many elements, it is abbreviated with an ellipsis.

     If the value is `nil' (the default), then there is no limit.

          (setq print-length 2)
               => 2
          (print '(1 2 3 4 5))
               -| (1 2 ...)
               => (1 2 ...)

 - Variable: print-level
     The value of this variable is the maximum depth of nesting of
     parentheses and brackets when printed.  Any list or vector at a
     depth exceeding this limit is abbreviated with an ellipsis.  A
     value of `nil' (which is the default) means no limit.

     This variable exists in version 19 and later versions.

 - Variable: print-string-length
     The value of this variable is the maximum number of characters of
     a string that will be printed.  If a string being printed has more
     than this many characters, it is abbreviated with an ellipsis.

 - Variable: print-gensym
     If non-`nil', then uninterned symbols will be printed specially.
     Uninterned symbols are those which are not present in `obarray',
     that is, those which were made with `make-symbol' or by calling
     `intern' with a second argument.

     When `print-gensym' is true, such symbols will be preceded by
     `#:', which causes the reader to create a new symbol instead of
     interning and returning an existing one.  Beware: The `#:' syntax
     creates a new symbol each time it is seen, so if you print an
     object which contains two pointers to the same uninterned symbol,
     `read' will not duplicate that structure.

     Also, since XEmacs has no real notion of packages, there is no way
     for the printer to distinguish between symbols interned in no
     obarray, and symbols interned in an alternate obarray.

 - Variable: float-output-format
     This variable holds the format descriptor string that Lisp uses to
     print floats.  This is a `%'-spec like those accepted by `printf'
     in C, but with some restrictions.  It must start with the two
     characters `%.'.  After that comes an integer precision
     specification, and then a letter which controls the format.  The
     letters allowed are `e', `f' and `g'.

        * Use `e' for exponential notation `DIG.DIGITSeEXPT'.

        * Use `f' for decimal point notation `DIGITS.DIGITS'.

        * Use `g' to choose the shorter of those two formats for the
          number at hand.

     The precision in any of these cases is the number of digits
     following the decimal point.  With `f', a precision of 0 means to
     omit the decimal point.  0 is not allowed with `f' or `g'.

     A value of `nil' means to use `%.16g'.

     Regardless of the value of `float-output-format', a floating point
     number will never be printed in such a way that it is ambiguous
     with an integer; that is, a floating-point number will always be
     printed with a decimal point and/or an exponent, even if the
     digits following the decimal point are all zero.  This is to
     preserve read-equivalence.


File: lispref.info,  Node: Minibuffers,  Next: Command Loop,  Prev: Read and Print,  Up: Top

Minibuffers
***********

   A "minibuffer" is a special buffer that XEmacs commands use to read
arguments more complicated than the single numeric prefix argument.
These arguments include file names, buffer names, and command names (as
in `M-x').  The minibuffer is displayed on the bottom line of the
frame, in the same place as the echo area, but only while it is in use
for reading an argument.

* Menu:

* Intro to Minibuffers::      Basic information about minibuffers.
* Text from Minibuffer::      How to read a straight text string.
* Object from Minibuffer::    How to read a Lisp object or expression.
* Minibuffer History::	      Recording previous minibuffer inputs
				so the user can reuse them.
* Completion::                How to invoke and customize completion.
* Yes-or-No Queries::         Asking a question with a simple answer.
* Multiple Queries::	      Asking a series of similar questions.
* Reading a Password::	      Reading a password from the terminal.
* Minibuffer Misc::           Various customization hooks and variables.


File: lispref.info,  Node: Intro to Minibuffers,  Next: Text from Minibuffer,  Up: Minibuffers

Introduction to Minibuffers
===========================

   In most ways, a minibuffer is a normal XEmacs buffer.  Most
operations _within_ a buffer, such as editing commands, work normally
in a minibuffer.  However, many operations for managing buffers do not
apply to minibuffers.  The name of a minibuffer always has the form
` *Minibuf-NUMBER', and it cannot be changed.  Minibuffers are
displayed only in special windows used only for minibuffers; these
windows always appear at the bottom of a frame.  (Sometimes frames have
no minibuffer window, and sometimes a special kind of frame contains
nothing but a minibuffer window; see *Note Minibuffers and Frames::.)

   The minibuffer's window is normally a single line.  You can resize it
temporarily with the window sizing commands; it reverts to its normal
size when the minibuffer is exited.  You can resize it permanently by
using the window sizing commands in the frame's other window, when the
minibuffer is not active.  If the frame contains just a minibuffer, you
can change the minibuffer's size by changing the frame's size.

   If a command uses a minibuffer while there is an active minibuffer,
this is called a "recursive minibuffer".  The first minibuffer is named
` *Minibuf-0*'.  Recursive minibuffers are named by incrementing the
number at the end of the name.  (The names begin with a space so that
they won't show up in normal buffer lists.)  Of several recursive
minibuffers, the innermost (or most recently entered) is the active
minibuffer.  We usually call this "the" minibuffer.  You can permit or
forbid recursive minibuffers by setting the variable
`enable-recursive-minibuffers'.

   Like other buffers, a minibuffer may use any of several local keymaps
(*note Keymaps::); these contain various exit commands and in some cases
completion commands (*note Completion::).

   * `minibuffer-local-map' is for ordinary input (no completion).

   * `minibuffer-local-completion-map' is for permissive completion.

   * `minibuffer-local-must-match-map' is for strict completion and for
     cautious completion.

