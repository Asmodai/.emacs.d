This is ../info/lispref.info, produced by makeinfo version 4.3 from
lispref/lispref.texi.

INFO-DIR-SECTION XEmacs Editor
START-INFO-DIR-ENTRY
* Lispref: (lispref).		XEmacs Lisp Reference Manual.
END-INFO-DIR-ENTRY

   Edition History:

   GNU Emacs Lisp Reference Manual Second Edition (v2.01), May 1993 GNU
Emacs Lisp Reference Manual Further Revised (v2.02), August 1993 Lucid
Emacs Lisp Reference Manual (for 19.10) First Edition, March 1994
XEmacs Lisp Programmer's Manual (for 19.12) Second Edition, April 1995
GNU Emacs Lisp Reference Manual v2.4, June 1995 XEmacs Lisp
Programmer's Manual (for 19.13) Third Edition, July 1995 XEmacs Lisp
Reference Manual (for 19.14 and 20.0) v3.1, March 1996 XEmacs Lisp
Reference Manual (for 19.15 and 20.1, 20.2, 20.3) v3.2, April, May,
November 1997 XEmacs Lisp Reference Manual (for 21.0) v3.3, April 1998

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995 Free Software
Foundation, Inc.  Copyright (C) 1994, 1995 Sun Microsystems, Inc.
Copyright (C) 1995, 1996 Ben Wing.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: lispref.info,  Node: Word Motion,  Next: Buffer End Motion,  Prev: Character Motion,  Up: Motion

Motion by Words
---------------

   These functions for parsing words use the syntax table to decide
whether a given character is part of a word.  *Note Syntax Tables::.

 - Command: forward-word &optional count buffer
     This function moves point forward COUNT words (or backward if
     COUNT is negative).  Normally it returns `t'.  If this motion
     encounters the beginning or end of the buffer, or the limits of the
     accessible portion when narrowing is in effect, point stops there
     and the value is `nil'.

     COUNT defaults to `1' and BUFFER defaults to the current buffer.

     In an interactive call, COUNT is set to the numeric prefix
     argument.

 - Command: backward-word &optional count buffer
     This function is just like `forward-word', except that it moves
     backward until encountering the front of a word, rather than
     forward.  BUFFER defaults to the current buffer if omitted.

     In an interactive call, COUNT is set to the numeric prefix
     argument.

 - Variable: words-include-escapes
     This variable affects the behavior of `forward-word' and everything
     that uses it.  If it is non-`nil', then characters in the "escape"
     and "character quote" syntax classes count as part of words.
     Otherwise, they do not.


File: lispref.info,  Node: Buffer End Motion,  Next: Text Lines,  Prev: Word Motion,  Up: Motion

Motion to an End of the Buffer
------------------------------

   To move point to the beginning of the buffer, write:

     (goto-char (point-min))

Likewise, to move to the end of the buffer, use:

     (goto-char (point-max))

   Here are two commands that users use to do these things.  They are
documented here to warn you not to use them in Lisp programs, because
they set the mark and display messages in the echo area.

 - Command: beginning-of-buffer &optional count
     This function moves point to the beginning of the buffer (or the
     limits of the accessible portion, when narrowing is in effect),
     setting the mark at the previous position.  If COUNT is non-`nil',
     then it puts point COUNT tenths of the way from the beginning of
     the buffer.

     In an interactive call, COUNT is the numeric prefix argument, if
     provided; otherwise COUNT defaults to `nil'.

     Don't use this function in Lisp programs!

 - Command: end-of-buffer &optional count
     This function moves point to the end of the buffer (or the limits
     of the accessible portion, when narrowing is in effect), setting
     the mark at the previous position.  If COUNT is non-`nil', then it
     puts point COUNT tenths of the way from the end of the buffer.

     In an interactive call, COUNT is the numeric prefix argument, if
     provided; otherwise COUNT defaults to `nil'.

     Don't use this function in Lisp programs!


File: lispref.info,  Node: Text Lines,  Next: Screen Lines,  Prev: Buffer End Motion,  Up: Motion

Motion by Text Lines
--------------------

   Text lines are portions of the buffer delimited by newline
characters, which are regarded as part of the previous line.  The first
text line begins at the beginning of the buffer, and the last text line
ends at the end of the buffer whether or not the last character is a
newline.  The division of the buffer into text lines is not affected by
the width of the window, by line continuation in display, or by how
tabs and control characters are displayed.

 - Command: goto-line line
     This function moves point to the front of the LINEth line,
     counting from line 1 at beginning of the buffer.  If LINE is less
     than 1, it moves point to the beginning of the buffer.  If LINE is
     greater than the number of lines in the buffer, it moves point to
     the end of the buffer--that is, the _end of the last line_ of the
     buffer.  This is the only case in which `goto-line' does not
     necessarily move to the beginning of a line.

     If narrowing is in effect, then LINE still counts from the
     beginning of the buffer, but point cannot go outside the accessible
     portion.  So `goto-line' moves point to the beginning or end of the
     accessible portion, if the line number specifies an inaccessible
     position.

     The return value of `goto-line' is the difference between LINE and
     the line number of the line to which point actually was able to
     move (in the full buffer, before taking account of narrowing).
     Thus, the value is positive if the scan encounters the real end of
     the buffer.  The value is zero if scan encounters the end of the
     accessible portion but not the real end of the buffer.

     In an interactive call, LINE is the numeric prefix argument if one
     has been provided.  Otherwise LINE is read in the minibuffer.

 - Command: beginning-of-line &optional count buffer
     This function moves point to the beginning of the current line.
     With an argument COUNT not `nil' or 1, it moves forward COUNT-1
     lines and then to the beginning of the line.  BUFFER defaults to
     the current buffer if omitted.

     If this function reaches the end of the buffer (or of the
     accessible portion, if narrowing is in effect), it positions point
     there.  No error is signaled.

 - Command: end-of-line &optional count buffer
     This function moves point to the end of the current line.  With an
     argument COUNT not `nil' or 1, it moves forward COUNT-1 lines and
     then to the end of the line.  BUFFER defaults to the current
     buffer if omitted.

     If this function reaches the end of the buffer (or of the
     accessible portion, if narrowing is in effect), it positions point
     there.  No error is signaled.

 - Command: forward-line &optional count buffer
     This function moves point forward COUNT lines, to the beginning of
     the line.  If COUNT is negative, it moves point -COUNT lines
     backward, to the beginning of a line.  If COUNT is zero, it moves
     point to the beginning of the current line.  BUFFER defaults to
     the current buffer if omitted.

     If `forward-line' encounters the beginning or end of the buffer (or
     of the accessible portion) before finding that many lines, it sets
     point there.  No error is signaled.

     `forward-line' returns the difference between COUNT and the number
     of lines actually moved.  If you attempt to move down five lines
     from the beginning of a buffer that has only three lines, point
     stops at the end of the last line, and the value will be 2.

     In an interactive call, COUNT is the numeric prefix argument.

 - Function: count-lines start end &optional ignore-invisible-lines-flag
     This function returns the number of lines between the positions
     START and END in the current buffer.  If START and END are equal,
     then it returns 0.  Otherwise it returns at least 1, even if START
     and END are on the same line.  This is because the text between
     them, considered in isolation, must contain at least one line
     unless it is empty.

     With optional IGNORE-INVISIBLE-LINES-FLAG non-`nil', lines
     collapsed with selective-display are excluded from the line count.

     *Note:* The expression to return the current line number is not
     obvious:

          (1+ (count-lines 1 (point-at-bol)))

     Here is an example of using `count-lines':

          (defun current-line ()
            "Return the vertical position of point..."
            (+ (count-lines (window-start) (point))
               (if (= (current-column) 0) 1 0)
               -1))

   Also see the functions `bolp' and `eolp' in *Note Near Point::.
These functions do not move point, but test whether it is already at the
beginning or end of a line.


File: lispref.info,  Node: Screen Lines,  Next: List Motion,  Prev: Text Lines,  Up: Motion

Motion by Screen Lines
----------------------

   The line functions in the previous section count text lines,
delimited only by newline characters.  By contrast, these functions
count screen lines, which are defined by the way the text appears on
the screen.  A text line is a single screen line if it is short enough
to fit the width of the selected window, but otherwise it may occupy
several screen lines.

   In some cases, text lines are truncated on the screen rather than
continued onto additional screen lines.  In these cases,
`vertical-motion' moves point much like `forward-line'.  *Note
Truncation::.

   Because the width of a given string depends on the flags that control
the appearance of certain characters, `vertical-motion' behaves
differently, for a given piece of text, depending on the buffer it is
in, and even on the selected window (because the width, the truncation
flag, and display table may vary between windows).  *Note Usual
Display::.

   These functions scan text to determine where screen lines break, and
thus take time proportional to the distance scanned.  If you intend to
use them heavily, Emacs provides caches which may improve the
performance of your code.  *Note cache-long-line-scans: Text Lines.

 - Function: vertical-motion count &optional window pixels
     This function moves point to the start of the frame line COUNT
     frame lines down from the frame line containing point.  If COUNT
     is negative, it moves up instead.  The optional second argument
     WINDOW may be used to specify a window other than the selected
     window in which to perform the motion.

     Normally, `vertical-motion' returns the number of lines moved.  The
     value may be less in absolute value than COUNT if the beginning or
     end of the buffer was reached.  If the optional third argument,
     PIXELS is non-`nil', the vertical pixel height of the motion which
     took place is returned instead of the actual number of lines
     moved.  A motion of zero lines returns the height of the current
     line.

     Note that `vertical-motion' sets WINDOW's buffer's point, not
     WINDOW's point. (This differs from FSF Emacs, which buggily always
     sets current buffer's point, regardless of WINDOW.)

 - Function: vertical-motion-pixels count &optional window how
     This function moves point to the start of the frame line PIXELS
     vertical pixels down from the frame line containing point, or up if
     PIXELS is negative.  The optional second argument WINDOW is the
     window to move in, and defaults to the selected window.  The
     optional third argument HOW specifies the stopping condition.  A
     negative integer indicates that the motion should be no more than
     PIXELS.  A positive value indicates that the motion should be at
     least PIXELS.  Any other value indicates that the motion should be
     as close as possible to PIXELS.

 - Command: move-to-window-line count &optional window
     This function moves point with respect to the text currently
     displayed in WINDOW, which defaults to the selected window.  It
     moves point to the beginning of the screen line COUNT screen lines
     from the top of the window.  If COUNT is negative, that specifies a
     position -COUNT lines from the bottom (or the last line of the
     buffer, if the buffer ends above the specified screen position).

     If COUNT is `nil', then point moves to the beginning of the line
     in the middle of the window.  If the absolute value of COUNT is
     greater than the size of the window, then point moves to the place
     that would appear on that screen line if the window were tall
     enough.  This will probably cause the next redisplay to scroll to
     bring that location onto the screen.

     In an interactive call, COUNT is the numeric prefix argument.

     The value returned is the window line number point has moved to,
     with the top line in the window numbered 0.


File: lispref.info,  Node: List Motion,  Next: Skipping Characters,  Prev: Screen Lines,  Up: Motion

Moving over Balanced Expressions
--------------------------------

   Here are several functions concerned with balanced-parenthesis
expressions (also called "sexps" in connection with moving across them
in XEmacs).  The syntax table controls how these functions interpret
various characters; see *Note Syntax Tables::.  *Note Parsing
Expressions::, for lower-level primitives for scanning sexps or parts of
sexps.  For user-level commands, see *Note Lists and Sexps:
(xemacs)Lists and Sexps.

 - Command: forward-list &optional arg
     This function moves forward across ARG balanced groups of
     parentheses. (Other syntactic entities such as words or paired
     string quotes are ignored.) ARG defaults to 1 if omitted.  If ARG
     is negative, move backward across that many groups of parentheses.

 - Command: backward-list &optional count
     This function moves backward across COUNT balanced groups of
     parentheses. (Other syntactic entities such as words or paired
     string quotes are ignored.) COUNT defaults to 1 if omitted.  If
     COUNT is negative, move forward across that many groups of
     parentheses.

 - Command: up-list &optional count
     This function moves forward out of COUNT levels of parentheses.  A
     negative argument means move backward but still to a less deep
     spot.

 - Command: down-list &optional count
     This function moves forward into COUNT levels of parentheses.  A
     negative argument means move backward but still go deeper in
     parentheses (-COUNT levels).

 - Command: forward-sexp &optional count
     This function moves forward across COUNT balanced expressions.
     Balanced expressions include both those delimited by parentheses
     and other kinds, such as words and string constants.  COUNT
     defaults to 1 if omitted.  If COUNT is negative, move backward
     across that many balanced expressions.  For example,

          ---------- Buffer: foo ----------
          (concat-!- "foo " (car x) y z)
          ---------- Buffer: foo ----------
          
          (forward-sexp 3)
               => nil
          
          ---------- Buffer: foo ----------
          (concat "foo " (car x) y-!- z)
          ---------- Buffer: foo ----------

 - Command: backward-sexp &optional count
     This function moves backward across COUNT balanced expressions.
     COUNT defaults to 1 if omitted.  If COUNT is negative, move
     forward across that many balanced expressions.

 - Command: beginning-of-defun &optional count
     This function moves back to the COUNTth beginning of a defun.  If
     COUNT is negative, this actually moves forward, but it still moves
     to the beginning of a defun, not to the end of one.  COUNT
     defaults to 1 if omitted.

 - Command: end-of-defun &optional count
     This function moves forward to the COUNTth end of a defun.  If
     COUNT is negative, this actually moves backward, but it still
     moves to the end of a defun, not to the beginning of one.  COUNT
     defaults to 1 if omitted.

 - User Option: defun-prompt-regexp
     If non-`nil', this variable holds a regular expression that
     specifies what text can appear before the open-parenthesis that
     starts a defun.  That is to say, a defun begins on a line that
     starts with a match for this regular expression, followed by a
     character with open-parenthesis syntax.


File: lispref.info,  Node: Skipping Characters,  Prev: List Motion,  Up: Motion

Skipping Characters
-------------------

   The following two functions move point over a specified set of
characters.  For example, they are often used to skip whitespace.  For
related functions, see *Note Motion and Syntax::.

 - Function: skip-chars-forward character-set &optional limit buffer
     This function moves point in BUFFER forward, skipping over a given
     set of characters.  It examines the character following point,
     then advances point if the character matches CHARACTER-SET.  This
     continues until it reaches a character that does not match.  The
     function returns `nil'.  BUFFER defaults to the current buffer if
     omitted.

     The argument CHARACTER-SET is like the inside of a `[...]' in a
     regular expression except that `]' is never special and `\' quotes
     `^', `-' or `\'.  Thus, `"a-zA-Z"' skips over all letters,
     stopping before the first non-letter, and `"^a-zA-Z'" skips
     non-letters stopping before the first letter.  *Note Regular
     Expressions::.

     If LIMIT is supplied (it must be a number or a marker), it
     specifies the maximum position in the buffer that point can be
     skipped to.  Point will stop at or before LIMIT.

     In the following example, point is initially located directly
     before the `T'.  After the form is evaluated, point is located at
     the end of that line (between the `t' of `hat' and the newline).
     The function skips all letters and spaces, but not newlines.

          ---------- Buffer: foo ----------
          I read "-!-The cat in the hat
          comes back" twice.
          ---------- Buffer: foo ----------
          
          (skip-chars-forward "a-zA-Z ")
               => nil
          
          ---------- Buffer: foo ----------
          I read "The cat in the hat-!-
          comes back" twice.
          ---------- Buffer: foo ----------

 - Function: skip-chars-backward character-set &optional limit buffer
     This function moves point backward, skipping characters that match
     CHARACTER-SET, until LIMIT.  It just like `skip-chars-forward'
     except for the direction of motion.


File: lispref.info,  Node: Excursions,  Next: Narrowing,  Prev: Motion,  Up: Positions

Excursions
==========

   It is often useful to move point "temporarily" within a localized
portion of the program, or to switch buffers temporarily.  This is
called an "excursion", and it is done with the `save-excursion' special
form.  This construct saves the current buffer and its values of point
and the mark so they can be restored after the completion of the
excursion.

   The forms for saving and restoring the configuration of windows are
described elsewhere (see *Note Window Configurations:: and *note Frame
Configurations::).

 - Special Form: save-excursion forms...
     The `save-excursion' special form saves the identity of the current
     buffer and the values of point and the mark in it, evaluates
     FORMS, and finally restores the buffer and its saved values of
     point and the mark.  All three saved values are restored even in
     case of an abnormal exit via `throw' or error (*note Nonlocal
     Exits::).

     The `save-excursion' special form is the standard way to switch
     buffers or move point within one part of a program and avoid
     affecting the rest of the program.  It is used more than 500 times
     in the Lisp sources of XEmacs.

     `save-excursion' does not save the values of point and the mark for
     other buffers, so changes in other buffers remain in effect after
     `save-excursion' exits.

     Likewise, `save-excursion' does not restore window-buffer
     correspondences altered by functions such as `switch-to-buffer'.
     One way to restore these correspondences, and the selected window,
     is to use `save-window-excursion' inside `save-excursion' (*note
     Window Configurations::).

     The value returned by `save-excursion' is the result of the last of
     FORMS, or `nil' if no FORMS are given.

          (save-excursion
            FORMS)
          ==
          (let ((old-buf (current-buffer))
                (old-pnt (point-marker))
                (old-mark (copy-marker (mark-marker))))
            (unwind-protect
                (progn FORMS)
              (set-buffer old-buf)
              (goto-char old-pnt)
              (set-marker (mark-marker) old-mark)))

 - Special Form: save-current-buffer forms...
     This special form is similar to `save-excursion' but it only saves
     and restores the current buffer.  Beginning with XEmacs 20.3,
     `save-current-buffer' is a primitive.

 - Special Form: with-current-buffer buffer forms...
     This special form evaluates FORMS with BUFFER as the current
     buffer.  It returns the value of the last form.

 - Special Form: with-temp-file filename forms...
     This special form creates a new buffer, evaluates FORMS there, and
     writes the buffer to FILENAME.  It returns the value of the last
     form evaluated.

 - Special Form: save-selected-window forms...
     This special form is similar to `save-excursion' but it saves and
     restores the selected window and nothing else.


File: lispref.info,  Node: Narrowing,  Prev: Excursions,  Up: Positions

Narrowing
=========

   "Narrowing" means limiting the text addressable by XEmacs editing
commands to a limited range of characters in a buffer.  The text that
remains addressable is called the "accessible portion" of the buffer.

   Narrowing is specified with two buffer positions which become the
beginning and end of the accessible portion.  For most editing commands
and most Emacs primitives, these positions replace the values of the
beginning and end of the buffer.  While narrowing is in effect, no text
outside the accessible portion is displayed, and point cannot move
outside the accessible portion.

   Values such as positions or line numbers, which usually count from
the beginning of the buffer, do so despite narrowing, but the functions
which use them refuse to operate on text that is inaccessible.

   The commands for saving buffers are unaffected by narrowing; they
save the entire buffer regardless of any narrowing.

 - Command: narrow-to-region start end &optional buffer
     This function sets the accessible portion of BUFFER to start at
     START and end at END.  Both arguments should be character
     positions.  BUFFER defaults to the current buffer if omitted.

     In an interactive call, START and END are set to the bounds of the
     current region (point and the mark, with the smallest first).

 - Command: narrow-to-page &optional move-count
     This function sets the accessible portion of the current buffer to
     include just the current page.  An optional first argument
     MOVE-COUNT non-`nil' means to move forward or backward by
     MOVE-COUNT pages and then narrow.  The variable `page-delimiter'
     specifies where pages start and end (*note Standard Regexps::).

     In an interactive call, MOVE-COUNT is set to the numeric prefix
     argument.

 - Command: widen &optional buffer
     This function cancels any narrowing in BUFFER, so that the entire
     contents are accessible.  This is called "widening".  It is
     equivalent to the following expression:

          (narrow-to-region 1 (1+ (buffer-size)))

     BUFFER defaults to the current buffer if omitted.

 - Special Form: save-restriction body...
     This special form saves the current bounds of the accessible
     portion, evaluates the BODY forms, and finally restores the saved
     bounds, thus restoring the same state of narrowing (or absence
     thereof) formerly in effect.  The state of narrowing is restored
     even in the event of an abnormal exit via `throw' or error (*note
     Nonlocal Exits::).  Therefore, this construct is a clean way to
     narrow a buffer temporarily.

     The value returned by `save-restriction' is that returned by the
     last form in BODY, or `nil' if no body forms were given.

     *Caution:* it is easy to make a mistake when using the
     `save-restriction' construct.  Read the entire description here
     before you try it.

     If BODY changes the current buffer, `save-restriction' still
     restores the restrictions on the original buffer (the buffer whose
     restrictions it saved from), but it does not restore the identity
     of the current buffer.

     `save-restriction' does _not_ restore point and the mark; use
     `save-excursion' for that.  If you use both `save-restriction' and
     `save-excursion' together, `save-excursion' should come first (on
     the outside).  Otherwise, the old point value would be restored
     with temporary narrowing still in effect.  If the old point value
     were outside the limits of the temporary narrowing, this would
     fail to restore it accurately.

     The `save-restriction' special form records the values of the
     beginning and end of the accessible portion as distances from the
     beginning and end of the buffer.  In other words, it records the
     amount of inaccessible text before and after the accessible
     portion.

     This method yields correct results if BODY does further narrowing.
     However, `save-restriction' can become confused if the body widens
     and then make changes outside the range of the saved narrowing.
     When this is what you want to do, `save-restriction' is not the
     right tool for the job.  Here is what you must use instead:

          (let ((start (point-min-marker))
                (end (point-max-marker)))
            (unwind-protect
                (progn BODY)
              (save-excursion
                (set-buffer (marker-buffer start))
                (narrow-to-region start end))))

     Here is a simple example of correct use of `save-restriction':

          ---------- Buffer: foo ----------
          This is the contents of foo
          This is the contents of foo
          This is the contents of foo-!-
          ---------- Buffer: foo ----------
          
          (save-excursion
            (save-restriction
              (goto-char 1)
              (forward-line 2)
              (narrow-to-region 1 (point))
              (goto-char (point-min))
              (replace-string "foo" "bar")))
          
          ---------- Buffer: foo ----------
          This is the contents of bar
          This is the contents of bar
          This is the contents of foo-!-
          ---------- Buffer: foo ----------


File: lispref.info,  Node: Markers,  Next: Text,  Prev: Positions,  Up: Top

Markers
*******

   A "marker" is a Lisp object used to specify a position in a buffer
relative to the surrounding text.  A marker changes its offset from the
beginning of the buffer automatically whenever text is inserted or
deleted, so that it stays with the two characters on either side of it.

* Menu:

* Overview of Markers::      The components of a marker, and how it relocates.
* Predicates on Markers::    Testing whether an object is a marker.
* Creating Markers::         Making empty markers or markers at certain places.
* Information from Markers:: Finding the marker's buffer or character position.
* Changing Markers::         Moving the marker to a new buffer or position.
* The Mark::                 How ``the mark'' is implemented with a marker.
* The Region::               How to access ``the region''.


File: lispref.info,  Node: Overview of Markers,  Next: Predicates on Markers,  Up: Markers

Overview of Markers
===================

   A marker specifies a buffer and a position in that buffer.  The
marker can be used to represent a position in the functions that
require one, just as an integer could be used.  *Note Positions::, for
a complete description of positions.

   A marker has two attributes: the marker position, and the marker
buffer.  The marker position is an integer that is equivalent (at a
given time) to the marker as a position in that buffer.  But the
marker's position value can change often during the life of the marker.
Insertion and deletion of text in the buffer relocate the marker.  The
idea is that a marker positioned between two characters remains between
those two characters despite insertion and deletion elsewhere in the
buffer.  Relocation changes the integer equivalent of the marker.

   Deleting text around a marker's position leaves the marker between
the characters immediately before and after the deleted text.  Inserting
text at the position of a marker normally leaves the marker in front of
the new text--unless it is inserted with `insert-before-markers' (*note
Insertion::).

   Insertion and deletion in a buffer must check all the markers and
relocate them if necessary.  This slows processing in a buffer with a
large number of markers.  For this reason, it is a good idea to make a
marker point nowhere if you are sure you don't need it any more.
Unreferenced markers are garbage collected eventually, but until then
will continue to use time if they do point somewhere.

   Because it is common to perform arithmetic operations on a marker
position, most of the arithmetic operations (including `+' and `-')
accept markers as arguments.  In such cases, the marker stands for its
current position.

   Note that you can use extents to achieve the same functionality, and
more, as markers. (Markers were defined before extents, which is why
they both continue to exist.) A zero-length extent with the
`detachable' property removed is almost identical to a marker.  (*Note
Extent Endpoints::, for more information on zero-length extents.)

   In particular:

   * In order to get marker-like behavior in a zero-length extent, the
     `detachable' property must be removed (otherwise, the extent will
     disappear when text near it is deleted) and exactly one endpoint
     must be closed (if both endpoints are closed, the extent will
     expand to contain text inserted where it is located).

   * If a zero-length extent has the `end-open' property but not the
     `start-open' property (this is the default), text inserted at the
     extent's location causes the extent to move forward, just like a
     marker.

   * If a zero-length extent has the `start-open' property but not the
     `end-open' property, text inserted at the extent's location causes
     the extent to remain before the text, like what happens to markers
     when `insert-before-markers' is used.

   * Markers end up after or before inserted text depending on whether
     `insert' or `insert-before-markers' was called.  These functions
     do not affect zero-length extents differently; instead, the
     presence or absence of the `start-open' and `end-open' extent
     properties determines this, as just described.

   * Markers are automatically removed from a buffer when they are no
     longer in use.  Extents remain around until explicitly removed
     from a buffer.

   * Many functions are provided for listing the extents in a buffer or
     in a region of a buffer.  No such functions exist for markers.

   Here are examples of creating markers, setting markers, and moving
point to markers:

     ;; Make a new marker that initially does not point anywhere:
     (setq m1 (make-marker))
          => #<marker in no buffer>
     
     ;; Set `m1' to point between the 99th and 100th characters
     ;;   in the current buffer:
     (set-marker m1 100)
          => #<marker at 100 in markers.texi>
     
     ;; Now insert one character at the beginning of the buffer:
     (goto-char (point-min))
          => 1
     (insert "Q")
          => nil
     
     ;; `m1' is updated appropriately.
     m1
          => #<marker at 101 in markers.texi>
     
     ;; Two markers that point to the same position
     ;;   are not `eq', but they are `equal'.
     (setq m2 (copy-marker m1))
          => #<marker at 101 in markers.texi>
     (eq m1 m2)
          => nil
     (equal m1 m2)
          => t
     
     ;; When you are finished using a marker, make it point nowhere.
     (set-marker m1 nil)
          => #<marker in no buffer>


File: lispref.info,  Node: Predicates on Markers,  Next: Creating Markers,  Prev: Overview of Markers,  Up: Markers

Predicates on Markers
=====================

   You can test an object to see whether it is a marker, or whether it
is either an integer or a marker or either an integer, a character, or a
marker.  The latter tests are useful in connection with the arithmetic
functions that work with any of markers, integers, or characters.

 - Function: markerp object
     This function returns `t' if OBJECT is a marker, `nil' otherwise.
     Note that integers are not markers, even though many functions
     will accept either a marker or an integer.

 - Function: integer-or-marker-p object
     This function returns `t' if OBJECT is an integer or a marker,
     `nil' otherwise.

 - Function: integer-char-or-marker-p object
     This function returns `t' if OBJECT is an integer, a character, or
     a marker, `nil' otherwise.

 - Function: number-or-marker-p object
     This function returns `t' if OBJECT is a number (either kind) or a
     marker, `nil' otherwise.

 - Function: number-char-or-marker-p object
     This function returns `t' if OBJECT is a number (either kind), a
     character, or a marker, `nil' otherwise.


File: lispref.info,  Node: Creating Markers,  Next: Information from Markers,  Prev: Predicates on Markers,  Up: Markers

Functions That Create Markers
=============================

   When you create a new marker, you can make it point nowhere, or point
to the present position of point, or to the beginning or end of the
accessible portion of the buffer, or to the same place as another given
marker.

 - Function: make-marker
     This functions returns a newly created marker that does not point
     anywhere.

          (make-marker)
               => #<marker in no buffer>

 - Function: point-marker &optional dont-copy-p buffer
     This function returns a marker that points to the present position
     of point in BUFFER, which defaults to the current buffer.  *Note
     Point::.  For an example, see `copy-marker', below.

     Internally, a marker corresponding to point is always maintained.
     Normally the marker returned by `point-marker' is a copy; you may
     modify it with reckless abandon.  However, if optional argument
     DONT-COPY-P is non-`nil', then the real point-marker is returned;
     modifying the position of this marker will move point.  It is
     illegal to change the buffer of it, or make it point nowhere.

 - Function: point-min-marker &optional buffer
     This function returns a new marker that points to the beginning of
     the accessible portion of BUFFER, which defaults to the current
     buffer.  This will be the beginning of the buffer unless narrowing
     is in effect.  *Note Narrowing::.

 - Function: point-max-marker &optional buffer
     This function returns a new marker that points to the end of the
     accessible portion of BUFFER, which defaults to the current
     buffer.  This will be the end of the buffer unless narrowing is in
     effect.  *Note Narrowing::.

     Here are examples of this function and `point-min-marker', shown in
     a buffer containing a version of the source file for the text of
     this chapter.

          (point-min-marker)
               => #<marker at 1 in markers.texi>
          (point-max-marker)
               => #<marker at 15573 in markers.texi>
          
          (narrow-to-region 100 200)
               => nil
          (point-min-marker)
               => #<marker at 100 in markers.texi>
          (point-max-marker)
               => #<marker at 200 in markers.texi>

 - Function: copy-marker marker-or-integer &optional marker-type
     If passed a marker as its argument, `copy-marker' returns a new
     marker that points to the same place and the same buffer as does
     MARKER-OR-INTEGER.  If passed an integer as its argument,
     `copy-marker' returns a new marker that points to position
     MARKER-OR-INTEGER in the current buffer.

     If passed an integer argument less than 1, `copy-marker' returns a
     new marker that points to the beginning of the current buffer.  If
     passed an integer argument greater than the length of the buffer,
     `copy-marker' returns a new marker that points to the end of the
     buffer.

     An error is signaled if MARKER-OR-INTEGER is neither a marker nor
     an integer.

     Optional second argument MARKER-TYPE specifies the insertion type
     of the new marker; see `marker-insertion-type'.

          (setq p (point-marker))
               => #<marker at 2139 in markers.texi>
          
          (setq q (copy-marker p))
               => #<marker at 2139 in markers.texi>
          
          (eq p q)
               => nil
          
          (equal p q)
               => t
          
          (point)
               => 2139
          
          (set-marker p 3000)
               => #<marker at 3000 in markers.texi>
          
          (point)
               => 2139
          
          (setq p (point-marker t))
               => #<marker at 2139 in markers.texi>
          
          (set-marker p 3000)
               => #<marker at 3000 in markers.texi>
          
          (point)
               => 3000
          
          (copy-marker 0)
               => #<marker at 1 in markers.texi>
          
          (copy-marker 20000)
               => #<marker at 7572 in markers.texi>


File: lispref.info,  Node: Information from Markers,  Next: Changing Markers,  Prev: Creating Markers,  Up: Markers

Information from Markers
========================

   This section describes the functions for accessing the components of
a marker object.

 - Function: marker-position marker
     This function returns the position that MARKER points to, or `nil'
     if it points nowhere.

 - Function: marker-buffer marker
     This function returns the buffer that MARKER points into, or `nil'
     if it points nowhere.

          (setq m (make-marker))
               => #<marker in no buffer>
          (marker-position m)
               => nil
          (marker-buffer m)
               => nil
          
          (set-marker m 3770 (current-buffer))
               => #<marker at 3770 in markers.texi>
          (marker-buffer m)
               => #<buffer markers.texi>
          (marker-position m)
               => 3770

   Two distinct markers are considered `equal' (even though not `eq')
to each other if they have the same position and buffer, or if they
both point nowhere.


File: lispref.info,  Node: Changing Markers,  Next: The Mark,  Prev: Information from Markers,  Up: Markers

Changing Marker Positions
=========================

   This section describes how to change the position of an existing
marker.  When you do this, be sure you know whether the marker is used
outside of your program, and, if so, what effects will result from
moving it--otherwise, confusing things may happen in other parts of
Emacs.

 - Function: set-marker marker position &optional buffer
     This function moves MARKER to POSITION in BUFFER.  If BUFFER is
     not provided, it defaults to the current buffer.

     POSITION can be a marker, an integer or `nil'.  If POSITION is an
     integer, `set-marker' moves MARKER to point before the POSITIONth
     character in BUFFER.  If POSITION is `nil', MARKER is made to
     point nowhere.  Then it no longer slows down editing in any
     buffer.  If POSITION is less than 1, MARKER is moved to the
     beginning of BUFFER.  If POSITION is greater than the size of
     BUFFER, MARKER is moved to the end of BUFFER.

     The value returned is MARKER.

          (setq m (point-marker))
               => #<marker at 4714 in markers.texi>
          (set-marker m 55)
               => #<marker at 55 in markers.texi>
          (setq b (get-buffer "foo"))
               => #<buffer foo>
          (set-marker m 0 b)
               => #<marker at 1 in foo>

 - Function: move-marker marker position &optional buffer
     This is another name for `set-marker'.


File: lispref.info,  Node: The Mark,  Next: The Region,  Prev: Changing Markers,  Up: Markers

The Mark
========

   One special marker in each buffer is designated "the mark".  It
records a position for the user for the sake of commands such as `C-w'
and `C-x <TAB>'.  Lisp programs should set the mark only to values that
have a potential use to the user, and never for their own internal
purposes.  For example, the `replace-regexp' command sets the mark to
the value of point before doing any replacements, because this enables
the user to move back there conveniently after the replace is finished.

   Once the mark "exists" in a buffer, it normally never ceases to
exist.  However, it may become "inactive", and usually does so after
each command (other than simple motion commands and some commands that
explicitly activate the mark).  When the mark is active, the region
between point and the mark is called the "active region" and is
highlighted specially.

   Many commands are designed so that when called interactively they
operate on the text between point and the mark.  Such commands work
only when an active region exists, i.e. when the mark is active.  (The
reason for this is to prevent you from accidentally deleting or
changing large chunks of your text.) If you are writing such a command,
don't examine the mark directly; instead, use `interactive' with the
`r' specification.  This provides the values of point and the mark as
arguments to the command in an interactive call, but permits other Lisp
programs to specify arguments explicitly, and automatically signals an
error if the command is called interactively when no active region
exists.  *Note Interactive Codes::.

   Each buffer has its own value of the mark that is independent of the
value of the mark in other buffers. (When a buffer is created, the mark
exists but does not point anywhere.  We consider this state as "the
absence of a mark in that buffer.") However, only one active region can
exist at a time.  Activating the mark in one buffer automatically
deactivates an active mark in any other buffer.  Note that the user can
explicitly activate a mark at any time by using the command
`activate-region' (normally bound to `M-C-z') or by using the command
`exchange-point-and-mark' (normally bound to `C-x C-x'), which has the
side effect of activating the mark.

   Some people do not like active regions, so they disable this behavior
by setting the variable `zmacs-regions' to `nil'.  This makes the mark
always active (except when a buffer is just created and the mark points
nowhere), and turns off the highlighting of the region between point
and the mark.  Commands that explicitly retrieve the value of the mark
should make sure that they behave correctly and consistently
irrespective of the setting of `zmacs-regions'; some primitives are
provided to ensure this behavior.

   In addition to the mark, each buffer has a "mark ring" which is a
list of markers containing previous values of the mark.  When editing
commands change the mark, they should normally save the old value of the
mark on the mark ring.  The variable `mark-ring-max' specifies the
maximum number of entries in the mark ring; once the list becomes this
long, adding a new element deletes the last element.

 - Function: mark &optional force buffer
     This function returns BUFFER's mark position as an integer.
     BUFFER defaults to the current buffer if omitted.

     If the mark is inactive, `mark' normally returns `nil'.  However,
     if FORCE is non-`nil', then `mark' returns the mark position
     anyway--or `nil', if the mark is not yet set for the buffer.

     (Remember that if ZMACS-REGIONS is `nil', the mark is always
     active as long as it exists, and the FORCE argument will have no
     effect.)

     If you are using this in an editing command, you are most likely
     making a mistake; see the documentation of `set-mark' below.

 - Function: mark-marker &optional force buffer
     This function returns BUFFER's mark.  BUFFER defaults to the
     current buffer if omitted.  This is the very marker that records
     the mark location inside XEmacs, not a copy.  Therefore, changing
     this marker's position will directly affect the position of the
     mark.  Don't do it unless that is the effect you want.

     If the mark is inactive, `mark-marker' normally returns `nil'.
     However, if FORCE is non-`nil', then `mark-marker' returns the
     mark anyway.
          (setq m (mark-marker))
               => #<marker at 3420 in markers.texi>
          (set-marker m 100)
               => #<marker at 100 in markers.texi>
          (mark-marker)
               => #<marker at 100 in markers.texi>

     Like any marker, this marker can be set to point at any buffer you
     like.  We don't recommend that you make it point at any buffer
     other than the one of which it is the mark.  If you do, it will
     yield perfectly consistent, but rather odd, results.

 - Function: set-mark position &optional buffer
     This function sets `buffer''s mark to POSITION, and activates the
     mark.  BUFFER defaults to the current buffer if omitted.  The old
     value of the mark is _not_ pushed onto the mark ring.

     *Please note:* Use this function only if you want the user to see
     that the mark has moved, and you want the previous mark position to
     be lost.  Normally, when a new mark is set, the old one should go
     on the `mark-ring'.  For this reason, most applications should use
     `push-mark' and `pop-mark', not `set-mark'.

     Novice XEmacs Lisp programmers often try to use the mark for the
     wrong purposes.  The mark saves a location for the user's
     convenience.  An editing command should not alter the mark unless
     altering the mark is part of the user-level functionality of the
     command.  (And, in that case, this effect should be documented.)
     To remember a location for internal use in the Lisp program, store
     it in a Lisp variable.  For example:

          (let ((start (point)))
            (forward-line 1)
            (delete-region start (point))).

 - Command: exchange-point-and-mark &optional dont-activate-region
     This function exchanges the positions of point and the mark.  It
     is intended for interactive use.  The mark is also activated
     unless DONT-ACTIVATE-REGION is non-`nil'.

 - Function: push-mark &optional position nomsg activate buffer
     This function sets BUFFER's mark to POSITION, and pushes a copy of
     the previous mark onto `mark-ring'.  BUFFER defaults to the
     current buffer if omitted.  If POSITION is `nil', then the value
     of point is used.  `push-mark' returns `nil'.

     If the last global mark pushed was not in BUFFER, also push
     POSITION on the global mark ring (see below).

     The function `push-mark' normally _does not_ activate the mark.
     To do that, specify `t' for the argument ACTIVATE.

     A `Mark set' message is displayed unless NOMSG is non-`nil'.

 - Function: pop-mark
     This function pops off the top element of `mark-ring' and makes
     that mark become the buffer's actual mark.  This does not move
     point in the buffer, and it does nothing if `mark-ring' is empty.
     It deactivates the mark.

     The return value is not meaningful.

 - Variable: mark-ring
     The value of this buffer-local variable is the list of saved former
     marks of the current buffer, most recent first.

          mark-ring
          => (#<marker at 11050 in markers.texi>
              #<marker at 10832 in markers.texi>
              ...)

 - User Option: mark-ring-max
     The value of this variable is the maximum size of `mark-ring'.  If
     more marks than this are pushed onto the `mark-ring', `push-mark'
     discards an old mark when it adds a new one.

   In additional to a per-buffer mark ring, there is a "global mark
ring".  Marks are pushed onto the global mark ring the first time you
set a mark after switching buffers.

 - Variable: global-mark-ring
     The value of this variable is the list of saved former global
     marks, most recent first.

 - User Option: mark-ring-max
     The value of this variable is the maximum size of
     `global-mark-ring'.  If more marks than this are pushed onto the
     `global-mark-ring', `push-mark' discards an old mark when it adds
     a new one.

 - Command: pop-global-mark
     This function pops a mark off the global mark ring and jumps to
     that location.

