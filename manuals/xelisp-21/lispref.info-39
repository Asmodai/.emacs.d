This is ../info/lispref.info, produced by makeinfo version 4.3 from
lispref/lispref.texi.

INFO-DIR-SECTION XEmacs Editor
START-INFO-DIR-ENTRY
* Lispref: (lispref).		XEmacs Lisp Reference Manual.
END-INFO-DIR-ENTRY

   Edition History:

   GNU Emacs Lisp Reference Manual Second Edition (v2.01), May 1993 GNU
Emacs Lisp Reference Manual Further Revised (v2.02), August 1993 Lucid
Emacs Lisp Reference Manual (for 19.10) First Edition, March 1994
XEmacs Lisp Programmer's Manual (for 19.12) Second Edition, April 1995
GNU Emacs Lisp Reference Manual v2.4, June 1995 XEmacs Lisp
Programmer's Manual (for 19.13) Third Edition, July 1995 XEmacs Lisp
Reference Manual (for 19.14 and 20.0) v3.1, March 1996 XEmacs Lisp
Reference Manual (for 19.15 and 20.1, 20.2, 20.3) v3.2, April, May,
November 1997 XEmacs Lisp Reference Manual (for 21.0) v3.3, April 1998

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995 Free Software
Foundation, Inc.  Copyright (C) 1994, 1995 Sun Microsystems, Inc.
Copyright (C) 1995, 1996 Ben Wing.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: lispref.info,  Node: Image Specifiers,  Next: Image Instantiator Conversion,  Up: Images

Image Specifiers
----------------

   An image specifier is used to describe the actual image of a glyph.
It works like other specifiers (*note Specifiers::), in that it contains
a number of specifications describing how the image should appear in a
variety of circumstances.  These specifications are called "image
instantiators".  When XEmacs wants to display the image, it instantiates
the image into an "image instance".  Image instances are their own
primitive object type (similar to font instances and color instances),
describing how the image appears in a particular domain. (On the other
hand, image instantiators, which are just descriptions of how the image
should appear, are represented using strings or vectors.)

 - Function: image-specifier-p object
     This function returns non-`nil' if OBJECT is an image specifier.
     Usually, an image specifier results from calling `glyph-image' on
     a glyph.

 - Function: make-image-specifier spec-list
     This function creates a new image specifier object and initializes
     it according to SPEC-LIST. *Note Specifiers::.

     Note that, in practice, you rarely, if ever, need to actually
     create an image specifier! (This function exists mainly for
     completeness.) Pretty much the only use for image specifiers is to
     control how glyphs are displayed, and the image specifier
     associated with a glyph (the `image' property of a glyph) is
     created automatically when a glyph is created and need not (and
     cannot, for that matter) ever be changed (*note Glyphs::).  In
     fact, the design decision to create a separate image specifier
     type, rather than make glyphs themselves be specifiers, is
     debatable--the other properties of glyphs are rarely used and could
     conceivably have been incorporated into the glyph's instantiator.
     The rarely used glyph types (buffer, pointer, icon) could also
     have been incorporated into the instantiator.

   Image instantiators come in many formats: `xbm', `xpm', `gif',
`jpeg', etc.  This describes the format of the data describing the
image.  The resulting image instances also come in many
types--`mono-pixmap', `color-pixmap', `text', `pointer', etc.  This
refers to the behavior of the image and the sorts of places it can
appear. (For example, a color-pixmap image has fixed colors specified
for it, while a mono-pixmap image comes in two unspecified shades
"foreground" and "background" that are determined from the face of the
glyph or surrounding text; a text image appears as a string of text and
has an unspecified foreground, background, and font; a pointer image
behaves like a mono-pixmap image but can only be used as a mouse
pointer [mono-pixmap images cannot be used as mouse pointers]; etc.) It
is important to keep the distinction between image instantiator format
and image instance type in mind.  Typically, a given image instantiator
format can result in many different image instance types (for example,
`xpm' can be instanced as `color-pixmap', `mono-pixmap', or `pointer';
whereas `cursor-font' can be instanced only as `pointer'), and a
particular image instance type can be generated by many different image
instantiator formats (e.g.  `color-pixmap' can be generated by `xpm',
`gif', `jpeg', etc.).

   *Note Image Instances::, for a more detailed discussion of image
instance types.

   An image instantiator should be a string or a vector of the form

      `[FORMAT :KEYWORD VALUE ...]'

   i.e. a format symbol followed by zero or more alternating
keyword-value pairs.  The "format" field should be a symbol, one of

`nothing'
     Don't display anything; no keywords are valid for this.  Can only
     be instanced as `nothing'.

`string'
     Display this image as a text string.  Can only be instanced as
     `text', although support for instancing as `mono-pixmap' should be
     added.

`formatted-string'
     Display this image as a text string with replaceable fields,
     similar to a modeline format string; not currently implemented.

`xbm'
     An X bitmap; only if X support was compiled into this XEmacs.  Can
     be instanced as `mono-pixmap', `color-pixmap', or `pointer'.

`xpm'
     An XPM pixmap; only if XPM support was compiled into this XEmacs.
     Can be instanced as `color-pixmap', `mono-pixmap', or `pointer'.
     XPM is an add-on library for X that was designed to rectify the
     shortcomings of the XBM format.  Most implementations of X include
     the XPM library as a standard part.  If your vendor does not, it
     is highly recommended that you download it and install it.  You
     can get it from the standard XEmacs FTP site, among other places.

`xface'
     An X-Face bitmap, used to encode people's faces in e-mail messages;
     only if X-Face support was compiled into this XEmacs.  Can be
     instanced as `mono-pixmap', `color-pixmap', or `pointer'.

`gif'
     A GIF87 or GIF89 image; only if GIF support was compiled into this
     XEmacs.  Can be instanced as `color-pixmap'.  Note that XEmacs
     includes GIF decoding functions as a standard part of it, so if
     you have X support, you will normally have GIF support, unless you
     explicitly disable it at configure time.

`jpeg'
     A JPEG-format image; only if JPEG support was compiled into this
     XEmacs.  Can be instanced as `color-pixmap'.  If you have the JPEG
     libraries present on your system when XEmacs is built, XEmacs will
     automatically detect this and use them, unless you explicitly
     disable it at configure time.

`png'
     A PNG/GIF24 image; only if PNG support was compiled into this
     XEmacs.  Can be instanced as `color-pixmap'.

`tiff'
     A TIFF-format image; only if TIFF support was compiled into this
     XEmacs.

`cursor-font'
     One of the standard cursor-font names, such as `watch' or
     `right_ptr' under X.  Under X, this is, more specifically, any of
     the standard cursor names from appendix B of the Xlib manual [also
     known as the file `<X11/cursorfont.h>'] minus the `XC_' prefix.  On
     other window systems, the valid names will be specific to the type
     of window system.  Can only be instanced as `pointer'.

`font'
     A glyph from a font; i.e. the name of a font, and glyph index into
     it of the form `FONT fontname index [[mask-font] mask-index]'.
     Only if X support was compiled into this XEmacs.  Currently can
     only be instanced as `pointer', although this should probably be
     fixed.

`mswindows-resource'
     An MS Windows pointer resource.  Specifies a resource to retrieve
     directly from the system (an OEM resource) or from a file,
     particularly an executable file.  If the resource is to be
     retrieved from a file, use :file and optionally :resource-id.
     Otherwise use :resource-id.  Always specify :resource-type to
     specify the type (cursor, bitmap or icon) of the resource.
     Possible values for :resource-id are listed below.  Can be
     instanced as `pointer' or `color-pixmap'.

`subwindow'
     An embedded windowing system window.  Can only be instanced as
     `subwindow'.

`button'
     A button widget; either a push button, radio button or toggle
     button.  Can only be instanced as `widget'.

`combo-box'
     A drop list of selectable items in a widget, for editing text.
     Can only be instanced as `widget'.

`edit-field'
     A text editing widget.  Can only be instanced as `widget'.

`label'
     A static, text-only, widget; for displaying text.  Can only be
     instanced as `widget'.

`layout'
     A widget for controlling the positioning of children underneath it.
     Through the use of nested layouts, a widget hierarchy can be
     created which can have the appearance of any standard dialog box
     or similar arrangement; all of this is counted as one "glyph" and
     could appear in many of the places that expect a single glyph.
     Can only be instanced as `widget'.

`native-layout'
     The native version of a layout widget.  Can only be instanced as
     `widget'.

`progress-gauge'
     A sliding widget, for showing progress.  Can only be instanced as
     `widget'.

`tab-control'
     A tab widget; a series of user selectable tabs.  Can only be
     instanced as `widget'.

`tree-view'
     A folding widget.  Can only be instanced as `widget'.

`scrollbar'
     A scrollbar widget.  Can only be instanced as `widget'.

`autodetect'
     XEmacs tries to guess what format the data is in.  If X support
     exists, the data string will be checked to see if it names a
     filename.  If so, and this filename contains XBM or XPM data, the
     appropriate sort of pixmap or pointer will be created. [This
     includes picking up any specified hotspot or associated mask
     file.] Otherwise, if `pointer' is one of the allowable
     image-instance types and the string names a valid cursor-font
     name, the image will be created as a pointer.  Otherwise, the
     image will be displayed as text.  If no X support exists, the
     image will always be displayed as text.

`inherit'
     Inherit from the background-pixmap property of a face.  Can only be
     instanced as `mono-pixmap'.

   The valid keywords are:

`:data'
     Inline data.  For most formats above, this should be a string.  For
     XBM images, this should be a list of three elements: width,
     height, and a string of bit data.  This keyword is not valid for
     instantiator format `nothing'.

`:file'
     Data is contained in a file.  The value is the name of this file.
     If both `:data' and `:file' are specified, the image is created
     from what is specified in `:data' and the string in `:file'
     becomes the value of the `image-instance-file-name' function when
     applied to the resulting image-instance.  This keyword is not
     valid for instantiator formats `nothing', `string',
     `formatted-string', `cursor-font', `font', and `autodetect'.

`:foreground'
`:background'
     For `xbm', `xface', `cursor-font', and `font'.  These keywords
     allow you to explicitly specify foreground and background colors.
     The argument should be anything acceptable to
     `make-color-instance'.  This will cause what would be a
     `mono-pixmap' to instead be colorized as a two-color color-pixmap,
     and specifies the foreground and/or background colors for a pointer
     instead of black and white.

`:mask-data'
     For `xbm' and `xface'.  This specifies a mask to be used with the
     bitmap.  The format is a list of width, height, and bits, like for
     `:data'.

`:mask-file'
     For `xbm' and `xface'.  This specifies a file containing the mask
     data.  If neither a mask file nor inline mask data is given for an
     XBM image, and the XBM image comes from a file, XEmacs will look
     for a mask file with the same name as the image file but with
     `Mask' or `msk' appended.  For example, if you specify the XBM file
     `left_ptr' [usually located in `/usr/include/X11/bitmaps'], the
     associated mask file `left_ptrmsk' will automatically be picked up.

`:hotspot-x'
`:hotspot-y'
     For `xbm' and `xface'.  These keywords specify a hotspot if the
     image is instantiated as a `pointer'.  Note that if the XBM image
     file specifies a hotspot, it will automatically be picked up if no
     explicit hotspot is given.

`:color-symbols'
     Only for `xpm'.  This specifies an alist that maps strings that
     specify symbolic color names to the actual color to be used for
     that symbolic color (in the form of a string or a color-specifier
     object).  If this is not specified, the contents of
     `xpm-color-symbols' are used to generate the alist.

`:resource-id'
     Only for `mswindows-resource'.  This must be either an integer
     (which directly specifies a resource number) or a string.  Valid
     strings are

     For bitmaps:

     "close", "uparrow", "dnarrow", "rgarrow", "lfarrow", "reduce",
     "zoom", "restore", "reduced", "zoomd", "restored", "uparrowd",
     "dnarrowd", "rgarrowd", "lfarrowd", "mnarrow", "combo",
     "uparrowi", "dnarrowi", "rgarrowi", "lfarrowi", "size", "btsize",
     "check", "checkboxes", and "btncorners".

     For cursors:

     "normal", "ibeam", "wait", "cross", "up", "sizenwse", "sizenesw",
     "sizewe", "sizens", "sizeall", and "no".

     For icons:

     "sample", "hand", "ques", "bang", "note", and "winlogo".

`:resource-type'
     Only for `mswindows-resource'.  This must be a symbol, either
     `cursor', `icon', or `bitmap', specifying the type of resource to
     be retrieved.

`:face'
     Only for `inherit'.  This specifies the face to inherit from.  For
     widgets this also specifies the face to use for display. It
     defaults to gui-element-face.

   Keywords accepted as menu item specs are also accepted by widgets.
These are `:selected', `:active', `:suffix', `:keys', `:style',
`:filter', `:config', `:included', `:key-sequence', `:accelerator',
`:label' and `:callback'.

   If instead of a vector, the instantiator is a string, it will be
converted into a vector by looking it up according to the specs in the
`console-type-image-conversion-list' for the console type of the domain
(usually a window; sometimes a frame or device) over which the image is
being instantiated.

   If the instantiator specifies data from a file, the data will be
read in at the time that the instantiator is added to the image
specifier (which may be well before the image is actually displayed),
and the instantiator will be converted into one of the inline-data
forms, with the filename retained using a `:file' keyword.  This
implies that the file must exist when the instantiator is added to the
image, but does not need to exist at any other time (e.g. it may safely
be a temporary file).

 - Function: valid-image-instantiator-format-p format &optional locale
     This function returns non-`nil' if FORMAT is a valid image
     instantiator format.

     If LOCALE is non-`nil' then the format is checked in that locale.
     If LOCALE is `nil' the current console is used.

     Note that the return value for many formats listed above depends on
     whether XEmacs was compiled with support for that format.

 - Function: image-instantiator-format-list
     This function return a list of valid image-instantiator formats.

 - Variable: xpm-color-symbols
     This variable holds definitions of logical color-names used when
     reading XPM files.  Elements of this list should be of the form
     `(COLOR-NAME FORM-TO-EVALUATE)'.  The COLOR-NAME should be a
     string, which is the name of the color to define; the
     FORM-TO-EVALUATE should evaluate to a color specifier object, or a
     string to be passed to `make-color-instance' (*note Colors::).  If
     a loaded XPM file references a symbolic color called COLOR-NAME,
     it will display as the computed color instead.

     The default value of this variable defines the logical color names
     `"foreground"' and `"background"' to be the colors of the
     `default' face.

 - Variable: x-bitmap-file-path
     A list of the directories in which X bitmap files may be found.
     If `nil', this is initialized from the `"*bitmapFilePath"'
     resource.  This is used by the `make-image-instance' function
     (however, note that if the environment variable `XBMLANGPATH' is
     set, it is consulted first).


File: lispref.info,  Node: Image Instantiator Conversion,  Next: Image Instances,  Prev: Image Specifiers,  Up: Images

Image Instantiator Conversion
-----------------------------

 - Function: set-console-type-image-conversion-list console-type list
     This function sets the image-conversion-list for consoles of the
     given CONSOLE-TYPE.  The image-conversion-list specifies how image
     instantiators that are strings should be interpreted.  Each
     element of the list should be a list of two elements (a regular
     expression string and a vector) or a list of three elements (the
     preceding two plus an integer index into the vector).  The string
     is converted to the vector associated with the first matching
     regular expression.  If a vector index is specified, the string
     itself is substituted into that position in the vector.

     Note: The conversion above is applied when the image instantiator
     is added to an image specifier, not when the specifier is actually
     instantiated.  Therefore, changing the image-conversion-list only
     affects newly-added instantiators.  Existing instantiators in
     glyphs and image specifiers will not be affected.

 - Function: console-type-image-conversion-list console-type
     This function returns the image-conversion-list for consoles of
     the given CONSOLE-TYPE.


File: lispref.info,  Node: Image Instances,  Prev: Image Instantiator Conversion,  Up: Images

Image Instances
---------------

   Image-instance objects encapsulate the way a particular image
(pixmap, etc.) is displayed on a particular device.

   In most circumstances, you do not need to directly create image
instances; use a glyph instead.  However, it may occasionally be useful
to explicitly create image instances, if you want more control over the
instantiation process.

 - Function: image-instance-p object
     This function returns non-`nil' if OBJECT is an image instance.

* Menu:

* Image Instance Types::         Each image instances has a particular type.
* Image Instance Functions::	 Functions for working with image instances.


File: lispref.info,  Node: Image Instance Types,  Next: Image Instance Functions,  Up: Image Instances

Image Instance Types
....................

   Image instances come in a number of different types.  The type of an
image instance specifies the nature of the image: Whether it is a text
string, a mono pixmap, a color pixmap, etc.

   The valid image instance types are

`nothing'
     Nothing is displayed.

`text'
     Displayed as text.  The foreground and background colors and the
     font of the text are specified independent of the pixmap.
     Typically these attributes will come from the face of the
     surrounding text, unless a face is specified for the glyph in
     which the image appears.

`mono-pixmap'
     Displayed as a mono pixmap (a pixmap with only two colors where the
     foreground and background can be specified independent of the
     pixmap; typically the pixmap assumes the foreground and background
     colors of the text around it, unless a face is specified for the
     glyph in which the image appears).

`color-pixmap'
     Displayed as a color pixmap.

`pointer'
     Used as the mouse pointer for a window.

`subwindow'
     A child window that is treated as an image.  This allows (e.g.)
     another program to be responsible for drawing into the window.
     Not currently implemented.

 - Function: valid-image-instance-type-p type
     This function returns non-`nil' if TYPE is a valid image instance
     type.

 - Function: image-instance-type-list
     This function returns a list of the valid image instance types.

 - Function: image-instance-type image-instance
     This function returns the type of the given image instance.  The
     return value will be one of `nothing', `text', `mono-pixmap',
     `color-pixmap', `pointer', or `subwindow'.

 - Function: text-image-instance-p object
     This function returns non-`nil' if OBJECT is an image instance of
     type `text'.

 - Function: mono-pixmap-image-instance-p object
     This function returns non-`nil' if OBJECT is an image instance of
     type `mono-pixmap'.

 - Function: color-pixmap-image-instance-p object
     This function returns non-`nil' if OBJECT is an image instance of
     type `color-pixmap'.

 - Function: pointer-image-instance-p object
     This function returns non-`nil' if OBJECT is an image instance of
     type `pointer'.

 - Function: subwindow-image-instance-p object
     This function returns non-`nil' if OBJECT is an image instance of
     type `subwindow'.

 - Function: nothing-image-instance-p object
     This function returns non-`nil' if OBJECT is an image instance of
     type `nothing'.

 - Function: widget-image-instance-p object
     Return `t' if OBJECT is an image instance of type `widget'.


File: lispref.info,  Node: Image Instance Functions,  Prev: Image Instance Types,  Up: Image Instances

Image Instance Functions
........................

 - Function: make-image-instance data &optional domain dest-types
          noerror
     This function creates a new image-instance object.

     DATA is an image instantiator, which describes the image (*note
     Image Specifiers::).

     DEST-TYPES should be a list of allowed image instance types that
     can be generated.  The DEST-TYPES list is unordered.  If multiple
     destination types are possible for a given instantiator, the "most
     natural" type for the instantiator's format is chosen. (For XBM,
     the most natural types are `mono-pixmap', followed by
     `color-pixmap', followed by `pointer'.  For the other normal image
     formats, the most natural types are `color-pixmap', followed by
     `mono-pixmap', followed by `pointer'.  For the string and
     formatted-string formats, the most natural types are `text',
     followed by `mono-pixmap' (not currently implemented), followed by
     `color-pixmap' (not currently implemented).  For MS Windows
     resources, the most natural type for pointer resources is
     `pointer', and for the others it's `color-pixmap'.  The other
     formats can only be instantiated as one type. (If you want to
     control more specifically the order of the types into which an
     image is instantiated, just call `make-image-instance' repeatedly
     until it succeeds, passing less and less preferred destination
     types each time.

     If DEST-TYPES is omitted, all possible types are allowed.

     DOMAIN specifies the domain to which the image instance will be
     attached.  This domain is termed the "governing domain".  The type
     of the governing domain depends on the image instantiator format.
     (Although, more correctly, it should probably depend on the image
     instance type.) For example, pixmap image instances are specific
     to a device, but widget image instances are specific to a
     particular XEmacs window because in order to display such a widget
     when two windows onto the same buffer want to display the widget,
     two separate underlying widgets must be created. (That's because a
     widget is actually a child window-system window, and all
     window-system windows have a unique existence on the screen.) This
     means that the governing domain for a pixmap image instance will
     be some device (most likely, the only existing device), whereas
     the governing domain for a widget image instance will be some
     XEmacs window.

     If you specify an overly general DOMAIN (e.g. a frame when a
     window was wanted), an error is signaled.  If you specify an overly
     specific DOMAIN (e.g. a window when a device was wanted), the
     corresponding general domain is fetched and used instead.  For
     `make-image-instance', it makes no difference whether you specify
     an overly specific domain or the properly general domain derived
     from it.  However, it does matter when creating an image instance
     by instantiating a specifier or glyph (e.g. with
     `glyph-image-instance'), because the more specific domain causes
     spec lookup to start there and proceed to more general domains. (It
     would also matter when creating an image instance with an
     instantiator format of `inherit', but we currently disallow this.
     #### We should fix this.)  n If omitted, DOMAIN defaults to the
     selected window.

     NOERROR controls what happens when the image cannot be generated.
     If `nil', an error message is generated.  If `t', no messages are
     generated and this function returns `nil'.  If anything else, a
     warning message is generated and this function returns `nil'.

 - Function: colorize-image-instance image-instance foreground
          background
     This function makes the image instance be displayed in the given
     colors.  Image instances come in two varieties: bitmaps, which are
     1 bit deep which are rendered in the prevailing foreground and
     background colors; and pixmaps, which are of arbitrary depth
     (including 1) and which have the colors explicitly specified.
     This function converts a bitmap to a pixmap.  If the image
     instance was a pixmap already, nothing is done (and `nil' is
     returned).  Otherwise `t' is returned.

 - Function: image-instance-name image-instance
     This function returns the name of the given image instance.

 - Function: image-instance-domain image-instance
     Return the governing domain of the given IMAGE-INSTANCE.  The
     governing domain of an image instance is the domain that the image
     instance is specific to.  It is _NOT_ necessarily the domain that
     was given to the call to `specifier-instance' that resulted in the
     creation of this image instance.  See `make-image-instance' for
     more information on governing domains.

 - Function: image-instance-string image-instance
     This function returns the string of the given image instance.
     This will only be non-`nil' for text image instances.

 - Function: image-instance-file-name image-instance
     This function returns the file name from which IMAGE-INSTANCE was
     read, if known.

 - Function: image-instance-mask-file-name image-instance
     This function returns the file name from which IMAGE-INSTANCE's
     mask was read, if known.

 - Function: image-instance-depth image-instance
     This function returns the depth of the image instance.  This is 0
     for a mono pixmap, or a positive integer for a color pixmap.

 - Function: image-instance-height image-instance
     This function returns the height of the image instance, in pixels.

 - Function: image-instance-width image-instance
     This function returns the width of the image instance, in pixels.

 - Function: image-instance-hotspot-x image-instance
     This function returns the X coordinate of the image instance's
     hotspot, if known.  This is a point relative to the origin of the
     pixmap.  When an image is used as a mouse pointer, the hotspot is
     the point on the image that sits over the location that the
     pointer points to.  This is, for example, the tip of the arrow or
     the center of the crosshairs.

     This will always be `nil' for a non-pointer image instance.

 - Function: image-instance-hotspot-y image-instance
     This function returns the Y coordinate of the image instance's
     hotspot, if known.

 - Function: image-instance-foreground image-instance
     This function returns the foreground color of IMAGE-INSTANCE, if
     applicable.  This will be a color instance or `nil'. (It will only
     be non-`nil' for colorized mono pixmaps and for pointers.)

 - Function: image-instance-background image-instance
     This function returns the background color of IMAGE-INSTANCE, if
     applicable.  This will be a color instance or `nil'. (It will only
     be non-`nil' for colorized mono pixmaps and for pointers.)


File: lispref.info,  Node: Glyph Types,  Next: Mouse Pointer,  Prev: Images,  Up: Glyphs

Glyph Types
===========

   Each glyph has a particular type, which controls how the glyph's
image is generated.  Each glyph type has a corresponding list of
allowable image instance types that can be generated.  When you call
`glyph-image-instance' to retrieve the image instance of a glyph,
XEmacs does the equivalent of calling `make-image-instance' and passing
in DEST-TYPES the list of allowable image instance types for the
glyph's type.

   * `buffer' glyphs can be used as the begin-glyph or end-glyph of an
     extent, in the modeline, and in the toolbar.  Their image can be
     instantiated as `nothing', `mono-pixmap', `color-pixmap', `text',
     and `subwindow'.

   * `pointer' glyphs can be used to specify the mouse pointer.  Their
     image can be instantiated as `pointer'.

   * `icon' glyphs can be used to specify the icon used when a frame is
     iconified.  Their image can be instantiated as `mono-pixmap' and
     `color-pixmap'.

 - Function: glyph-type glyph
     This function returns the type of the given glyph.  The return
     value will be a symbol, one of `buffer', `pointer', or `icon'.

 - Function: valid-glyph-type-p glyph-type
     Given a GLYPH-TYPE, this function returns non-`nil' if it is valid.

 - Function: glyph-type-list
     This function returns a list of valid glyph types.

 - Function: buffer-glyph-p object
     This function returns non-`nil' if OBJECT is a glyph of type
     `buffer'.

 - Function: icon-glyph-p object
     This function returns non-`nil' if OBJECT is a glyph of type
     `icon'.

 - Function: pointer-glyph-p object
     This function returns non-`nil' if OBJECT is a glyph of type
     `pointer'.


File: lispref.info,  Node: Mouse Pointer,  Next: Redisplay Glyphs,  Prev: Glyph Types,  Up: Glyphs

Mouse Pointer
=============

   The shape of the mouse pointer when over a particular section of a
frame is controlled using various glyph variables.  Since the image of
a glyph is a specifier, it can be controlled on a per-buffer,
per-frame, per-window, or per-device basis.

   You should use `set-glyph-image' to set the following variables,
_not_ `setq'.

 - Glyph: text-pointer-glyph
     This variable specifies the shape of the mouse pointer when over
     text.

 - Glyph: nontext-pointer-glyph
     This variable specifies the shape of the mouse pointer when over a
     buffer, but not over text.  If unspecified in a particular domain,
     `text-pointer-glyph' is used.

 - Glyph: modeline-pointer-glyph
     This variable specifies the shape of the mouse pointer when over
     the modeline.  If unspecified in a particular domain,
     `nontext-pointer-glyph' is used.

 - Glyph: selection-pointer-glyph
     This variable specifies the shape of the mouse pointer when over a
     selectable text region.  If unspecified in a particular domain,
     `text-pointer-glyph' is used.

 - Glyph: gc-pointer-glyph
     This variable specifies the shape of the mouse pointer when a
     garbage collection is in progress.  If the selected window is on a
     window system and this glyph specifies a value (i.e. a pointer
     image instance) in the domain of the selected window, the pointer
     will be changed as specified during garbage collection.
     Otherwise, a message will be printed in the echo area, as
     controlled by `gc-message'.

 - Glyph: busy-pointer-glyph
     This variable specifies the shape of the mouse pointer when XEmacs
     is busy.  If unspecified in a particular domain, the pointer is
     not changed when XEmacs is busy.

 - Glyph: menubar-pointer-glyph
     This variable specifies the shape of the mouse pointer when over
     the menubar.  If unspecified in a particular domain, the
     window-system-provided default pointer is used.

 - Glyph: scrollbar-pointer-glyph
     This variable specifies the shape of the mouse pointer when over a
     scrollbar.  If unspecified in a particular domain, the
     window-system-provided default pointer is used.

 - Glyph: toolbar-pointer-glyph
     This variable specifies the shape of the mouse pointer when over a
     toolbar.  If unspecified in a particular domain,
     `nontext-pointer-glyph' is used.

   Internally, these variables are implemented in
`default-mouse-motion-handler', and thus only take effect when the
mouse moves.  That function calls `set-frame-pointer', which sets the
current mouse pointer for a frame.

 - Function: set-frame-pointer frame image-instance
     This function sets the mouse pointer of FRAME to the given pointer
     image instance.  You should not call this function directly.  (If
     you do, the pointer will change again the next time the mouse
     moves.)


File: lispref.info,  Node: Redisplay Glyphs,  Next: Subwindows,  Prev: Mouse Pointer,  Up: Glyphs

Redisplay Glyphs
================

 - Glyph: truncation-glyph
     This variable specifies what is displayed at the end of truncated
     lines.

 - Glyph: continuation-glyph
     This variable specifies what is displayed at the end of wrapped
     lines.

 - Glyph: octal-escape-glyph
     This variable specifies what to prefix character codes displayed
     in octal with.

 - Glyph: hscroll-glyph
     This variable specifies what to display at the beginning of
     horizontally scrolled lines.

 - Glyph: invisible-text-glyph
     This variable specifies what to use to indicate the presence of
     invisible text.  This is the glyph that is displayed when an
     ellipsis is called for, according to `selective-display-ellipses'
     or `buffer-invisibility-spec').  Normally this is three dots
     ("...").

 - Glyph: control-arrow-glyph
     This variable specifies what to use as an arrow for control
     characters.


File: lispref.info,  Node: Subwindows,  Next: Glyph Examples,  Prev: Redisplay Glyphs,  Up: Glyphs

Subwindows
==========

   Subwindows are not currently implemented.

 - Function: subwindowp object
     This function returns non-`nil' if OBJECT is a subwindow.


File: lispref.info,  Node: Glyph Examples,  Prev: Subwindows,  Up: Glyphs

Glyph Examples
==============

   For many applications, displaying graphics is a simple process: you
create a glyph, and then you insert it into a buffer.

   The easiest way to create a glyph is to use a file that contains a
graphical image, such as a JPEG, TIFF, or PNG file:

     ;; Create a glyph from a JPEG file:
     (setq foo (make-glyph [jpeg :file "/tmp/file1.jpg"]))

     ;; Create a glyph from a XPM file:
     (setq foo (make-glyph [xpm :file "/tmp/file2.xpm"]))

     ;; Create a glyph from a PNG file:
     (setq foo (make-glyph [png :file "/tmp/file3.png"]))

     ;; Create a glyph from a TIFF file:
     (setq foo (make-glyph [tiff :file "/tmp/file4.tiff"]))

   The parameters passed to `make-glyph' are called "Image Specifiers",
and can handle more image types than those shown above.  You can also
put the raw image data into a string (e.g., if you put the contents of
a JPEG file into a string), and use that to create a glyph.  *Note
Image Specifiers::, for more information.

     *Caution*: In order for XEmacs to read a particular graphics file
     format, support for that format must have been compiled into
     XEmacs.  It's possible, although somewhat unlikely, for XEmacs to
     have been compiled without support for any of the various graphics
     file formats.  To see what graphics formats your particular
     version of XEmacs supports, use `M-x describe-installation'.

     To programmatically query whether or not a particular file format
     is supported, you can use the `featurep' function, with one of:
     `gif', `tiff', `jpeg', `xpm', `xbm', `png', or `xface'.  For an
     up-to-date list, *Note Image Specifiers::.  Example:

          ;; Returns `t' if TIFF is supported:
          (featurep 'tiff)

     Another example is:

          ;; Returns a list of `t' or `nil', depending on whether or not the
          ;; corresponding feature is supported:
          (mapcar #'(lambda (format-symbol) (featurep format-symbol))
                  '(gif tiff jpeg xpm png))


   Once you have a glyph, you can then insert it into a buffer.
Example:

     ;; Use this function to insert a glyph at the left edge of point in the
     ;; current buffer.  Any existing glyph at this location is replaced.
     (defun insert-glyph (gl)
       "Insert a glyph at the left edge of point."
       (let ( (prop 'myimage)        ;; myimage is an arbitrary name, chosen
                                     ;; to (hopefully) not conflict with any
                                     ;; other properties.  Change it if
                                     ;; necessary.
              extent )
         ;; First, check to see if one of our extents already exists at
         ;; point.  For ease-of-programming, we are creating and using our
         ;; own extents (multiple extents are allowed to exist/overlap at the
         ;; same point, and it's quite possible for other applications to
         ;; embed extents in the current buffer without your knowledge).
         ;; Basically, if an extent, with the property stored in "prop",
         ;; exists at point, we assume that it is one of ours, and we re-use
         ;; it (this is why it is important for the property stored in "prop"
         ;; to be unique, and only used by us).
         (if (not (setq extent (extent-at (point) (current-buffer) prop)))
           (progn
             ;; If an extent does not already exist, create a zero-length
             ;; extent, and give it our special property.
             (setq extent (make-extent (point) (point) (current-buffer)))
             (set-extent-property extent prop t)
             ))
         ;; Display the glyph by storing it as the extent's "begin-glyph".
         (set-extent-property extent 'begin-glyph gl)
         ))
     
     ;; You can then use this function like:
     (insert-glyph (make-glyph [jpeg :file "/tmp/file1.jpg"]))
     ;; This will insert the glyph at point.
     
     ;; Here's an example of how to insert two glyphs side-by-side, at point
     ;; (using the above code):
     (progn
       (insert-glyph (make-glyph [jpeg :file "/tmp/file1.jpg"]))
       ;; Create a new extent at point.  We can't simply call "insert-glyph",
       ;; as "insert-glyph" will simply replace the first glyph with the
       ;; second.
       (setq extent (make-extent (point) (point) (current-buffer)))
       ;; Here, we're only setting the 'myimage property in case we need
       ;; to later identify/locate/reuse this particular extent.
       (set-extent-property extent 'myimage t)
       (set-extent-property extent 'begin-glyph
                            (make-glyph [jpeg :file "/tmp/file2.jpg"]))
       )

   Here are the gory details:

   * Glyphs are displayed by attaching them to extents (see *Note
     Extents::), either to the beginning or the end of extents.

     Note that extents can be used for many things, and not just for
     displaying images (although, in the above example, we are creating
     our own extent for the sole purpose of displaying an image).
     Also, note that multiple extents are allowed to exist at the same
     position, and they can overlap.

   * Glyphs are often displayed inside the text area (alongside text).
     This is the default.

     Although glyphs can also be displayed in the margins, how to do
     this will not be described here.  For more information on this, see
     *Note Annotation Basics:: (look for information on "layout types")
     and *Note Extent Properties:: (look for `begin-glyph-layout' and
     `end-glyph-layout').

   * The easiest way to insert a glyph into text is to create a
     zero-length extent at the point where you want the glyph to appear.

     Note that zero-length extents are attached to the character to the
     right of the extent; deleting this character will also delete the
     extent.

   * It's often a good idea to assign a unique property to the
     newly-created extent, in case you later want to locate it, and
     replace any existing glyph with a different one (or just delete
     the existing one).  In the above example, we are using "myimage"
     as our (hopefully) unique property name.

     If you need to locate all of the extents, you'll have to use
     functions like `extent-list' or `next-extent', or provide
     additional parameters to the `extent-at' function.  Assigning a
     unique property to the extent makes it easy to locate your
     extents; for example, `extent-list' can return only those extents
     with a particular property.  *Note Finding Extents::, and *Note
     Mapping Over Extents::, for more information.

   * Glyphs are displayed by assigning then to the `begin-glyph' or
     `end-glyph' property of the extent.  For zero-length extents, it
     doesn't really matter if you assign the glyph to the `begin-glyph'
     or `end-glyph' property, as they are both at the same location;
     however, for non-zero-length extents (extents that cover one or
     more characters of text), it does matter which one you use.

     Assigning `nil' to the `begin-glyph' or `end-glyph' property will
     delete any existing glyph.  In this case, you may also want to
     delete the extent, assuming that the extent is used for no other
     purpose.

   * If you happen to insert two glyphs, side-by-side, note that the
     example `insert-glyph' function will have trouble, if it's again
     used at the same point (it can only locate one of the two extents).
     *Note Finding Extents::, and *Note Mapping Over Extents::, for more
     information on locating extents in a buffer.

   * Among other things, glyphs provide a way of displaying graphics
     alongside text.  Note, however, that glyphs only provide a way of
     displaying graphics; glyphs are not actually part of the text, and
     are only displayed alongside the text.  If you save the text in
     the buffer, the graphics are not saved.  The low-level glyph code
     does not provide a way of saving graphics with the text.  If you
     need to save graphics and text, you have to write your own code to
     do this, and this topic is outside the scope of this discussion.



File: lispref.info,  Node: Annotations,  Next: Display,  Prev: Glyphs,  Up: Top

Annotations
***********

   An "annotation" is a pixmap or string that is not part of a buffer's
text but is displayed next to a particular location in a buffer.
Annotations can be displayed intermixed with text, in any whitespace at
the beginning or end of a line, or in a special area at the left or
right side of the frame called a "margin", whose size is controllable.
Annotations are implemented using extents (*note Extents::); but you
can work with annotations without knowing how extents work.

* Menu:

* Annotation Basics::		Introduction to annotations.
* Annotation Primitives::	Creating and deleting annotations.
* Annotation Properties::	Retrieving and changing the characteristics
				  of an annotation.
* Margin Primitives::		Controlling the size of the margins.
* Locating Annotations::	Looking for annotations in a buffer.
* Annotation Hooks::		Hooks called at certain times during an
				  annotation's lifetime.


File: lispref.info,  Node: Annotation Basics,  Next: Annotation Primitives,  Up: Annotations

Annotation Basics
=================

   Marginal annotations are notes associated with a particular location
in a buffer.  They may be displayed in a margin created on the
left-hand or right-hand side of the frame, in any whitespace at the
beginning or end of a line, or inside of the text itself.  Every
annotation may have an associated action to be performed when the
annotation is selected.  The term "annotation" is used to refer to an
individual note.  The term "margin" is generically used to refer to the
whitespace before the first character on a line or after the last
character on a line.

   Each annotation has the following characteristics:
GLYPH
     This is a glyph object and is used as the displayed representation
     of the annotation.

DOWN-GLYPH
     If given, this glyph is used as the displayed representation of
     the annotation when the mouse is pressed down over the annotation.

FACE
     The face with which to display the glyph.

SIDE
     Which side of the text (left or right) the annotation is displayed
     at.

ACTION
     If non-`nil', this field must contain a function capable of being
     the first argument to `funcall'.  This function is normally
     evaluated with a single argument, the value of the DATA field,
     each time the annotation is selected.  However, if the WITH-EVENT
     parameter to `make-annotation' is non-`nil', the function is
     called with two arguments.  The first argument is the same as
     before, and the second argument is the event (a button-up event,
     usually) that activated the annotation.

DATA
     Not used internally.  This field can contain any E-Lisp object.
     It is passed as the first argument to ACTION described above.

MENU
     A menu displayed when the right mouse button is pressed over the
     annotation.

   The margin is divided into "outside" and "inside".  The outside
margin is space on the left or right side of the frame which normal text
cannot be displayed in.  The inside margin is that space between the
leftmost or rightmost point at which text can be displayed and where the
first or last character actually is.

   There are four different "layout types" which affect the exact
location an annotation appears.

`outside-margin'
     The annotation is placed in the outside margin area. as close as
     possible to the edge of the frame.  If the outside margin is not
     wide enough for an annotation to fit, it is not displayed.

`inside-margin'
     The annotation is placed in the inside margin area, as close as
     possible to the edge of the frame.  If the inside margin is not
     wide enough for the annotation to fit, it will be displayed using
     any available outside margin space if and only if the specifier
     `use-left-overflow' or `use-right-overflow' (depending on which
     side the annotation appears in) is non-`nil'.

`whitespace'
     The annotation is placed in the inside margin area, as close as
     possible to the first or last non-whitespace character on a line.
     If the inside margin is not wide enough for the annotation to fit,
     it will be displayed if and only if the specifier
     `use-left-overflow' or `use-right-overflow' (depending on which
     side the annotation appears in) is non-`nil'.

`text'
     The annotation is placed at the position it is inserted.  It will
     create enough space for itself inside of the text area.  It does
     not take up a place in the logical buffer, only in the display of
     the buffer.

   The current layout policy is that all `whitespace' annotations are
displayed first.  Next, all `inside-margin' annotations are displayed
using any remaining space.  Finally as many `outside-margin'
annotations are displayed as possible.  The `text' annotations will
always display as they create their own space to display in.


File: lispref.info,  Node: Annotation Primitives,  Next: Annotation Properties,  Prev: Annotation Basics,  Up: Annotations

Annotation Primitives
=====================

 - Function: make-annotation glyph &optional position layout buffer
          with-event d-glyph rightp
     This function creates a marginal annotation at position POSITION in
     BUFFER.  The annotation is displayed using GLYPH, which should be
     a glyph object or a string, and is positioned using layout policy
     LAYOUT.  If POSITION is `nil', point is used.  If LAYOUT is `nil',
     `whitespace' is used.  If BUFFER is `nil', the current buffer is
     used.

     If WITH-EVENT is non-`nil', then when an annotation is activated,
     the triggering event is passed as the second arg to the annotation
     function.  If D-GLYPH is non-`nil' then it is used as the glyph
     that will be displayed when button1 is down.  If RIGHTP is
     non-`nil' then the glyph will be displayed on the right side of
     the buffer instead of the left.

     The newly created annotation is returned.

 - Function: delete-annotation annotation
     This function removes ANNOTATION from its buffer.  This does not
     modify the buffer text.

 - Function: annotationp annotation
     This function returns `t' if ANNOTATION is an annotation, `nil'
     otherwise.

