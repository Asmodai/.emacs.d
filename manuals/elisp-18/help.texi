@c -*-texinfo-*-
@setfilename ../info/help
@node Documentation, Files, Modes, Top
@chapter Documentation
@cindex documentation strings

  GNU Emacs Lisp has convenient on-line help facilities, most of which
derive their information from the documentation strings associated with
functions and variables.  This chapter describes how to write good
documentation strings for your Lisp programs, as well as how to write
programs to access documentation.

  Note that the documentation strings for Emacs are not the same thing
as the Emacs manual.  Manuals have their own source files, written in
the Texinfo language; documentation strings are specified in the
definitions of the functions and variables they apply to.  A collection
of documentation strings is not sufficient as a manual because a good
manual is not organized in that fashion; it is organized in terms of
topics of discussion.

@menu
* Documentation Basics::      Good style for doc strings.
                                Where to put them.  How Emacs stores them.
* Accessing Documentation::   How Lisp programs can access doc strings.
* Keys in Documentation::     Substituting current key bindings.
* Describing Characters::     Making printable descriptions of
                                non-printing characters and key sequences.
* Help Functions::            Subroutines used by Emacs help facilities.
@end menu

@node Documentation Basics, Accessing Documentation, Documentation, Documentation
@comment  node-name,  next,  previous,  up
@section Documentation Basics
@cindex documentation conventions
@cindex writing a documentation string
@cindex string, writing a documentation string

  A documentation string is written using the Lisp syntax for strings,
with double-quote characters surrounding the text of the string.  This
is because it really is a Lisp string object.  The string serves as
documentation when it is written in the proper place in the definition
of a function or variable.  In a function definition, the documentation
string follows the argument list.  In a variable definition, the
documentation string follows the initial value of the variable.

  When you write a documentation string, make the first line a complete
sentence (or two complete sentences) since some commands, such as
@code{apropos}, print only the first line of a multi-line documentation
string.  Also, you should not indent the second line of a documentation
string, if you have one, because that looks odd when you use @kbd{C-h f}
(@code{describe-function}) or @kbd{C-h v} (@code{describe-variable}).

  Documentation strings may contain several special substrings, which
stand for key bindings to be looked up in the current keymaps when the
documentation is displayed.  This allows documentation strings to refer
to the keys for related commands and be accurate even when a user
rearranges the key bindings.  (@xref{Accessing Documentation}.)

  Within the Lisp world, a documentation string is kept with the
function or variable that it describes:

@itemize @bullet
@item
The documentation for a function is stored in the function definition
itself (@pxref{Lambda Expressions}).  The function
@code{documentation} knows how to extract it.

@item
@kindex variable-documentation
The documentation for a variable is stored on the variable's property
list under the property name @code{variable-documentation}.  The
function @code{documentation-property} knows how to extract it.
@end itemize

@cindex @file{DOC} (documentation) file
@cindex @file{emacs/etc/DOC-@var{version}}
@cindex @file{etc/DOC-@var{version}}
  However, to save space, the documentation for preloaded functions and
variables (including primitive functions and autoloaded functions) are
stored in the @file{emacs/etc/DOC-@var{version}} file.  Both the
@code{documentation} and the @code{documentation-property} functions
know how to access @file{emacs/etc/DOC-@var{version}}, and the process
is transparent to the user.  In this case, the documentation string is
replaced with an integer offset into the
@file{emacs/etc/DOC-@var{version}} file.  Keeping the documentation
strings out of the Emacs core image saves a significant amount of space.
@xref{Building Emacs}.

  For information on the uses of documentation strings, see
@code{where-is-internal} and @code{describe-bindings} in @ref{Global and
Local Keymaps}.  Also, see @ref{Help, , Help, emacs, The GNU Emacs
Manual}.

  The @file{emacs/etc} directory contains two utilities for printing
the @file{emacs/etc/DOC-@var{version}} file in hardcopy.  These are
@file{sorted-doc.c} and @file{digest-doc.c}.

@node Accessing Documentation, Keys in Documentation, Documentation Basics, Documentation
@section Access to Documentation Strings

@defun documentation-property symbol property
  This function returns the documentation string that is recorded
@var{symbol}'s property list under property @var{property}.  This uses
the function @code{get}, but does more than that: it also retrieves the
string from the file @file{emacs/etc/DOC-@var{version}} if necessary,
and runs @code{substitute-command-keys} to substitute the actual
(current) key bindings.

@example
(documentation-property 'command-line-processed
   'variable-documentation)
     @result{} "t once command line has been processed"
(symbol-plist 'command-line-processed)
     @result{} (variable-documentation 188902)
@end example
@end defun

@defun documentation function
  This function returns the documentation string of @var{function}.  If
the documentation string is stored in the
@file{emacs/etc/DOC-@var{version}} file, this function will access it
there.

  In addition, @code{documentation} runs @code{substitute-command-keys}
on the resulting string, so the value contains the actual (current)
key bindings.

  The function @code{documentation} signals a @code{void-function} error
unless @var{function} has a function definition.  However,
@var{function} does not need to have a documentation string.  If there
is no documentation string, @code{documentation} returns @code{nil}.

  Here is an example of using @code{documentation} and
@code{documentation-property} to display the documentation strings for
several symbols in a @samp{*Help*} buffer.

@example
(defun describe-symbols (pattern)
  "Describe the Emacs Lisp symbols matching PATTERN.
All symbols that have PATTERN in their name are described
in the *Help* buffer."
  (interactive "sDescribe symbols matching: ")
  (let ((describe-func
         (function 
          (lambda (s)
            ;; @r{Print description of symbol.}
            (if (fboundp s)             ; @r{It is a function.}
                (princ
                 (format "%s\t%s\n%s\n\n" s
                         (if (commandp s) 
                             (concat "Command: "
                                     (or (mapconcat 
                                          'key-description 
                                          (where-is-internal s) 
                                          " ")))
                           "Function")
                         (or (documentation s) 
                             "not documented"))))
            
            (if (boundp s)              ; @r{It is a variable.}
                (princ
                 (format "%s\t%s\n%s\n\n" s
                         (if (user-variable-p s) 
                             "Option " "Variable")
                         (or (documentation-property 
                               s 'variable-documentation)
                             "not documented")))))))
         sym-list)

    ;; @r{Build a list of symbols that match pattern.}
    (mapatoms (function 
               (lambda (sym)
                 (if (string-match pattern (symbol-name sym))
                     (setq sym-list (cons sym sym-list))))))

    ;; @r{Display the data.}
    (with-output-to-temp-buffer "*Help*"
      (mapcar describe-func (sort sym-list 'string<))
      (print-help-return-message))))
@end example

  The @code{describe-symbols} function works like @code{apropos},
but provides more information.

@example
(describe-symbols "goal")

---------- Buffer: *Help* ----------
goal-column     Option 
*Semipermanent goal column for vertical motion, 
as set by C-x C-n, or nil.

set-goal-column Command: C-x C-n
Set the current horizontal position as a goal for C-n and C-p.
Those commands will move to this position in the line moved to
rather than trying to keep the same horizontal position.
With a non-nil argument, clears out the goal column
so that C-n and C-p resume vertical motion.

temporary-goal-column   Variable
Current goal column for vertical motion.
It is the column where point was at the start of current run 
of vertical motion commands.
---------- Buffer: *Help* ----------
@end example
@end defun

@defun Snarf-documentation filename
  This function is used only during Emacs initialization, just before
the runnable Emacs is dumped.  It finds the file offsets of the
documentation strings stored in the file @var{filename}, and records
them in the in-core function definitions and variable property lists in
place of the actual strings.  @xref{Building Emacs}.

  The file @var{filename} is found in the @file{emacs/etc} directory
(usually @var{filename} is @code{"DOC-@var{version}"}).  When the dumped
Emacs is later executed, the same file is found in the
@code{exec-directory} (@pxref{Subprocess Creation}).
@end defun

@node Keys in Documentation, Describing Characters, Accessing Documentation, Documentation
@section Substituting Key Bindings in Documentation
@cindex documentation, keys in
@cindex keys in documentation strings
@cindex substituting keys in documentation

@defun substitute-command-keys string
  This function returns @var{string} with certain special substrings
replaced by the actual (current) key bindings are listed.  This permits
the documentation to be displayed with accurate information about key
bindings.  (The key bindings may be changed by the user between the time
Emacs is built and the time that the documentation is asked for.)

  This table lists the forms of the special substrings and what they are
replaced with:

@table @code
@item \[@var{command}]
is replaced either by a keystroke sequence that will invoke
@var{command}, or by @samp{M-x @var{command}} if @var{command} is not
bound to any key sequence.

@item \@{@var{mapvar}@} 
is replaced by a summary (made by @code{describe-bindings}) of the value
of @var{mapvar}, taken as a keymap.

@item \<@var{mapvar}> 
makes this call to @code{substitute-command-keys} use the value of
@var{mapvar} as the keymap for future @samp{\[@var{command}]}
substrings.  This special string does not produce any replacement text
itself; it only affects the replacements done later.
@end table

@strong{Note:} each @samp{\} must be doubled when written in a string in
Emacs Lisp.

  Here are examples of the special substrings:

@example
(substitute-command-keys 
   "To abort recursive edit, type: \\[abort-recursive-edit]")

@result{} "To abort recursive edit, type: C-]"

(substitute-command-keys 
   "The keys that are defined for the minibuffer here are:
  \\@{minibuffer-local-must-match-map@}")

@result{} "The keys that are defined for the minibuffer here are:

?               minibuffer-completion-help
SPC             minibuffer-complete-word
TAB             minibuffer-complete
LFD             minibuffer-complete-and-exit
RET             minibuffer-complete-and-exit
C-g             abort-recursive-edit
"

(substitute-command-keys
   "To abort a recursive edit from the minibuffer, type\
 \\<minibuffer-local-must-match-map>\\[abort-recursive-edit].")
@result{} "To abort a recursive edit from the minibuffer, type C-g."
@end example
@end defun

@node Describing Characters, Help Functions, Keys in Documentation, Documentation
@section Describing Characters for Help Messages

  These functions convert characters or strings to textual descriptions.
These descriptions are useful for including arbitrary text characters or
key sequences in messages, because they convert non-printing characters
to sequences of printing characters.  The description of a printing
character is the character itself.

@defun key-description string
@cindex Emacs character standard notation
  This function returns a string containing the Emacs standard notation
for the keyboard characters in @var{string}.  See the examples for
@code{single-key-description}.
@end defun

@defun single-key-description character
@cindex character printing
@cindex control character printing
@cindex meta character printing
  This function returns a string describing @var{character} in the
standard Emacs notation for keyboard input.  A normal printing character
is represented by itself, but a control character turns into a string
starting with @samp{C-}, a meta character turns into a string starting
with @samp{M-}, and space, linefeed, etc. are transformed to @samp{SPC},
@samp{LFD}, etc.

@example
(single-key-description ?\C-x)
     @result{} "C-x"
(key-description "\C-x \M-y \n \t \r \f123")
     @result{} "C-x SPC M-y SPC LFD SPC TAB SPC RET SPC C-l 1 2 3"
@end example
@end defun

@defun text-char-description character
  This function returns a string describing @var{character} in the
standard Emacs notation for characters that appear in text---like
@code{single-key-description}, except that that control characters are
represented with a leading caret (which is how control characters in
Emacs buffers are usually displayed).

@example
(text-char-description ?\C-c)
     @result{} "^C"
(text-char-description ?\M-m)
     @result{} "M-m"
(text-char-description ?\C-\M-m)
     @result{} "M-^M"
@end example
@end defun

@node Help Functions,  , Describing Characters, Documentation
@section Help Functions

  Emacs provides a variety of on-line help functions, all accessible to
the user as subcommands of the prefix @kbd{C-h}.  For more information
about them, see @ref{Help, , Help, emacs, The GNU Emacs Manual}.  Here
we describe some program-level interfaces to the same information.

@deffn Command apropos regexp &optional predicate noprint
  This function finds all symbols whose names contain a match for the
regular expression @var{regexp}, and returns a list of them.  Normally
it displays the symbols in a buffer named @samp{*Help*}, each with a
one-line description.  If @var{noprint} is non-@code{nil}, it does not
display them, but just returns the list.

  If @var{predicate} is non-@code{nil}, it should be a function to be
called on each symbol that has matched @var{regexp}.  Only symbols for
which @var{predicate} returns a non-@code{nil} value are listed or
displayed.

  When you call @code{apropos} interactively, it prompts for
@var{regexp} in the minibuffer.

  In the first of the following examples, @code{apropos} finds all the
symbols with names containing @samp{exec}.  They are returned but not
displayed.  In the second example, it finds and returns only those
symbols that are also commands; in addition, they are then displayed in
the @samp{*Help*} buffer.

@example
(apropos "exec" nil t)
     @result{} (Buffer-menu-execute command-execute exec-directory
    exec-path execute-extended-command execute-kbd-macro
    executing-kbd-macro executing-macro)

(apropos "exec" 'commandp)
     @result{} (Buffer-menu-execute execute-extended-command)

---------- Buffer: *Help* ----------
Buffer-menu-execute
  Function: Save and/or delete buffers marked with
  M-x Buffer-menu-save or M-x Buffer-menu-delete commands.
execute-extended-command      ESC x
  Function: Read function name, then read its arguments and call it.
---------- Buffer: *Help* ----------
@end example

  The command @kbd{C-h a} (@code{command-apropos}) calls @code{apropos},
but specifies a @var{predicate} to restrict the output to symbols that
are commands.  The call to @code{apropos} looks like this:

@example
(apropos string 'commandp)
@end example
@end deffn

@deffn Command help-command
  This command is not a function, but rather a symbol which is
equivalent to the keymap called @code{help-map}.  It is defined in
@file{help.el} as follows:

@example
(define-key global-map "\C-h" 'help-command)
(fset 'help-command help-map)
@end example
@end deffn

@defvar help-map
  The value of this variable is a local keymap for characters following the
Help key, @kbd{C-h}.
@end defvar

@defun print-help-return-message &optional function
  This function builds a string which is a message explaining how to
restore the previous state of the windows after a help command.  After
building the message, it applies @var{function} to it if @var{function}
is non-@code{nil}.  Otherwise it calls @code{message} to display it in
the echo area.

This function expects to be called inside a
@code{with-output-to-temp-buffer} special form, and expects
@code{standard-output} to have the value bound by that special form.
For an example of its use, see the example in the section describing the
@code{documentation} function (@pxref{Accessing Documentation}).

The constructed message will have one of the forms shown below.

@example
---------- Echo Area ----------
Type C-x 1 to remove help window.
---------- Echo Area ----------

---------- Echo Area ----------
Type C-x 4 b RET to restore old contents of help window.
---------- Echo Area ----------
@end example
@end defun

@defvar help-char
  The value of this variable is the character that Emacs recognizes as
meaning Help.  When Emacs reads this character (which is usually 8, the
value of @kbd{C-h}), Emacs evaluates @code{(eval help-form)}, and
displays the result if it is a string.  If @code{help-form}'s value is
@code{nil}, this character is read normally.
@end defvar

@defvar help-form
  The value of this variable is a form to execute when the character
@code{help-char} is read.  If the form returns a string, that string is
displayed.  If @code{help-form} is @code{nil}, then the help character
is not recognized.

  Entry to the minibuffer binds this variable to the value of
@code{minibuffer-help-form}.
@end defvar

  The following two functions are found in the library @file{helper}.
They are for modes that want to provide help without relinquishing
control, such as the ``electric'' modes.  You must load that library
with @code{(require 'helper)} in order to use them.  Their names begin
with @samp{Helper} to distinguish them from the ordinary help functions.

@deffn Command Helper-describe-bindings
  This command pops up a window displaying a help buffer containing a
listing of all of the key bindings from both the local and global keymaps.
It works by calling @code{describe-bindings}.
@end deffn

@deffn Command Helper-help
  This command provides help for the current mode.  It prompts the user
in the minibuffer with the message @samp{Help (Type ? for further
options)}, and then provides assistance in finding out what the key
bindings are, and what the mode is intended for.  It returns @code{nil}.

  This can be customized by changing the map @code{Helper-help-map}.
@end deffn
